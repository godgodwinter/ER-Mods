

-- CUSTOM: Begin.
--############################################################################--
---------------------------- MODIFY ALL OPTIONS HERE ---------------------------


-- You can use ER HKS Hotloader to reload the script file without restarting the game.
-- (https://github.com/A1steaksa/Elden-Ring-HKS-Hotloader)


--------------------------------------------------------------------------------
----------------------------------- SHORTCUTS ----------------------------------

-- Hold R1&R2 + press Y: Switch Custom Movesets modes.
-- Hold R1    + press Y: Next list of movesets (switch to first list of movesets upon reaching the last one).
-- Hold R2    + press Y: Previous list of movesets (switch to last list of movesets upon reaching the first one).
-- Hold L1    + press Y: Switch Guard-Cancel modes.
-- Hold B     + press Y: Switch Evasion-Cancel modes.
-- Hold A     + press Y: Switch Jump-Cancel modes.

-- Allow using a combination of buttons to switch modes.
-- Mode 0: Disable.
-- Mode 1: Enable.
DMN_OptionShortcuts_Mode = 1


--------------------------------------------------------------------------------
------------------------------------ DEFLECT -----------------------------------

-- Time to open the deflect window after pressing L1 (in milliseconds).
DMN_DeflectDuration_Time = 200

-- Time to trigger a perfect deflect (in milliseconds).
DMN_DeflectPerfect_Time = 100

-- The penalty duration during which the deflect window will shrink if you fail to deflect an attack (in milliseconds).
-- Set to 0 to disable the penalty to deflect window time.
DMN_DeflectPenalty_Duration = 200

-- The percentage (%) to shrink the deflect window during the penalty duration.
-- Set to 0 to use the number of milliseconds below.
DMN_DeflectPenalty_Percent = 50

-- The number of milliseconds to shrink the deflect window during the penalty duration (in milliseconds).
DMN_DeflectPenalty_Amount = 50

-- Cooldown time to reopen the deflect window after failing to deflect an attack (in milliseconds).
DMN_DeflectCooldown_Time = 50

----------------------------------------
-- Adjust the deflect window status on successful deflect.
-- Mode 1: Clear the deflect window (must press L1 again to deflect the next attack).
-- Mode 2: Keep the deflect window open until the end of its duration.
-- Mode 3: Refresh the duration of the deflect window.
DMN_DeflectStatus_Mode = 3

-- Adjust the playstyle when deflecting an attack.
-- Mode 1: Hold L1 to deflect an attack.
-- Mode 2: Tap L1 to deflect an attack.
DMN_DeflectStyle_Mode = 2

----------------------------------------
-- Adjust damage dealt by deflect counter.
-- Mode 0: Disable.
-- Mode 1: Deal a fixed amount of damage with each successful deflect.
-- Mode 2: Deal an increased amount of damage with each successful deflect.
-- Mode 3: Deal a different amount of damage, depending on how strong the attack is. (blocking front attacks only).
DMN_DeflectCounter_Mode = 3

-- Level of HP damage dealt by deflect counter.
-- x10% for each level.
DMN_DeflectDamage_Level = 1

-- Level of poise damage dealt by deflect counter.
-- x10% for each level.
DMN_DeflectPower_Level = 1

-- Bonus level to HP damage when triggering a perfect deflect.
DMN_DeflectDamage_Bonus = 3

-- Bonus level to poise damage when triggering a perfect deflect.
DMN_DeflectPower_Bonus = 3

----------------------------------------
-- Adjust restorative power on successful deflect.
-- Mode 0: Disable.
-- Mode 1: Restore a fixed amount with each successful deflect.
-- Mode 2: Restore an increased amount with each successful deflect.
-- Mode 3: Restore a different amount, depending on how strong the attack is. (blocking front attacks only).
DMN_DeflectRestore_Mode = 3

-- Amount of HP restored on successful deflect.
DMN_DeflectRestore_HP = 5

-- Amount of FP restored on successful deflect.
DMN_DeflectRestore_FP = 5

-- Amount of SP restored on successful deflect.
DMN_DeflectRestore_SP = 5

----------------------------------------
-- Adjust how the deflect effect will be applied to attacker.
-- Mode 1: Hit all targets around your character.
-- Mode 2: Hit the targets in front of your character.
DMN_DeflectEffect_Mode = 1

-- Adjust repellent power when deflecting an attack.
-- Mode 0: Default (use equipment stats).
-- Mode 1: Do not break enemy stance.
-- Mode 2: Break enemy stance after deflecting an attack.
DMN_DeflectRepel_Mode = 1

----------------------------------------
-- Adjust the protection when deflect status is active.
-- Mode 1: Protect from front only.
-- Mode 2: Protect from front, left and right.
-- Mode 3: Protect from all directions.
DMN_DeflectProtect_Mode = 2

-- Adjust escape action when deflect status is active.
-- Mode 0: Disable.
-- Mode 1: Turn back.
-- Mode 2: Roll forward.
-- Mode 3: Jump forward.
DMN_DeflectEscape_Mode = 1

-- Evade critical attack when deflect status is active.
-- Mode 0: Disable.
-- Mode 1: Enable.
DMN_DeflectEvade_Mode = 1

----------------------------------------
-- Adjust the animations when deflecting an attack.
-- Mode 0: Use default animations (guarding).
-- Mode 1: Mix default and repel animations.
-- Mode 2: Use Sekiro's animations.
-- Mode 3: Use Lady Butterfly's animations.
DMN_DeflectAnimation_Mode = 2

-- Adjust whether the character is pushed back when deflecting an attack.
-- Mode 0: Default.
-- Mode 1: Being pushed back by medium, strong and very strong attacks only.
-- Mode 2: Being pushed back by very strong attacks only.
-- Mode 3: No pushback.
DMN_DeflectPushback_Mode = 0

-- Chance (%) to get pushed back when deflecting a light attack (0 - 100).
-- This option will use different animations and is independent of the pushback mode above.
DMN_DeflectPushback_Chance = 10

-- Chance (%) to get knocked back when deflecting a medium attack (0 - 100).
-- This option will use different animations and is independent of the pushback mode above.
DMN_DeflectKnockback_Chance = 10

----------------------------------------
-- Adjust the ability to deflect an attack while attacking with a weapon (including normal attacks and AoWs).
-- Mode 0: Disable.
-- Mode 1: Deflect and stop the current attack.
-- Mode 2: Deflect and stop the current attack, interrupt enemy attack.
-- Mode 3: Deflect and continue the current attack.
-- Mode 4: Deflect and continue the current attack, interrupt enemy attack.
DMN_AttackCounter_Mode = 1

-- Allow refreshing deflect status when using attack counter.
-- Mode 0: Disable.
-- Mode 1: Enable.
DMN_AttackCounterRefresh_Mode = 1

-- Adjust the ability to deflect an attack with left-hand actions (casting magic/lighting up torch).
-- Mode 0: Disable.
-- Mode 1: Enable.
DMN_DeflectExtends_Mode = 1

----------------------------------------
-- Enable additional visual effect when deflecting an attack (Sekiro flashing light).
-- Mode 0: Disable.
-- Mode 1: Enable for perfect deflect only.
-- Mode 2: Enable for normal deflect and perfect deflect.
DMN_DeflectVFX_Mode = 2

-- Adjust the intensity of visual effects when deflecting an attack (0 = Auto, 1-3 = Custom).
DMN_DeflectVFX_Level = 0

----------------------------------------
-- Always allow the following AoWs to deflect an attack.
-- Check "Sword Arts Type" under "SwordArtsParam" in the regulation file for ID.
DMN_DeflectAoWs_Table =
{-- TABLE-BEGIN.
	90,		-- Shield Bash.
	98,		-- Shield Crash.
	6,		-- Stamp (Upward Cut).
	7,		-- Stamp (Sweep).
	14		-- Unsheathe.
}-- TABLE-END.


--------------------------------------------------------------------------------
------------------------------ DEFLECT ACCUMULATE ------------------------------

-- Adjust the number of stacks each time you deflect an attack.
-- Mode 0: Increase the number of stacks each time you deflect an attack.
-- Mode 1: Decrease the number of stacks each time you fail to deflect an attack.
-- Mode 2: Reset the number of stacks if you fail to deflect two or more attacks in a row.
-- Mode 3: Reset the number of stacks if you fail to deflect an attack.
DMN_AccumulateDeflect_Mode = 1

-- Adjust HP and poise damage multiplier bonus when accumulating stacks.
-- Mode 1: Activate multiplier bonus only after a number of successful deflect.
-- Mode 2: Activate multiplier bonus every time you deflect an attack, according to the number of stacks accumulated.
DMN_AccumulateBonus_Mode = 1

----------------------------------------
-- Boost damage multiplier after a number of successful deflect.
-- x10% for each level.
DMN_AccumulateAttack_Level = 3

-- Boost poise damage multiplier after a number of successful deflect.
-- x10% for each level.
DMN_AccumulatePower_Level = 3

-- Boost defense multiplier after a number of successful deflect.
-- x10% for each level.
DMN_AccumulateDefense_Level = 3

----------------------------------------
-- Number of successful deflect to enter super power state.
DMN_AccumulateDeflect_Number = 10

-- Duration of super power state (in seconds).
DMN_AccumulateDuration_Time = 10

-- Time to reset number of successful deflect and super power state (in seconds).
DMN_AccumulateTimeout_Time = 10

----------------------------------------
-- Enable additional visual effects when using deflect accumulate.
-- Mode 0: Disable.
-- Mode 1: Enable.
DMN_AccumulateDeflect_VFX = 1


--------------------------------------------------------------------------------
--------------------------------- ACTION CANCEL --------------------------------

-- Cancel actions with guard-cancel.
-- Mode 0: Disable.
-- Mode 1: Override normal guard with guard-cancel.
DMN_GuardCancel_Mode = 0

-- Cancel actions with roll-cancel/step-cancel.
-- Mode 0: Disable.
-- Mode 1: Override normal roll/backstep with roll-cancel/step-cancel.
-- Mode 2: Override normal roll/backstep and remove input lag (you have to trigger a roll or a backstep first before sprinting).
DMN_EvasionCancel_Mode = 0

-- Cancel actions with jump-cancel.
-- Mode 0: Disable.
-- Mode 1: Override normal jump with jump-cancel.
-- Mode 2: Override normal jump and enable double-jump.
-- Mode 3: Override normal jump and enable infinite jumping in the air.
DMN_JumpCancel_Mode = 0

-- Adjust behavior of action-cancel ability.
-- Mode 0: Default.
-- Mode 1: Disable usage while being hit or knocked down.
-- Mode 2: Allow usage even while being hit or knocked down.
DMN_ActionCancel_Mode = 0

----------------------------------------
-- Additional stamina needed to perform action-cancel.
DMN_ActionCancel_CostSP = 0

----------------------------------------
-- Enable additional visual effects when using action-cancel.
-- Mode 0: Disable.
-- Mode 1: Enable.
DMN_ActionCancel_VFX = 1


--------------------------------------------------------------------------------
------------------------------ MOVEMENT & ACTIONS ------------------------------

-- Replace the default rolling/backstep actions with custom animations.
-- Mode 0: Disable.
-- Mode 1: Use Sekiro animations.
-- Mode 2: Use Bloodhound animations.
-- Mode 3: Use Lady Butterfly animations.
DMN_EvasionAction_Mode = 1

-- Enable sprinting just by using left-stick (no need to hold the sprint button).
-- Mode 0: Default.
-- Mode 1: After activating sprinting, tilt the stick to continue sprinting.
-- Mode 2: Tilt the stick to max to activate sprinting, when not using lock-on.
-- Mode 3: Tilt the stick to max to activate sprinting, even when using lock-on.
DMN_Sprinting_Mode = 1

-- Adjust running speed.
-- +10% for each level.
DMN_RunningSpeed_Level = 0

-- Adjust rolling distance.
-- +10% for each level.
DMN_RollingDistance_Level = 0

-- Adjust backstep distance.
-- +10% for each level.
DMN_BackstepDistance_Level = 0

-- Adjust jump height.
-- +10% for each level.
DMN_JumpHeight_Level = 0


--------------------------------------------------------------------------------
----------------------------------- GAMEPLAY -----------------------------------

-- Use Lady Butterfly's left and right-hand attacks to attach the invisible strings to the field.  
-- When the strings turn red, use Special Attack 1 or 2 to activate String Master's Judgment, attacking all enemies in a large area.  
-- Mode 0: Disable.
-- Mode 1: Enable.
DMN_StringMaster_Mode = 1

-- The number of stacks required to activate the String Master's Judgment attack.
DMN_StringMaster_MaxStacks = 10

-- Reset the number of stacks to 0 when there are no strings attached to the field after the time runs out (in seconds).
DMN_StringMaster_Timeout = 30

-- Press A while attacking to jump into the air and stand on an invisible string.
-- Mode 0: Disable.
-- Mode 1: Enable.
DMN_StringMaster_AirRetreat = 0


--------------------------------------------------------------------------------
------------------------------------ PLAYER ------------------------------------

-- Boost the amount of runes gained when finishing an enemy with critical attacks (x2 effective for backstab).
-- x10% for each level.
DMN_RuneGain_Level = 5

-- The number of times your character will be revived.
-- This does not apply to certain cases.
DMN_AutoRevive_Number = 1

----------------------------------------
-- Decrease your character's attack (use this when you're too overpowered).
-- x10% for each level.
DMN_DecreaseAttack_Level = 0

-- Decrease your character's defense (use this when you're too overpowered).
-- x10% for each level.
DMN_DecreaseDefense_Level = 0

----------------------------------------
-- Regen HP.
-- +1 HP/s for each level.
DMN_RegenHP_Level = 0

-- Regen FP.
-- +1 FP/s for each level.
DMN_RegenFP_Level = 0

-- Regen Stamina.
-- +1 SP/s for each level.
DMN_RegenSP_Level = 0

----------------------------------------
-- Increase Item Discovery.
-- +100 for each level.
DMN_ItemDiscovery_Level = 0

-- Increase Max Equip Load.
-- x10% for each level.
DMN_MaxEquipLoad_Level = 0

-- Increase Arrow Distance.
-- +10% for each level.
DMN_ArrowDistance_Level = 0


--------------------------------------------------------------------------------
------------------------------------ TORRENT -----------------------------------

-- Enable Torrent to jump infinitely in the air.
-- Mode 0: Disable.
-- Mode 1: Enable.
DMN_CloudChasing_Mode = 0


--------------------------------------------------------------------------------
------------------------------------- ENEMY ------------------------------------

-- Adjust how enemy will react when they are fighting (Deflect/Backstab/Critical attacks will not trigger enemy alerts).
-- Mode 0: Default.
-- Mode 1: Alert nearby enemies in a small area.
-- Mode 2: Alert nearby enemies in a large area.
-- Mode 3: Alert nearby enemies in a very large area.
DMN_EnemyAlert_Mode = 0

-- Adjust how easily enemy will see you.
-- x10% for each level.
DMN_EnemyVision_Level = 0

-- Adjust how easily enemy will hear you.
-- x10% for each level.
DMN_EnemyHearing_Level = 0

----------------------------------------
-- Chance (%) to confuse enemy when triggering a perfect deflect (0 - 100).
DMN_EnemyConfusion_Chance = 0

-- Duration of confusion status applied to enemy.
-- 0: Disable.
-- 1: 10 seconds.
-- 2: 20 seconds.
-- 3: 30 seconds.
DMN_EnemyConfusion_Time = 0

-- Enemy will lose the ability to recover poise HP for a short time, after a perfect deflect.
-- 0: Disable.
-- 1: 3 seconds.
-- 2: 5 seconds.
-- 3: 10 seconds.
DMN_EnemyRecoveryCooldown_Time = 0


--------------------------------------------------------------------------------
----------------------------------- MOVESETS -----------------------------------

-- Time for guard counter window after a successful guard/deflect (in milliseconds).
DMN_GuardCounter_Time = 600

-- Hold L1 and press R1/R2 to enter a guard stance, counter with an attack upon enemy hit.
-- Custom Movesets must be enabled for this feature to work.
-- Mode 0: Disable.
-- Mode 1: Enable guard stance with R1.
-- Mode 2: Enable guard stance with R2.
-- Mode 3: Enable guard stance with R1/R2.
DMN_GuardStance_Mode = 3

-- Enable custom movesets for all weapons.
-- Mode 0: Default.
-- Mode 1: Use custom movesets.
DMN_CustomMovesets_Mode = 1

-- Multiplier for cooldown time between each attacks (1.0 = 30 frames).
-- Set to 0 to disable custom timing and use in-game cooldown time.
DMN_ComboCooldown_Multiplier = 0

-- Default attacks.
RIGHT_LIGHT1, RIGHT_LIGHT2, RIGHT_LIGHT3, RIGHT_LIGHT4, RIGHT_LIGHT5, RIGHT_LIGHT6									= "W_AttackRightLight1", "W_AttackRightLight2", "W_AttackRightLight3", "W_AttackRightLight4", "W_AttackRightLight5", "W_AttackRightLight6"
RIGHT_HEAVY1, RIGHT_HEAVY1_CHARGE, RIGHT_HEAVY2, RIGHT_HEAVY2_CHARGE												= "W_AttackRightHeavy1End", "W_AttackRightHeavy1Start", "W_AttackRightHeavy2End", "W_AttackRightHeavy2Start"
RIGHT_DASH1, RIGHT_DASH2, RIGHT_ROLL, RIGHT_STEP, RIGHT_EVADE, RIGHT_STEALTH										= "W_AttackRightLightDash", "W_AttackRightHeavyDash", "W_AttackRightLightStep", "W_AttackRightBackstep", "W_AttackRightSpecial2", "W_AttackRightLightStealth"
RIGHT_SPECIAL1, RIGHT_SPECIAL1_CHARGE, RIGHT_SPECIAL2, RIGHT_SPECIAL2_CHARGE, RIGHT_COUNTER							= "W_AttackRightHeavySpecial1End", "W_AttackRightHeavySpecial1Start", "W_AttackRightHeavySpecial2End", "W_AttackRightHeavySpecial2Start", "W_AttackRightHeavyCounter"

BOTH_LIGHT1, BOTH_LIGHT2, BOTH_LIGHT3, BOTH_LIGHT4, BOTH_LIGHT5, BOTH_LIGHT6										= "W_AttackBothLight1", "W_AttackBothLight2", "W_AttackBothLight3", "W_AttackBothLight4", "W_AttackBothLight5", "W_AttackBothLight6"
BOTH_HEAVY1, BOTH_HEAVY1_CHARGE, BOTH_HEAVY2, BOTH_HEAVY2_CHARGE													= "W_AttackBothHeavy1End", "W_AttackBothHeavy1Start", "W_AttackBothHeavy2End", "W_AttackBothHeavy2Start"
BOTH_DASH1, BOTH_DASH2, BOTH_ROLL, BOTH_STEP, BOTH_EVADE, BOTH_STEALTH												= "W_AttackBothDash", "W_AttackBothHeavyDash", "W_AttackBothLightStep", "W_AttackBothBackstep", "W_AttackBothSpecial2", "W_AttackBothLightStealth"
BOTH_SPECIAL1, BOTH_SPECIAL1_CHARGE, BOTH_SPECIAL2, BOTH_SPECIAL2_CHARGE, BOTH_COUNTER								= "W_AttackBothHeavySpecial1End", "W_AttackBothHeavySpecial1Start", "W_AttackBothHeavySpecial2End", "W_AttackBothHeavySpecial2Start", "W_AttackBothHeavyCounter"

DUAL_LIGHT1, DUAL_LIGHT2, DUAL_LIGHT3, DUAL_LIGHT4, DUAL_LIGHT5, DUAL_LIGHT6										= "W_AttackDualLight1", "W_AttackDualLight2", "W_AttackDualLight3", "W_AttackDualLight4", "W_AttackDualLight5", "W_AttackDualLight6"
DUAL_DASH, DUAL_ROLL, DUAL_STEP, DUAL_STEALTH																		= "W_AttackDualDash", "W_AttackDualRolling", "W_AttackDualBackStep", "W_AttackDualStealth"
LEFT_LIGHT1, LEFT_LIGHT2, LEFT_LIGHT3, LEFT_LIGHT4, LEFT_LIGHT5, LEFT_LIGHT6										= "W_AttackLeftHeavy1", "W_AttackLeftHeavy2", "W_AttackLeftHeavy3", "W_AttackLeftHeavy4", "W_AttackLeftHeavy5", "W_AttackLeftHeavy6"
ART_STANCE1, ART_STANCE2, ART_ONESHOT1, ART_ONESHOT2, ART_ONESHOT3													= "W_DrawStanceRightAttackLight", "W_DrawStanceRightAttackHeavy", "W_SwordArtsOneShot", "W_SwordArtsOneShotComboEnd", "W_SwordArtsOneShotComboEnd_2"

-- Sekiro.
ONE_MIND1, ONE_MIND2, DRAGON_FLASH1, DRAGON_FLASH2, SHADOWN_RUSH1, SHADOWN_RUSH2									= "W_DMN_OneMind1", "W_DMN_OneMind2", "W_DMN_DragonFlash1", "W_DMN_DragonFlash2", "W_DMN_Shadowrush1", "W_DMN_Shadowrush2"
ICHIMONJI1, ICHIMONJI2, ICHIMONJI3, LOADED_SHURIKEN1, LOADED_SHURIKEN2, LOADED_SHURIKEN3							= "W_DMN_Ichimonji1", "W_DMN_Ichimonji2", "W_DMN_Ichimonji3", "W_DMN_LoadedShuriken1", "W_DMN_LoadedShuriken2", "W_DMN_LoadedShuriken3"
PRAYING_STRIKES1, PRAYING_STRIKES2, PRAYING_STRIKES3, WHIRLWIND_SLASH1, ASHINA_CROSS1, SAKURA_DANCE1				= "W_DMN_PrayingStrikes1", "W_DMN_PrayingStrikes2", "W_DMN_PrayingStrikes3", "W_DMN_WhirlwindSlash1", "W_DMN_AshinaCross1", "W_DMN_SakuraDance1"
NIGHTJAR_SLASH1, NIGHTJAR_SLASH2, SENPOU_LEAPING_KICKS1, SENPOU_LEAPING_KICKS2, SENPOU_LEAPING_KICKS3 				= "W_DMN_NightjarSlash1", "W_DMN_NightjarSlash2", "W_DMN_SenpouLeapingKicks1", "W_DMN_SenpouLeapingKicks2", "W_DMN_SenpouLeapingKicks3"
FLOATING_PASSAGE1, FLOATING_PASSAGE2, FLOATING_PASSAGE3, FLOATING_PASSAGE4, FLOATING_PASSAGE5, FLOATING_PASSAGE6	= "W_DMN_FloatingPassage1", "W_DMN_FloatingPassage2", "W_DMN_FloatingPassage3", "W_DMN_FloatingPassage4", "W_DMN_FloatingPassage5", "W_DMN_FloatingPassage6"
SEKIRO1, SEKIRO2, SEKIRO3, SEKIRO4, SEKIRO5, SEKIRO6, SEKIRO7, SEKIRO8, SEKIRO9, SEKIRO10, SEKIRO11, SEKIRO12		= "W_DMN_Sekiro1", "W_DMN_Sekiro2", "W_DMN_Sekiro3", "W_DMN_Sekiro4", "W_DMN_Sekiro5", "W_DMN_Sekiro6", "W_DMN_Sekiro7", "W_DMN_Sekiro8", "W_DMN_Sekiro9", "W_DMN_Sekiro10", "W_DMN_Sekiro11", "W_DMN_Sekiro12"

-- Genichiro.
GENICHIRO1, GENICHIRO2, GENICHIRO3, GENICHIRO4, GENICHIRO5, GENICHIRO6, GENICHIRO7, GENICHIRO8						= "W_DMN_Genichiro1", "W_DMN_Genichiro2", "W_DMN_Genichiro3", "W_DMN_Genichiro4", "W_DMN_Genichiro5", "W_DMN_Genichiro6", "W_DMN_Genichiro7", "W_DMN_Genichiro8"
GENICHIRO9, GENICHIRO10, GENICHIRO11, GENICHIRO12, GENICHIRO13, GENICHIRO14, GENICHIRO15							= "W_DMN_Genichiro9", "W_DMN_Genichiro10", "W_DMN_Genichiro11", "W_DMN_Genichiro12", "W_DMN_Genichiro13", "W_DMN_Genichiro14", "W_DMN_Genichiro15"
GENICHIRO16, GENICHIRO17, GENICHIRO18, GENICHIRO19, GENICHIRO20, GENICHIRO21, GENICHIRO22							= "W_DMN_Genichiro16", "W_DMN_Genichiro17", "W_DMN_Genichiro18", "W_DMN_Genichiro19", "W_DMN_Genichiro20", "W_DMN_Genichiro21", "W_DMN_Genichiro22"

GENICHIRO_BOW1, GENICHIRO_BOW2, GENICHIRO_BOW3, GENICHIRO_BOW4, GENICHIRO_BOW5, GENICHIRO_BOW6						= "W_DMN_Genichiro_Bow1", "W_DMN_Genichiro_Bow2", "W_DMN_Genichiro_Bow3", "W_DMN_Genichiro_Bow4", "W_DMN_Genichiro_Bow5", "W_DMN_Genichiro_Bow6"
GENICHIRO_BOW7, GENICHIRO_BOW8, GENICHIRO_BOW9, GENICHIRO_BOW10, GENICHIRO_BOW11, GENICHIRO_BOW12					= "W_DMN_Genichiro_Bow7", "W_DMN_Genichiro_Bow8", "W_DMN_Genichiro_Bow9", "W_DMN_Genichiro_Bow10", "W_DMN_Genichiro_Bow11", "W_DMN_Genichiro_Bow12"

-- Great Shinobi Owl.
GREAT_SHINOBI_OWL1, GREAT_SHINOBI_OWL2, GREAT_SHINOBI_OWL3, GREAT_SHINOBI_OWL4, GREAT_SHINOBI_OWL5					= "W_DMN_GreatShinobiOwl1", "W_DMN_GreatShinobiOwl2", "W_DMN_GreatShinobiOwl3", "W_DMN_GreatShinobiOwl4", "W_DMN_GreatShinobiOwl5"
GREAT_SHINOBI_OWL6, GREAT_SHINOBI_OWL7, GREAT_SHINOBI_OWL8, GREAT_SHINOBI_OWL9, GREAT_SHINOBI_OWL10					= "W_DMN_GreatShinobiOwl6", "W_DMN_GreatShinobiOwl7", "W_DMN_GreatShinobiOwl8", "W_DMN_GreatShinobiOwl9", "W_DMN_GreatShinobiOwl10"
GREAT_SHINOBI_OWL11, GREAT_SHINOBI_OWL12, GREAT_SHINOBI_OWL13, GREAT_SHINOBI_OWL14, GREAT_SHINOBI_OWL15				= "W_DMN_GreatShinobiOwl11", "W_DMN_GreatShinobiOwl12", "W_DMN_GreatShinobiOwl13", "W_DMN_GreatShinobiOwl14", "W_DMN_GreatShinobiOwl15"
GREAT_SHINOBI_OWL16, GREAT_SHINOBI_OWL17, GREAT_SHINOBI_OWL18, GREAT_SHINOBI_OWL19									= "W_DMN_GreatShinobiOwl16", "W_DMN_GreatShinobiOwl17", "W_DMN_GreatShinobiOwl18", "W_DMN_GreatShinobiOwl19"

-- Lone Shadow.
LONE_SHADOW1, LONE_SHADOW2, LONE_SHADOW3, LONE_SHADOW4, LONE_SHADOW5, LONE_SHADOW6									= "W_DMN_LoneShadow1", "W_DMN_LoneShadow2", "W_DMN_LoneShadow3", "W_DMN_LoneShadow4", "W_DMN_LoneShadow5", "W_DMN_LoneShadow6"
LONE_SHADOW7, LONE_SHADOW8, LONE_SHADOW9, LONE_SHADOW10, LONE_SHADOW11												= "W_DMN_LoneShadow7", "W_DMN_LoneShadow8", "W_DMN_LoneShadow9", "W_DMN_LoneShadow10", "W_DMN_LoneShadow11"

-- Isshin Ashina.
ISSHIN1, ISSHIN2, ISSHIN3, ISSHIN4, ISSHIN5, ISSHIN6, ISSHIN7, ISSHIN8, ISSHIN9, ISSHIN10, ISSHIN11					= "W_DMN_Isshin1", "W_DMN_Isshin2", "W_DMN_Isshin3", "W_DMN_Isshin4", "W_DMN_Isshin5", "W_DMN_Isshin6", "W_DMN_Isshin7", "W_DMN_Isshin8", "W_DMN_Isshin9", "W_DMN_Isshin10", "W_DMN_Isshin11"
ISSHIN12, ISSHIN13, ISSHIN14, ISSHIN15, ISSHIN16, ISSHIN17, ISSHIN18, ISSHIN19, ISSHIN20, ISSHIN21					= "W_DMN_Isshin12", "W_DMN_Isshin13", "W_DMN_Isshin14", "W_DMN_Isshin15", "W_DMN_Isshin16", "W_DMN_Isshin17", "W_DMN_Isshin18", "W_DMN_Isshin19", "W_DMN_Isshin20", "W_DMN_Isshin21"
ISSHIN22, ISSHIN23, ISSHIN24, ISSHIN25, ISSHIN26, ISSHIN27, ISSHIN28, ISSHIN29, ISSHIN30, ISSHIN31					= "W_DMN_Isshin22", "W_DMN_Isshin23", "W_DMN_Isshin24", "W_DMN_Isshin25", "W_DMN_Isshin26", "W_DMN_Isshin27", "W_DMN_Isshin28", "W_DMN_Isshin29", "W_DMN_Isshin30", "W_DMN_Isshin31"

-- Custom.
UNLIMITED_BLADE_WORKS1, EXPLOSION_SPHERE1, SHATTERING_ARROW1, PIERCING_ARROW1										= "W_DMN_UnlimitedBladeWorks1", "W_DMN_ExplosionSphere1", "W_DMN_ShatteringArrow1", "W_DMN_PiercingArrow1"


-- Lady Butterfly.
LADY_BUTTERFLY_ATTACK1, LADY_BUTTERFLY_ATTACK2, LADY_BUTTERFLY_ATTACK3, LADY_BUTTERFLY_ATTACK4						= "W_DMN_LadyButterfly_Attack1", "W_DMN_LadyButterfly_Attack2", "W_DMN_LadyButterfly_Attack3", "W_DMN_LadyButterfly_Attack4"
LADY_BUTTERFLY_ATTACK5, LADY_BUTTERFLY_ATTACK6, LADY_BUTTERFLY_ATTACK7, LADY_BUTTERFLY_ATTACK8						= "W_DMN_LadyButterfly_Attack5", "W_DMN_LadyButterfly_Attack6", "W_DMN_LadyButterfly_Attack7", "W_DMN_LadyButterfly_Attack8"
LADY_BUTTERFLY_ATTACK9, LADY_BUTTERFLY_ATTACK10, LADY_BUTTERFLY_ATTACK11, LADY_BUTTERFLY_ATTACK12					= "W_DMN_LadyButterfly_Attack9", "W_DMN_LadyButterfly_Attack10", "W_DMN_LadyButterfly_Attack11", "W_DMN_LadyButterfly_Attack12"
LADY_BUTTERFLY_ATTACK13, LADY_BUTTERFLY_ATTACK14																	= "W_DMN_LadyButterfly_Attack13", "W_DMN_LadyButterfly_Attack14"

LADY_BUTTERFLY_COMBO1, LADY_BUTTERFLY_COMBO2, LADY_BUTTERFLY_COMBO3, LADY_BUTTERFLY_COMBO4							= "W_DMN_LadyButterfly_Combo1", "W_DMN_LadyButterfly_Combo2", "W_DMN_LadyButterfly_Combo3", "W_DMN_LadyButterfly_Combo4"
LADY_BUTTERFLY_COMBO5, LADY_BUTTERFLY_COMBO6, LADY_BUTTERFLY_COMBO7, LADY_BUTTERFLY_COMBO8							= "W_DMN_LadyButterfly_Combo5", "W_DMN_LadyButterfly_Combo6", "W_DMN_LadyButterfly_Combo7", "W_DMN_LadyButterfly_Combo8"

LADY_BUTTERFLY_KUNAI1, LADY_BUTTERFLY_KUNAI2, LADY_BUTTERFLY_KUNAI3													= "W_DMN_LadyButterfly_Kunai1", "W_DMN_LadyButterfly_Kunai2", "W_DMN_LadyButterfly_Kunai3"

LADY_BUTTERFLY_SPECIAL1, LADY_BUTTERFLY_SPECIAL2																	= "W_DMN_LadyButterfly_Special1_Empty", "W_DMN_LadyButterfly_Special2_Empty"

-- Table of custom attacks.
R1, R2																												= "R1", "R2"
DMN_CustomMovesets_Table =
{-- TABLE-BEGIN.
	-- 6-6
	[WEAPON_CATEGORY_CLAW]					= {},
	[WEAPON_CATEGORY_FIST]					= {},
	[WEAPON_CATEGORY_MARTIAL_ARTS]			= {},
	[WEAPON_CATEGORY_BACKHAND_SWORD]		= {},
	[WEAPON_CATEGORY_THROW_DAGGER]			= {},

	-- 6-4
	[WEAPON_CATEGORY_SHORT_SWORD]			= {},
	[WEAPON_CATEGORY_CURVEDSWORD]			= {},
	[WEAPON_CATEGORY_RAPIER]				= {},

	-- 5-4
	[WEAPON_CATEGORY_STRAIGHT_SWORD]		= {},
	[WEAPON_CATEGORY_KATANA]				=
	{
		-- My default movesets.
		{
			-- Hold a weapon with two-hand.
			TWO_HAND =
			{
				-- Combo of attacks in normal state.
				NORMAL_COMBO =
				{
					{R1, R1, R1, R1, R1},
					{GENICHIRO1, SEKIRO7, SEKIRO8, SEKIRO9, SEKIRO11},

					{R1, R1, R1, R1, R2},
					{0, 0, 0, 0, LONE_SHADOW3},

					{R1, R1, R1, R2, R1},
					{0, 0, 0, GENICHIRO21, GREAT_SHINOBI_OWL4},

					{R1, R1, R1, R2, R2},
					{0, 0, 0, 0, LONE_SHADOW11},

					{R1, R1, R2, R1, R1},
					{0, 0, GREAT_SHINOBI_OWL17, GREAT_SHINOBI_OWL8, GREAT_SHINOBI_OWL15},

					{R1, R1, R2, R1, R2},
					{0, 0, 0, 0, SENPOU_LEAPING_KICKS3},

					{R1, R1, R2, R2, R1},
					{0, 0, 0, LONE_SHADOW6, GREAT_SHINOBI_OWL9},

					{R1, R1, R2, R2, R2},
					{0, 0, 0, 0, GENICHIRO_BOW10},

					{R1, R2, R1, R1, R1},
					{0, GENICHIRO16, GENICHIRO14, GENICHIRO6, GENICHIRO13},

					{R1, R2, R1, R1, R2},
					{0, 0, LONE_SHADOW11, SENPOU_LEAPING_KICKS2, GREAT_SHINOBI_OWL8},

					{R1, R2, R1, R2, R1},
					{0, 0, 0, LONE_SHADOW11, GREAT_SHINOBI_OWL8},

					{R1, R2, R1, R2, R2},
					{0, 0, 0, 0, LADY_BUTTERFLY_ATTACK13},

					{R1, R2, R2, R1, R1},
					{0, 0, GENICHIRO_BOW7, GENICHIRO22, GREAT_SHINOBI_OWL8},

					{R1, R2, R2, R1, R2},
					{0, 0, 0, 0, SENPOU_LEAPING_KICKS1},

					{R1, R2, R2, R2, R1},
					{0, 0, 0, GENICHIRO_BOW7, GENICHIRO_BOW9},

					{R1, R2, R2, R2, R2},
					{0, 0, 0, 0, GENICHIRO_BOW2},

					{R2, R1, R1, R1, R1},
					{GENICHIRO16, GENICHIRO18, GREAT_SHINOBI_OWL10, GENICHIRO5, GREAT_SHINOBI_OWL8},

					{R2, R1, R1, R1, R2},
					{0, 0, 0, 0, SENPOU_LEAPING_KICKS3},

					{R2, R1, R1, R2, R1},
					{0, 0, 0, LONE_SHADOW11, GREAT_SHINOBI_OWL8},

					{R2, R1, R1, R2, R2},
					{0, 0, 0, LONE_SHADOW11, LONE_SHADOW7},

					{R2, R1, R2, R1, R1},
					{0, 0, GREAT_SHINOBI_OWL5, GENICHIRO5, GREAT_SHINOBI_OWL11},

					{R2, R1, R2, R1, R2},
					{0, 0, GREAT_SHINOBI_OWL5, GENICHIRO5, LONE_SHADOW3},

					{R2, R1, R2, R2, R1},
					{0, 0, 0, LONE_SHADOW6, GREAT_SHINOBI_OWL13},

					{R2, R1, R2, R2, R2},
					{0, 0, 0, LONE_SHADOW6, GENICHIRO_BOW10},

					{R2, R2, R1, R1, R1},
					{0, LONE_SHADOW10, SENPOU_LEAPING_KICKS2, GREAT_SHINOBI_OWL10, GENICHIRO18},

					{R2, R2, R1, R1, R2},
					{0, 0, 0, 0, GREAT_SHINOBI_OWL4},

					{R2, R2, R1, R2, R1},
					{0, 0, 0, LONE_SHADOW11, DRAGON_FLASH2},

					{R2, R2, R1, R2, R2},
					{0, 0, 0, 0, LONE_SHADOW7},

					{R2, R2, R2, R1, R1},
					{0, 0, LONE_SHADOW11, WHIRLWIND_SLASH1, GENICHIRO19},

					{R2, R2, R2, R1, R2},
					{0, 0, 0, 0, SENPOU_LEAPING_KICKS3},

					{R2, R2, R2, R2, R1},
					{0, 0, 0, LONE_SHADOW6, GREAT_SHINOBI_OWL13},

					{R2, R2, R2, R2, R2},
					{0, 0, 0, 0, GREAT_SHINOBI_OWL14}
				},

				-- Combo of attacks after guarding/deflecting.
				GUARD_COUNTER =
				{
					{R1, R1, R1},
					{ASHINA_CROSS1, DRAGON_FLASH2, GENICHIRO10},

					{R2, R2, R2},
					{GREAT_SHINOBI_OWL17, LONE_SHADOW6, GREAT_SHINOBI_OWL9}
				},

				-- Combo of attacks upon enemy hit in guard stance.
				GUARD_STANCE =
				{
					{R1},
					{"W_DMN_GuardStance1_Normal"},

				--	{R1, R1, R1, R1, R1},
				--	{FLOATING_PASSAGE2, FLOATING_PASSAGE3, FLOATING_PASSAGE4, FLOATING_PASSAGE5, DRAGON_FLASH2},

					{R2, R2, R2, R2},
					{GENICHIRO6, GENICHIRO16, GENICHIRO17, GENICHIRO10}
				},

				-- Combo of attacks after dashing.
				DASH_COMBO =
				{
					{R1, R1, R1},
					{GENICHIRO22, GREAT_SHINOBI_OWL8, GREAT_SHINOBI_OWL11},

					{R2, R2},
					{GREAT_SHINOBI_OWL4, GREAT_SHINOBI_OWL9}
				},

				-- Combo of attacks after rolling.
				ROLL_COMBO =
				{
					{R1, R1, R1},
					{SEKIRO3, LONE_SHADOW11, LONE_SHADOW3},

					{R2, R2, R2},
					{SENPOU_LEAPING_KICKS1, LONE_SHADOW11, LONE_SHADOW7}
				},

				-- Combo of attacks after backstepping.
				BACKSTEP_COMBO =
				{
					{R1, R1},
					{LONE_SHADOW3, LONE_SHADOW7},

					{R2, R2},
					{GENICHIRO16, GENICHIRO7}
				},

				-- Combo of attacks in stealth mode.
				STEALTH_COMBO =
				{
					{R1, R1},
					{GREAT_SHINOBI_OWL14, GREAT_SHINOBI_OWL9}
				}
			}
		},

		-- My Isshin movesets.
		{
			TWO_HAND =
			{
				NORMAL_COMBO =
				{
					{R1, R1, R1, R1, R1},
					{ISSHIN12, ISSHIN15, ISSHIN22, ISSHIN3, ISSHIN16}
				}
			}
		},
	},
	[WEAPON_CATEGORY_AX]					= {},
	[WEAPON_CATEGORY_HAMMER]				= {},
	[WEAPON_CATEGORY_LARGE_RAPIER]			= {},
	[WEAPON_CATEGORY_LIGHT_LARGE_SWORD]		= {},
	[WEAPON_CATEGORY_TWINBLADE]				= {},

	-- 4-4
	[WEAPON_CATEGORY_FLAIL]					= {},
	[WEAPON_CATEGORY_BEAST_CLAW]			= {},
	[WEAPON_CATEGORY_DUELING_SHIELD]		= {},
	[WEAPON_CATEGORY_PERFUME_BOTTLE]		= {},

	-- 4-3
	[WEAPON_CATEGORY_LARGE_SWORD]			= {},
	[WEAPON_CATEGORY_LARGE_KATANA]			= {},
	[WEAPON_CATEGORY_LARGE_CURVEDSWORD]		= {},
	[WEAPON_CATEGORY_LARGE_AX]				= {},
	[WEAPON_CATEGORY_LARGE_HAMMER]			= {},
	[WEAPON_CATEGORY_SPEAR]					= {},
	[WEAPON_CATEGORY_HALBERD]				= {},
	[WEAPON_CATEGORY_LARGE_SCYTHE]			= {},
	[WEAPON_CATEGORY_WHIP]					= {},

	-- 3-3
	[WEAPON_CATEGORY_EXTRALARGE_SWORD]		= {},
	[WEAPON_CATEGORY_EXTRALARGE_AXHAMMER]	= {},
	[WEAPON_CATEGORY_LARGE_SPEAR]			= {}
}-- TABLE-END.


--############################################################################--
----------------------------- PLEASE DO NOT MODIFY -----------------------------


--------------------------------------------------------------------------------
----------------------------------- CONSTANTS ----------------------------------

GC_BUTTONS =
{
	R1									= 0,
	R2									= 1,
	L1									= 2,
	L2									= 3,
	Y									= 4,
	B									= 5,
	A									= 6,
	X									= 7,
	UP									= 8,
	RIGHT								= 9,
	LEFT								= 10,
	DOWN								= 11,
	R3									= 12,
	L3									= 13
}

GC_STICKS =
{
	LEVEL_NONE							= 0.00,
	LEVEL_MINIMUM						= 0.15,
	LEVEL_SMALL							= 0.65,
	LEVEL_LARGE							= 0.95,
	LEVEL_EXLARGE						= 1.05,

	DIRECTION_UP						= 0,
	DIRECTION_DOWN						= 1,
	DIRECTION_LEFT						= 2,
	DIRECTION_RIGHT						= 3
}

----------------------------------------
GC_MODES =
{
	DEFLECT_STATUS_CLEAR				= 1,
	DEFLECT_STATUS_KEEP					= 2,
	DEFLECT_STATUS_REFRESH				= 3,

	DEFLECT_RESTORE_SAME				= 1,
	DEFLECT_RESTORE_STACK				= 2,
	DEFLECT_RESTORE_VARY				= 3,

	DEFLECT_COUNTER_SAME				= 1,
	DEFLECT_COUNTER_STACK				= 2,
	DEFLECT_COUNTER_VARY				= 3,

	DEFLECT_EFFECT_ALL					= 1,
	DEFLECT_EFFECT_SINGLE				= 2,

	DEFLECT_STYLE_REMOVE				= 1,
	DEFLECT_STYLE_KEEP					= 2,

	DEFLECT_REPEL_DEFAULT				= 0,
	DEFLECT_REPEL_NONE					= 1,
	DEFLECT_REPEL_ALL					= 2,

	DEFLECT_PROTECT_FRONT				= 1,
	DEFLECT_PROTECT_SIDES				= 2,
	DEFLECT_PROTECT_ALL					= 3,

	DEFLECT_ESCAPE_DISABLE				= 0,
	DEFLECT_ESCAPE_TURN					= 1,
	DEFLECT_ESCAPE_ROLL					= 2,
	DEFLECT_ESCAPE_JUMP					= 3,

	DEFLECT_EVADE_DISABLE				= 0,
	DEFLECT_EVADE_ENABLE				= 1,

	DEFLECT_VFX_DISABLE					= 0,
	DEFLECT_VFX_PERFECT					= 1,
	DEFLECT_VFX_ALL						= 2,

	DEFLECT_ANIMATION_DEFAULT			= 0,
	DEFLECT_ANIMATION_MIX				= 1,
	DEFLECT_ANIMATION_SEKIRO			= 2,
	DEFLECT_ANIMATION_LADYBUTTERFLY		= 3,

	DEFLECT_PUSHBACK_DEFAULT			= 0,
	DEFLECT_PUSHBACK_MEDIUM				= 1,
	DEFLECT_PUSHBACK_STRONG				= 2,
	DEFLECT_PUSHBACK_NONE				= 3,

	DEFLECT_ATTACK_DISABLE				= 0,
	DEFLECT_ATTACK_STOP					= 1,
	DEFLECT_ATTACK_STOP_INTERRUPT		= 2,
	DEFLECT_ATTACK_CONTINUE				= 3,
	DEFLECT_ATTACK_CONTINUE_INTERRUPT	= 4,

	DEFLECT_ATTACK_REFRESH_DISABLE		= 0,
	DEFLECT_ATTACK_REFRESH_ENABLE		= 1,

	DEFLECT_EXTENDS_DISABLE				= 0,
	DEFLECT_EXTENDS_ENABLE				= 1,

	DEFLECT_ACCUMULATE_DEFAULT			= 0,
	DEFLECT_ACCUMULATE_BALANCE			= 1,
	DEFLECT_ACCUMULATE_BYPASS			= 2,
	DEFLECT_ACCUMULATE_STRICT			= 3,

	DEFLECT_ACCUMULATE_BONUS_FULL		= 1,
	DEFLECT_ACCUMULATE_BONUS_DYNAMIC	= 2,

	DEFLECT_ACCUMULATE_VFX_DISABLE		= 0,
	DEFLECT_ACCUMULATE_VFX_ENABLE		= 1,

	ENEMY_CONFUSE_SHORT					= 1,
	ENEMY_CONFUSE_MEDIUM				= 2,
	ENEMY_CONFUSE_LONG					= 3,

	ENEMY_RECOVERY_SHORT				= 1,
	ENEMY_RECOVERY_MEDIUM				= 2,
	ENEMY_RECOVERY_LONG					= 3,

	ACTION_CANCEL_DEFAULT				= 0,
	ACTION_CANCEL_STRICT				= 1,
	ACTION_CANCEL_FREE					= 2,

	ACTION_CANCEL_VFX_DISABLE			= 0,
	ACTION_CANCEL_VFX_ENABLE			= 1,

	GUARD_CANCEL_NONE					= 0,
	GUARD_CANCEL_OVERRIDE				= 1,

	EVASION_CANCEL_NONE					= 0,
	EVASION_CANCEL_OVERRIDE				= 1,
	EVASION_CANCEL_NODELAY				= 2,

	JUMP_CANCEL_NONE					= 0,
	JUMP_CANCEL_OVERRIDE				= 1,
	JUMP_CANCEL_DOUBLE					= 2,
	JUMP_CANCEL_INFINITE				= 3,

	EVASION_ACTIONS_DEFAULT				= 0,
	EVASION_ACTIONS_SEKIRO				= 1,
	EVASION_ACTIONS_BLOODHOUND			= 2,
	EVASION_ACTIONS_LADYBUTTERFLY		= 3,

	TORRENT_CLOUDCHASING_DISABLE		= 0,
	TORRENT_CLOUDCHASING_ENABLE			= 1,

	MOVESETS_DEFAULT					= 0,
	MOVESETS_CUSTOM						= 1,

	GUARDSTANCE_DISABLE					= 0,
	GUARDSTANCE_R1						= 1,
	GUARDSTANCE_R2						= 2,
	GUARDSTANCE_ALL						= 3,

	SHORTCUT_DISABLE					= 0,
	SHORTCUT_ENABLE						= 1,

	SPRINTING_DEFAULT					= 0,
	SPRINTING_KEEP						= 1,
	SPRINTING_LOCK						= 2,
	SPRINTING_FREE						= 3,

	AI_ENEMY_ALERT_DEFAULT				= 0,
	AI_ENEMY_ALERT_SMALL				= 1,
	AI_ENEMY_ALERT_LARGE				= 2,
	AI_ENEMY_ALERT_EXLARGE				= 3,

	STRING_MASTER_DISABLE				= 0,
	STRING_MASTER_ENABLE				= 1,

	AIR_RETREAT_DISABLE					= 0,
	AIR_RETREAT_ENABLE					= 1
}

GC_ACTIONS =
{
	GUARD_CANCEL						= 1,
	EVASION_CANCEL						= 2,
	JUMP_CANCEL							= 3,

	JUMP_NORMAL							= 0,
	JUMP_FORWARD						= 1,
	JUMP_DASH							= 2,
}

GC_FLAGS =
{
	ANIMATION_CANCEL					= 28,
	ANIMATION_PLAYING					= 29,
	ANIMATION_END						= 30
}


----------------------------------------
GC_SPEIDS =
{
	ITEM_DISCOVERY						= 9001001,
	MAX_EQUIP_LOAD						= 9001002,
	ARROW_DISTANCE						= 9001003,

	REGEN_HP							= 9001004,
	REGEN_FP							= 9001005,
	REGEN_SP							= 9001006,

	INCREASE_FP							= 9001007,
	DECREASE_FP							= 9001008,

	ENEMY_VISION						= 9001009,
	ENEMY_HEARING						= 9001010,

	ENEMY_ALERT_SMALL					= 9001011,
	ENEMY_ALERT_LARGE					= 9001012,
	ENEMY_ALERT_EXLARGE					= 9001013,

	DECREASE_ATTACK						= 9001014,
	DECREASE_DEFENSE					= 9001015,

	BUFF_ATTACK							= 9001101,
	BUFF_POWER							= 9001102,
	BUFF_DEFENSE						= 9001103,

	BOOST_ATTACK						= 9001104,
	BOOST_POWER							= 9001105,
	BOOST_DEFENSE						= 9001106,

	INVISIBLE_INSTANT					= 9001107,
	INVISIBLE_SHORT						= 9001108,
	INVISIBLE_LONG						= 9001109,

	DEFLECT_STATUS						= 9001110,
	DEFLECT_REPEL_NONE					= 9001111,
	DEFLECT_REPEL_ALL					= 9001112,
	DEFLECT_COUNTER						= 9001113,

	RUNE_GAIN							= 9001114,

	TIMER_FPS							= 9001201,

	STRING_MASTER_WIRE_LEFT				= 9001202,
	STRING_MASTER_WIRE_RIGHT			= 9001203,
	STRING_MASTER_STATUS_AIR			= 9001204
}

GC_VFXIDS =
{
	PARTICLE_SPARK_RED					= 9002001,
	PARTICLE_SPARK_ORANGE				= 9002002,

	AURA_MIST_WHITE						= 9002101,

	HALO_CIRCLE_JADE					= 9002201,
	HALO_CIRCLE_ORANGE					= 9002202,

	SPOT_MIST_DARK_CENTER				= 9002301,
	SPOT_MIST_DARK_GROUND				= 9002302,

	FIELD_GOLDEN_SIMPLE					= 9002401,
	FIELD_GOLDEN_CHARGE					= 9002402,
	FIELD_GOLDEN_SPARK					= 9002403,

	SIGIL_GOLDEN_CROSS					= 9002501,
	SIGIL_PERILOUS_ATTACK				= 9002502,

	SPHERE_LIGHT_VACUUM					= 9002601,
	SPHERE_GOLDEN_VACUUM				= 9002602,

	BLADE_FLAME_AZURE_LEFT				= 9002701,
	BLADE_FLAME_AZURE_RIGHT				= 9002702,

	BLAST_SPARK_WHITE					= 9002801,
	BLAST_SPARK_WHITE_LEFT				= 9002802,
	BLAST_SPARK_WHITE_RIGHT				= 9002803,

	FLASH_SPOT_WHITE					= 9002811,
	FLASH_HORIZONTAL_GOLDEN_IMPACT		= 9002812,
	FLASH_HORIZONTAL_GOLDEN_SPARK		= 9002813,

	ABSORPT_BODY_WHITE					= 9002901,
	ABSORPT_BODY_TRANSPARENT			= 9002902,

	STRING_MASTER_WIRE_LEFT				= 9002911,
	STRING_MASTER_WIRE_RIGHT			= 9002912,
	STRING_MASTER_WIRE_CRIMSON_LEFT		= 9002913,
	STRING_MASTER_WIRE_CRIMSON_RIGHT	= 9002914
}

GC_SFXID =
{
	DEFLECT_S1							= 9003001,
	DEFLECT_S2							= 9003002,
	DEFLECT_S3							= 9003003,

	DEFLECT_M1							= 9003011,
	DEFLECT_M2							= 9003012,
	DEFLECT_M3							= 9003013,

	DEFLECT_B1							= 9003021,

	DEFLECT_P1							= 9003031,

	SWORD_SLASH1						= 9003041,
	SWORD_SLASH2						= 9003042,
	SWORD_SLASH3						= 9003043,

	SWORD_STAB1							= 9003051,

	SWORD_UNSHEATHED1					= 9003061,

	SWORD_SHEATHED1						= 9003071,

	MARTIAL_ART1						= 9003081,
	MARTIAL_ART2						= 9003082,
	MARTIAL_ART3						= 9003083,
	MARTIAL_ART4						= 9003084,
	MARTIAL_ART5						= 9003085,
	MARTIAL_ART6						= 9003086,

	WARNING_PERILOUS_ATTACK				= 9003091,

	SIGNAL_STRING_MASTER_JUDGEMENT		= 9003101,

	GUN_SHOT1							= 9003111
}

GC_ARTIDS =
{
	DEFLECT_REPEL_ATTACK				= 9000501,
	DEFLECT_REPEL_POWER					= 9000502,
	DEFLECT_REPEL_ALL					= 9000503,

	DEFLECT_REPEL_ATTACK_SINGLE			= 9000504,
	DEFLECT_REPEL_POWER_SINGLE			= 9000505,
	DEFLECT_REPEL_ALL_SINGLE			= 9000506,

	ENEMY_CONFUSE_SHORT					= 9000601,
	ENEMY_CONFUSE_MEDIUM				= 9000602,
	ENEMY_CONFUSE_LONG					= 9000603,

	ENEMY_RECOVERY_SHORT				= 9000604,
	ENEMY_RECOVERY_MEDIUM				= 9000605,
	ENEMY_RECOVERY_LONG					= 9000606,

	ENEMY_CLEAR_TARGET					= 9000691,
	ENEMY_HP_REGEN						= 9000692
}

GC_AOWIDS =
{
	UNSHEATHE							= 14,
	MIGHTY_SHOT							= 102
}

----------------------------------------
GC_COMBO =
{
	GUARD_COUNTER1 =
	{
		{R1},
		{RIGHT_LIGHT1},

		{R2},
		{RIGHT_COUNTER}
	},

	GUARD_COUNTER2 =
	{
		{R1},
		{BOTH_LIGHT1},

		{R2},
		{BOTH_COUNTER}
	},

	GUARD_STANCE1 =
	{
		{R1},
		{"W_DMN_GuardStance1_Normal"},

		{R2},
		{"W_DMN_GuardStance1_Normal"},
	},

	GUARD_STANCE2 =
	{
		{R1},
		{"W_DMN_GuardStance1_Perfect"},

		{R2},
		{"W_DMN_GuardStance1_Perfect"},
	}
}

GC_ANIMATIONS_SEKIRO =
{
	DEFLECT =
	{
		LEFT =
		{
			"W_DMN_DeflectS_Up1",
			"W_DMN_DeflectS_Left1",
			"W_DMN_DeflectM_Left1",
			"W_DMN_DeflectM_Left2",
			"W_DMN_DeflectH_Left1",
			"W_DMN_DeflectH_Left2"
		},

		RIGHT =
		{
			"W_DMN_DeflectS_Up1",
			"W_DMN_DeflectS_Right1",
			"W_DMN_DeflectM_Right1",
			"W_DMN_DeflectH_Right1"
		},

		PUSH_LEFT =
		{
			"W_DMN_DeflectP_Up1",
			"W_DMN_DeflectP_Left1"
		},

		PUSH_RIGHT =
		{
			"W_DMN_DeflectP_Up1",
			"W_DMN_DeflectP_Right1",
			"W_DMN_DeflectP_Right2"
		},

		HEAVY =
		{
			"W_DMN_BlockH_Back1",
			"W_DMN_BlockH_Back2",
			"W_DMN_DeflectH_Back1",
			"W_DMN_DeflectH_Back2",
			"W_DMN_DeflectH_Back3"
		}
	}
}

GC_ANIMATIONS_LADYBUTTERFLY =
{
	DEFLECT =
	{
		LEFT =
		{
			"W_DMN_LadyButterfly_DeflectS_Left1",
			"W_DMN_LadyButterfly_DeflectS_Left2",
			"W_DMN_LadyButterfly_DeflectS_Left3",
			"W_DMN_LadyButterfly_DeflectM_Left1",
			"W_DMN_LadyButterfly_DeflectH_Left1"
		},

		RIGHT =
		{
			"W_DMN_LadyButterfly_DeflectS_Right1",
			"W_DMN_LadyButterfly_DeflectS_Right2",
			"W_DMN_LadyButterfly_DeflectM_Right1",
			"W_DMN_LadyButterfly_DeflectH_Right1"
		},

		PUSH_LEFT =
		{
			"W_DMN_LadyButterfly_DeflectP_Left1"
		},

		PUSH_RIGHT =
		{
			"W_DMN_LadyButterfly_DeflectP_Left1"
		},

		HEAVY =
		{
			"W_DMN_BlockH_Back1",
			"W_DMN_BlockH_Back2",
			"W_DMN_DeflectH_Back1",
			"W_DMN_DeflectH_Back2",
			"W_DMN_DeflectH_Back3"
		}
	}
}

GC_SOUNDS =
{
	DEFLECT =
	{
		GC_SFXID.DEFLECT_S1,
		GC_SFXID.DEFLECT_S2,
		GC_SFXID.DEFLECT_S3,
		GC_SFXID.DEFLECT_M1,
		GC_SFXID.DEFLECT_M2,
		GC_SFXID.DEFLECT_M3
	}
}


--------------------------------------------------------------------------------
----------------------------------- VARIABLES ----------------------------------

GV_System =
{
	Initialize							= TRUE,
	Debug								= FALSE,

	TargetFPS							= 60,
	SystemFPS							= 60,
	AccumulateFPS						= 0
}

GV_Requests =
{
	[GC_BUTTONS.R1]						= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.R2]						= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.R3]						= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.L1]						= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.L2]						= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.L3]						= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.A]						= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.B]						= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.X]						= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.Y]						= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.UP]						= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.DOWN]					= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.LEFT]					= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0},
	[GC_BUTTONS.RIGHT]					= {IsButton = FALSE, IsPressed = FALSE, IsReleased = FALSE, Duration = 0, Status = 0}
}

GV_Timer =
{
	Actions								= {},

	Index								= 0,
	Count								= 0
}


----------------------------------------
GV_Effects =
{
	MaxLevel							= 100,

	IncreaseFP							= 5,
	DecreaseFP							= 5,

	TargetDurationShort					= 10,
	TargetDurationLong					= 40,

	DurationInstant						= 1,
	DurationShort						= 10,
	DurationLong						= 40
}

GV_Actions =
{
	Special								= FALSE,
	Critical							= FALSE,
	Counter								= FALSE,
	Casting								= FALSE,

	EvadingPossible						= FALSE,
	SpecialRequest						= FALSE,

	TimerID_GuardCounter				= 0
}


----------------------------------------
GV_Deflect =
{
	Repel								= FALSE,
	Success								= FALSE,
	Cooldown							= FALSE,
	Counter								= FALSE,
	Interrupt							= FALSE,
	Refresh								= FALSE,
	Perfect								= FALSE,
	Heavy								= FALSE,

	AnimationQueue						= {1, 2},
	SoundIndex							= 1,

	CounterMaxLevel						= 4,
	CounterLevel						= 0,

	TargetDuration						= 0,
	TargetPerfect						= 0,
	TargetCooldown						= 0,

	Duration							= 9999,

	TimerID_Status						= 0,
	TimerID_Perfect						= 0,
	TimerID_Penalty						= 0,
	TimerID_Cooldown					= 0
}

GV_Accumulate =
{
	Count								= 0,

	MaxPass								= 1,
	Pass								= 0,

	TargetDuration						= 0,
	TargetTimeout						= 0,

	TimerID_State						= 0,
	TimerID_VFX							= 0,
	TimerID_Timeout						= 0
}

GV_Cancel =
{
	Cooldown							= FALSE,

	RollReady							= FALSE,
	BackstepReady						= FALSE,
	JumpReady							= FALSE,
	QueueReady							= TRUE,

	TargetRollCooldown					= 35,
	TargetStepCooldown					= 35,
	TargetQueueCooldown					= 10,

	RollCooldown						= 35,
	StepCooldown						= 35,
	QueueCooldown						= 10,

	TargetJumpNormalCooldown			= 30,
	TargetJumpDoubleCooldown			= 30,
	TargetJumpInfiniteCooldown			= 30,

	JumpNormalCooldown					= 30,
	JumpDoubleCooldown					= 30,
	JumpInfiniteCooldown				= 30,

	EvasionTimeout						= 500,
	EvasionDuration						= 0,

	JumpCount							= 0
}

GV_Combo =
{
	Custom								= FALSE,
	Cooldown							= FALSE,
	Delay								= FALSE,

	TargetDurationCooldown				= 30,
	TargetDurationDelay					= 15,

	DurationCooldown					= 30,
	DurationDelay						= 15,

	ComboTable							= {},
	ComboActions						= {},
	ComboIndex							= 1,

	MovesetsIndex						= 1,

	GuardStanceStatus					= FALSE,
	GuardStanceAttack					= nil,

	TimerID_Cooldown					= 0,
	TimerID_Delay						= 0
}

GV_GuardStance =
{
	Perfect								= FALSE
}

----------------------------------------
GV_Movement =
{
	Sprinting							= FALSE,

	Multiplier							= 0.1
}

GV_Character =
{
	TimerID_RuneGain					= 0
}

GV_Gameplay =
{
	StringMaster_Flag1					= 0,
	StringMaster_Stacks					= 0,

	AirRetreat_Ready					= FALSE,

	TimerID_StringMaster_Timeout		= 0
}


--------------------------------------------------------------------------------
------------------------------------ SYSTEM ------------------------------------

function System_Update()
	System_Startup()
	System_Initialize()
	System_Requests()
	System_Triggers()
	System_Timer()
	System_Cancel()
	System_Shortcut()

	-- Testing.
	if System_IsDebug() == TRUE then
		if Request_IsPressed(GC_BUTTONS.Y) == TRUE then
		--	ExecEventAllBody("W_DMN_SEKIRO82")
		end

		if Request_IsPressed(GC_BUTTONS.R1) == TRUE then
			Effect_AddByID(GC_ARTIDS.ENEMY_HP_REGEN)
		end

		GV_Deflect.TargetDuration		= 1000
		GV_Deflect.TargetPerfect		= 1000
		GV_Deflect.TargetCooldown		= 50

		DMN_DeflectDamage_Level			= 0
		DMN_DeflectPower_Level			= 0
		DMN_DeflectDamage_Bonus			= 0
		DMN_DeflectPower_Bonus			= 0
		DMN_AccumulateAttack_Level		= 0
		DMN_AccumulatePower_Level		= 0

	--	DMN_DeflectStatus_Mode			= GC_MODES.DEFLECT_STATUS_CLEAR
	--	DMN_DeflectStyle_Mode			= GC_MODES.DEFLECT_STYLE_KEEP
	--	DMN_JumpCancel_Mode				= GC_MODES.JUMP_CANCEL_INFINITE
	--	DMN_GuardCancel_Mode			= GC_MODES.GUARD_CANCEL_OVERRIDE

		DMN_AutoRevive_Number			= 1000

		Stat_IncreaseHP(1000)
	--	Stat_IncreaseFP(200)
		Stat_IncreaseSP(200)
	end
	--
end

function System_Startup()
	if GV_System.Initialize == TRUE then

		Effect_AddByLevel(GC_SPEIDS.DECREASE_ATTACK, DMN_DecreaseAttack_Level)
		Effect_AddByLevel(GC_SPEIDS.DECREASE_DEFENSE, DMN_DecreaseDefense_Level)

		Effect_AddByLevel(GC_SPEIDS.REGEN_HP, DMN_RegenHP_Level)
		Effect_AddByLevel(GC_SPEIDS.REGEN_FP, DMN_RegenFP_Level)
		Effect_AddByLevel(GC_SPEIDS.REGEN_SP, DMN_RegenSP_Level)

		Effect_AddByLevel(GC_SPEIDS.ITEM_DISCOVERY, DMN_ItemDiscovery_Level)
		Effect_AddByLevel(GC_SPEIDS.MAX_EQUIP_LOAD, DMN_MaxEquipLoad_Level)
		Effect_AddByLevel(GC_SPEIDS.ARROW_DISTANCE, DMN_ArrowDistance_Level)

		Effect_AddByLevel(GC_SPEIDS.ENEMY_VISION, DMN_EnemyVision_Level)
		Effect_AddByLevel(GC_SPEIDS.ENEMY_HEARING, DMN_EnemyHearing_Level)

		GV_Deflect.TargetDuration = DMN_DeflectDuration_Time
		GV_Deflect.TargetPerfect = DMN_DeflectPerfect_Time
		GV_Deflect.TargetCooldown = DMN_DeflectCooldown_Time

		GV_Accumulate.TargetDuration = DMN_AccumulateDuration_Time
		GV_Accumulate.TargetTimeout = DMN_AccumulateTimeout_Time

		GV_Combo.Custom = DMN_CustomMovesets_Mode

		GV_System.Initialize = FALSE
	end
end

function System_Initialize()
	if Effect_IsActive(GC_SPEIDS.TIMER_FPS) == TRUE then
		GV_System.AccumulateFPS = GV_System.AccumulateFPS + 1
	else
		if GV_System.AccumulateFPS > 0 then
			GV_System.SystemFPS = GV_System.AccumulateFPS * 2
			GV_System.AccumulateFPS = 0

			DMN_DeflectDuration_Time = System_MillisecondsToFrames(GV_Deflect.TargetDuration)
			DMN_DeflectPerfect_Time = System_MillisecondsToFrames(GV_Deflect.TargetPerfect)
			DMN_DeflectCooldown_Time = System_MillisecondsToFrames(GV_Deflect.TargetCooldown)

			DMN_AccumulateDuration_Time = System_SecondsToFrames(GV_Accumulate.TargetDuration)
			DMN_AccumulateTimeout_Time = System_SecondsToFrames(GV_Accumulate.TargetTimeout)

			Effect_AdjustFrames()
			Cancel_AdjustFrames()
			Combo_AdjustFrames()
		end

		Effect_AddByID(GC_SPEIDS.TIMER_FPS)
	end
end

function System_Requests()
	for Button, _ in pairs(GV_Requests) do
		GV_Requests[Button].IsButton = FALSE
		GV_Requests[Button].IsPressed = FALSE
		GV_Requests[Button].IsReleased = FALSE

		if env(ActionRequest, Button) == TRUE or env(ActionDuration, Button) > 0 then
			GV_Requests[Button].IsButton = TRUE
		end

		if GV_Requests[Button].IsButton == TRUE then
			if GV_Requests[Button].Status == FALSE then
				GV_Requests[Button].Status = TRUE
				GV_Requests[Button].IsPressed = TRUE
			end
		else
			if GV_Requests[Button].Status == TRUE then
				GV_Requests[Button].Status = FALSE
				GV_Requests[Button].IsReleased = TRUE
			end
		end

		GV_Requests[Button].Duration = env(ActionDuration, Button)
	end
end

function System_Triggers()
	if Stat_GetHP() <= 0 then
		Action_SetSpecial(TRUE)
		Action_SetCritical(TRUE)
		return
	end

	Deflect_UpdateStatus()
	Deflect_RepelAttack()

	Cancel_ResetJumpCount()

	Gameplay_UpdateEffects()
end

function System_Timer()
	for Key, _ in pairs(GV_Timer.Actions) do
		if GV_Timer.Actions[Key] ~= nil then
			if GV_Timer.Actions[Key][2] > 0 and GV_Timer.Actions[Key][4] > 0 then
				if GV_Timer.Actions[Key][3] == -1 then
					if GV_Timer.Actions[Key][5] ~= nil then
						GV_Timer.Actions[Key][5](GV_Timer.Actions[Key][6])
					end

					GV_Timer.Actions[Key][3] = GV_Timer.Actions[Key][4]
				else
					GV_Timer.Actions[Key][1] = GV_Timer.Actions[Key][1] - 1
					GV_Timer.Actions[Key][3] = GV_Timer.Actions[Key][3] - 1

					if GV_Timer.Actions[Key][1] > 0 then
						if GV_Timer.Actions[Key][3] <= 0 then
							if GV_Timer.Actions[Key][5] ~= nil then
								GV_Timer.Actions[Key][5](GV_Timer.Actions[Key][6])
							end

							GV_Timer.Actions[Key][3] = GV_Timer.Actions[Key][4]
						end
					end

					if GV_Timer.Actions[Key][1] <= 0 then
						if GV_Timer.Actions[Key][7] ~= nil then
							GV_Timer.Actions[Key][7](GV_Timer.Actions[Key][8])
						end

						Timer_RemoveAction(Key)
					end
				end
			end
		end
	end
end

function System_Cancel()
	if Game_IsRiding() == FALSE then
		if Cancel_IsQueueReady() == FALSE then
			if Action_IsJumping() == FALSE and (Request_IsButton(GC_BUTTONS.A) == TRUE or Request_IsButton(GC_BUTTONS.B) == TRUE) then
				ResetRequest()
				return
			end
		end

		if DMN_GuardCancel_Mode == GC_MODES.GUARD_CANCEL_OVERRIDE then
			if Request_IsPressed(GC_BUTTONS.L1) == TRUE and Action_IsGuardPossible() == TRUE and Action_IsJumping() == FALSE then
				Cancel_Execute(GC_ACTIONS.GUARD_CANCEL, FALSE)
				return
			end
		end

		if DMN_EvasionCancel_Mode == GC_MODES.EVASION_CANCEL_OVERRIDE then
			if GetLocomotionState() == PLAYER_STATE_MOVE then
				if (Cancel_IsRollReady() == TRUE or Cancel_IsBackstepReady() == TRUE or (Request_IsReleased(GC_BUTTONS.B) == TRUE and Cancel_IsEvasionTimeout() == FALSE)) and Action_IsJumping() == FALSE then
					Cancel_Execute(GC_ACTIONS.EVASION_CANCEL, FALSE)
					return
				end

				Cancel_SetEvasionDuration(Request_GetDuration(GC_BUTTONS.B))
			else
				if (Cancel_IsRollReady() == TRUE or Cancel_IsBackstepReady() == TRUE or Request_IsPressed(GC_BUTTONS.B) == TRUE) and Action_IsJumping() == FALSE then
					Cancel_Execute(GC_ACTIONS.EVASION_CANCEL, FALSE)
					return
				end
			end
		elseif DMN_EvasionCancel_Mode == GC_MODES.EVASION_CANCEL_NODELAY then
			if (Cancel_IsRollReady() == TRUE or Cancel_IsBackstepReady() == TRUE or Request_IsPressed(GC_BUTTONS.B) == TRUE) and Action_IsJumping() == FALSE then
				Cancel_Execute(GC_ACTIONS.EVASION_CANCEL, FALSE)
				return
			end
		end
	end

	if Game_IsRiding() == TRUE and DMN_CloudChasing_Mode ~= GC_MODES.TORRENT_CLOUDCHASING_ENABLE then
		return
	end

	if Game_IsRiding() == TRUE and DMN_CloudChasing_Mode == GC_MODES.TORRENT_CLOUDCHASING_ENABLE then
		if Cancel_IsJumpReady() == TRUE or Request_IsPressed(GC_BUTTONS.A) == TRUE then
			Cancel_Execute(GC_ACTIONS.JUMP_CANCEL, FALSE)
			return
		end
	elseif DMN_JumpCancel_Mode == GC_MODES.JUMP_CANCEL_OVERRIDE then
		if (Cancel_IsJumpReady() == TRUE or Request_IsPressed(GC_BUTTONS.A) == TRUE) and Action_IsJumping() == FALSE then
			Cancel_Execute(GC_ACTIONS.JUMP_CANCEL, FALSE)
			return
		end
	elseif DMN_JumpCancel_Mode == GC_MODES.JUMP_CANCEL_DOUBLE then
		if (Cancel_IsJumpReady() == TRUE or Request_IsPressed(GC_BUTTONS.A) == TRUE) and Cancel_IsSecondJump() == FALSE then
			if Cancel_IsJumpReady() == TRUE then
				
			end
			Cancel_Execute(GC_ACTIONS.JUMP_CANCEL, FALSE)
			return
		end
	elseif DMN_JumpCancel_Mode == GC_MODES.JUMP_CANCEL_INFINITE then
		if Cancel_IsJumpReady() == TRUE or Request_IsPressed(GC_BUTTONS.A) == TRUE then
			Cancel_Execute(GC_ACTIONS.JUMP_CANCEL, FALSE)
			return
		end
	end
end

function System_Shortcut()
	if DMN_OptionShortcuts_Mode == GC_MODES.SHORTCUT_DISABLE then
		return
	end

	local Mode = -1
	if Request_IsButton(GC_BUTTONS.R1) == TRUE and Request_IsButton(GC_BUTTONS.R2) == TRUE and Request_IsPressed(GC_BUTTONS.Y) == TRUE then
		DMN_CustomMovesets_Mode = System_GetValueCirculate(DMN_CustomMovesets_Mode, 0, 1)
		Mode = DMN_CustomMovesets_Mode
		GV_Combo.Custom = DMN_CustomMovesets_Mode
	elseif Request_IsButton(GC_BUTTONS.R1) == TRUE and Request_IsPressed(GC_BUTTONS.Y) == TRUE then
		Combo_SwitchToNextMovesets()
		Effect_AddByID(GC_VFXIDS.BLAST_SPARK_WHITE)
	elseif Request_IsButton(GC_BUTTONS.R2) == TRUE and Request_IsPressed(GC_BUTTONS.Y) == TRUE then
		Combo_SwitchToPreviousMovesets()
		Effect_AddByID(GC_VFXIDS.BLAST_SPARK_WHITE)
	elseif Request_IsButton(GC_BUTTONS.A) == TRUE and Request_IsPressed(GC_BUTTONS.Y) == TRUE then
		DMN_JumpCancel_Mode = System_GetValueCirculate(DMN_JumpCancel_Mode, 0, 3)
		Mode = DMN_JumpCancel_Mode
	elseif Request_IsButton(GC_BUTTONS.B) == TRUE and Request_IsPressed(GC_BUTTONS.Y) == TRUE then
		DMN_EvasionCancel_Mode = System_GetValueCirculate(DMN_EvasionCancel_Mode, 0, 2)
		Mode = DMN_EvasionCancel_Mode
	end

	if Mode == 0 then
		Effect_AddByID(GC_VFXIDS.HALO_CIRCLE_JADE)
	elseif Mode > 0 then
		Effect_AddByID(GC_VFXIDS.HALO_CIRCLE_ORANGE)
	end
end

----------------------------------------
function System_SecondsToFrames(Seconds)
	return GV_System.SystemFPS * Seconds
end

function System_MillisecondsToFrames(Milliseconds)
	return GV_System.SystemFPS * Milliseconds / 1000
end

function System_AdjustFrames(Frames)
	local Result = math.floor(GV_System.SystemFPS * Frames / GV_System.TargetFPS)
	if Result < 1 then
		Result = 1
	end

	return Result
end

----------------------------------------
function System_IsExistInTable(Value, Table)
	for Key, _ in pairs(Table) do
		if Table[Key] == Value then
			return TRUE
		end
	end

	return FALSE
end

function System_GetValueLimit(Value, Min, Max)
	if Value < Min then
		return Min
	elseif Max < Value then
		return Max
	end

	return Value
end

function System_GetValueCirculate(Value, Min, Max)
	Value = Value + 1
	if Max < Value then
		Value = Min
	end

	return Value
end

----------------------------------------
function System_IsDebug()
	if Request_IsPressed(GC_BUTTONS.Y) == TRUE and Request_IsButton(GC_BUTTONS.L1) == TRUE and Request_IsButton(GC_BUTTONS.L2) == TRUE and Request_IsButton(GC_BUTTONS.R1) == TRUE and Request_IsButton(GC_BUTTONS.R2) == TRUE then
		if GV_System.Debug == FALSE then
			GV_System.Debug = TRUE
		else
			GV_System.Debug = FALSE
		end

		Effect_AddByID(GC_VFXIDS.SIGIL_GOLDEN_CROSS)
	end

	return GV_System.Debug
end


--------------------------------------------------------------------------------
------------------------------------- GAME -------------------------------------

function Game_IsPlayer()
	if env(IsCOMPlayer) == FALSE then
		return TRUE
	end

	return FALSE
end

function Game_IsRiding()
	return env(IsOnMount)
end

function Game_IsLockon()
	if GetVariable("IsLockon") == true then
		return TRUE
	end

	return FALSE
end

function Game_IsDualWielding()
	if IsEnableDualWielding() ~= -1 then
		return TRUE
	end

	return FALSE
end

----------------------------------------
function Game_GetStickLevel()
	return GetVariable("MoveSpeedLevel")
end

function Game_GetStickDirection()
	return hkbGetVariable("MoveDirection")
end

function Game_ClearInputQueue()
	act(ResetInputQueue)
end

----------------------------------------
function Game_GetGuardStyle()
	local Style = c_Style
	local Hand = HAND_LEFT
	if Style == HAND_RIGHT_BOTH then
		Hand = HAND_RIGHT
	end

	local GuardIndex = env(GetGuardMotionCategory, Hand)
	local Kind = env(GetEquipWeaponCategory, Hand)
	if Kind == WEAPON_CATEGORY_TORCH then
		GuardIndex = GUARD_STYLE_TORCH
	elseif Kind ~= WEAPON_CATEGORY_SMALL_SHIELD and Kind ~= WEAPON_CATEGORY_MIDDLE_SHIELD and Kind ~= WEAPON_CATEGORY_LARGE_SHIELD then
		GuardIndex = GUARD_STYLE_DEFAULT
	end

	return GuardIndex
end

function Game_SetGuardStyle(IsDamage)
	local GuardIndex = Game_GetGuardStyle()
	if GuardIndex == GUARD_STYLE_DEFAULT or (GuardIndex == GUARD_STYLE_TORCH and (c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH)) then
		GuardIndex = 0
	end

	if IsDamage == TRUE then
		SetVariable("IsTorchGuard", FALSE)
		if GuardIndex == GUARD_STYLE_TORCH then
			SetVariable("IndexGuard", GUARD_STYLE_DEFAULT)
		else
			SetVariable("IndexGuard", GuardIndex)
		end
	else
		SetVariable("IndexGuardStyle", GuardIndex)
	end
end


--------------------------------------------------------------------------------
----------------------------------- REQUESTS -----------------------------------

function Request_IsButton(Button)
	return GV_Requests[Button].IsButton
end

function Request_IsPressed(Button)
	return GV_Requests[Button].IsPressed
end

function Request_IsReleased(Button)
	return GV_Requests[Button].IsReleased
end

function Request_GetDuration(Button)
	return GV_Requests[Button].Duration
end


--------------------------------------------------------------------------------
------------------------------------- TIMER ------------------------------------

function Timer_IsActive(Index)
	if GV_Timer.Actions[Index] ~= nil then
		return TRUE
	end

	return FALSE
end

function Timer_AddAction(Duration, Interval, ActionContinuous, ParameterContinuous, ActionFinal, ParameterFinal)
	GV_Timer.Index = GV_Timer.Index + 1
	GV_Timer.Count = GV_Timer.Count + 1
	GV_Timer.Actions[GV_Timer.Index] = {Duration, Duration, -1, Interval, ActionContinuous, ParameterContinuous, ActionFinal, ParameterFinal}

	return GV_Timer.Index
end

function Timer_AddActionOrRefresh(Index, Duration, Interval, ActionContinuous, ParameterContinuous, ActionFinal, ParameterFinal)
	if Timer_IsActive(Index) == FALSE then
		Index = Timer_AddAction(Duration, Interval, ActionContinuous, ParameterContinuous, ActionFinal, ParameterFinal)
	else
		Timer_RefreshAction(Index)
	end

	return Index
end

function Timer_RefreshAction(Index)
	if GV_Timer.Actions[Index] ~= nil then
		GV_Timer.Actions[Index][1] = GV_Timer.Actions[Index][2]
		GV_Timer.Actions[Index][3] = -1
	end
end

function Timer_ResetAction(Index, Duration, Interval)
	if GV_Timer.Actions[Index] ~= nil then
		GV_Timer.Actions[Index][1] = Duration
		GV_Timer.Actions[Index][2] = Duration
		GV_Timer.Actions[Index][3] = -1
		GV_Timer.Actions[Index][4] = Interval
	end
end

function Timer_EndAction(Index)
	if GV_Timer.Actions[Index] ~= nil then
		GV_Timer.Actions[Index][1] = 0
	end
end

function Timer_RemoveAction(Index)
	if GV_Timer.Actions[Index] ~= nil then
		GV_Timer.Actions[Index] = nil
		GV_Timer.Count = GV_Timer.Count - 1

		if GV_Timer.Count <= 0 then
			GV_Timer.Actions = {}
		end
	end
end

function Timer_ChangeDuration(Index, Duration)
	if GV_Timer.Actions[Index] ~= nil then
		GV_Timer.Actions[Index][1] = Duration
		GV_Timer.Actions[Index][2] = Duration
		GV_Timer.Actions[Index][3] = -1
	end
end


--------------------------------------------------------------------------------
-------------------------------- STATS & STATUS --------------------------------

function Stat_GetHP()
	return env(GetHP)
end

function Stat_GetFP()
	return env(GetFP)
end

function Stat_GetSP()
	return env(GetStamina)
end

----------------------------------------
function Stat_IncreaseHP(HP)
	if 0 < HP then
		act(ChangeHP, HP)
	end
end

function Stat_IncreaseFP(FP)
	if FP > 0 then
		local Level = math.floor((FP + GV_Effects.IncreaseFP - 1) / GV_Effects.IncreaseFP)
		Effect_AddByLevel(GC_SPEIDS.INCREASE_FP, Level)
	end
end

function Stat_IncreaseSP(SP)
	if 0 < SP then
		act(ChangeStamina, SP)
	end
end

----------------------------------------
function Stat_DecreaseHP(HP)
	if 0 < HP then
		act(ChangeHP, -HP)
	end
end

function Stat_DecreaseFP(FP)
	if FP > 0 then
		local Level = math.floor((FP + GV_Effects.DecreaseFP - 1) / GV_Effects.DecreaseFP)
		Effect_AddByLevel(GC_SPEIDS.DECREASE_FP, Level)
	end
end

function Stat_DecreaseSP(SP)
	if 0 < SP then
		act(ChangeStamina, -SP)
	end
end

----------------------------------------
function Stat_UseHP(HP)
	if Stat_GetHP() < HP then
		return FALSE
	end

	Stat_DecreaseHP(HP)

	return TRUE
end

function Stat_UseFP(FP)
	if Stat_GetFP() < FP then
		return FALSE
	end

	Stat_DecreaseFP(FP)

	return TRUE
end

function Stat_UseSP(SP)
	if Stat_GetSP() < SP then
		return FALSE
	end

	Stat_DecreaseSP(SP)

	return TRUE
end

----------------------------------------
function Status_IsInvisible()
	if Effect_IsActive(GC_SPEIDS.INVISIBLE_SHORT) == TRUE or Effect_IsActive(GC_SPEIDS.INVISIBLE_LONG) == TRUE or Effect_IsActive(GC_SPEIDS.INVISIBLE_INSTANT) == TRUE then
		return TRUE
	end

	return FALSE
end


--------------------------------------------------------------------------------
------------------------------------ EFFECTS -----------------------------------

function Effect_IsActive(ID)
	return env(GetSpEffectID, ID)
end

function Effect_AddByID(ID)
	act(AddSpEffect, ID)
end

function Effect_AddByLevel(ID, Level)
	if 1 <= Level and Level <= GV_Effects.MaxLevel then
		for i = 1, Level, 1 do
			act(AddSpEffect, ID)
		end
	end
end

function Effect_AddByInfo(Info)
	Effect_AddByLevel(Info[1], Info[2])
end

function Effect_AddBySteps(ID, Steps)
	if Steps == nil then
		Steps = 10
	end

	if g_FrameCount - math.floor(g_FrameCount / Steps) * Steps == 0 then
		Effect_AddByID(ID)
	end
end

----------------------------------------
function Effect_GetMaxLevel()
	return GV_Effects.MaxLevel
end

function Effect_GetDurationInstant()
	return GV_Effects.DurationInstant
end

function Effect_GetDurationShort()
	return GV_Effects.DurationShort
end

function Effect_GetDurationLong()
	return GV_Effects.DurationLong
end

function Effect_AdjustFrames()
	GV_Effects.DurationShort = System_AdjustFrames(GV_Effects.TargetDurationShort)
	GV_Effects.DurationLong = System_AdjustFrames(GV_Effects.TargetDurationLong)
end


--------------------------------------------------------------------------------
------------------------------------ ACTIONS -----------------------------------

function Action_Guard()
	if Action_IsGuardPossible() == FALSE then
		return
	end

	if env(GetSpEffectID, 172) == TRUE then
		SetVariable("GuardStartType", 1)
	else
		SetVariable("GuardStartType", 0)
	end

	local Hand = HAND_LEFT
	if c_Style == HAND_RIGHT_BOTH then
		Hand = HAND_RIGHT
	end

	local Kind = env(GetEquipWeaponCategory, Hand)

	if Deflect_IsCounterExtends() == TRUE or Kind ~= WEAPON_CATEGORY_TORCH then
		Deflect_Activate(FALSE)
	end

	local Blend_Type = ALLBODY
	if MoveStart(LOWER, Event_MoveLong, FALSE) == TRUE then
		Blend_Type = UPPER
	end

	ExecEventHalfBlend(Event_GuardStart, Blend_Type)
end

function Action_Roll()
	SetWeightIndex()

	local rollingEvent = "W_Rolling"
	local is_selfTrans = FALSE

	if IsNodeActive("Rolling_CMSG") == TRUE then
		is_selfTrans = TRUE
	end

	if estep == ESTEP_DOWN then
		rollingEvent = "W_EStepDown"
	elseif c_IsStealth == TRUE and GetVariable("EvasionWeightIndex") ~= EVASION_WEIGHT_INDEX_OVERWEIGHT then
		rollingEvent = "W_Stealth_Rolling"
	elseif is_selfTrans == TRUE then
		rollingEvent = rollingEvent .. "_Selftrans"
	end

	if GetVariable("IsEnableToggleDashTest") == 2 then
		SetVariable("ToggleDash", 0)
	end

	local turn_angle_real = 200

	if GetVariable("IsLockon") == false and env(IsPrecisionShoot) == FALSE and env(IsCOMPlayer) == FALSE or env(GetSpEffectID, 100002) == TRUE then
		SetVariable("RollingOverweightIndex", 0)

		if is_selfTrans == TRUE then
			SetVariable("RollingDirectionIndex_SelfTrans", 0)
		else
			SetVariable("RollingDirectionIndex", 0)
		end
	elseif GetVariable("EvasionWeightIndex") == EVASION_WEIGHT_INDEX_OVERWEIGHT then
		if c_RollingAngle <= 45 and c_RollingAngle >= -45 then
			SetVariable("RollingOverweightIndex", 0)
		elseif c_RollingAngle > 45 and c_RollingAngle < 135 then
			SetVariable("RollingOverweightIndex", 3)
		elseif c_RollingAngle >= 135 then
			SetVariable("RollingOverweightIndex", 1)
		elseif c_RollingAngle < -45 and c_RollingAngle > -135 then
			SetVariable("RollingOverweightIndex", 2)
		else
			SetVariable("RollingOverweightIndex", 1)
		end

		act(TurnToLockonTargetImmediately)

		turn_angle_real = math.abs(GetVariable("TurnAngle") - c_RollingAngle)

		if turn_angle_real > 180 then
			turn_angle_real = 360 - turn_angle_real
		end
	else
		local turn_target_angle = 0
		local rollingDirection = 0

		if c_RollingAngle <= GetVariable("RollingAngleThresholdRightFrontTest") and c_RollingAngle
			>= GetVariable("RollingAngleThresholdLeftFrontTest") then
			rollingDirection = 0
			turn_target_angle = c_RollingAngle
		elseif c_RollingAngle > GetVariable("RollingAngleThresholdRightFrontTest") and c_RollingAngle
			< GetVariable("RollingAngleThresholdRightBackTest") then
			rollingDirection = 3
			turn_target_angle = c_RollingAngle - 90
		elseif c_RollingAngle < GetVariable("RollingAngleThresholdLeftFrontTest") and c_RollingAngle
			> GetVariable("RollingAngleThresholdLeftBackTest") then
			rollingDirection = 2
			turn_target_angle = c_RollingAngle + 90
		else
			rollingDirection = 1
			turn_target_angle = c_RollingAngle - 180
		end

		if is_selfTrans == TRUE then
			SetVariable("RollingDirectionIndex_SelfTrans", rollingDirection)
		else
			SetVariable("RollingDirectionIndex", rollingDirection)
		end

		if GetVariable("IsLockon") == true then
			act(TurnToLockonTargetImmediately, turn_target_angle)
		else
			act(FaceDirection, turn_target_angle)
		end

		turn_angle_real = math.abs(GetVariable("TurnAngle") - c_RollingAngle)

		if turn_angle_real > 180 then
			turn_angle_real = 360 - turn_angle_real
		end
	end

	SetVariable("TurnAngleReal", turn_angle_real)

	if is_selfTrans == TRUE then
		SetVariable("RollingAngleRealSelftrans", c_RollingAngle)
	else
		SetVariable("RollingAngleReal", c_RollingAngle)
	end

	if DMN_EvasionAction_Mode ~= GC_MODES.EVASION_ACTIONS_DEFAULT then
		if is_selfTrans == TRUE then
			Action_Dash(GetVariable("RollingDirectionIndex_SelfTrans"))
		else
			Action_Dash(GetVariable("RollingDirectionIndex"))
		end
	else
		ExecEventAllBody(rollingEvent)
	end

	if GetVariable("IsEnableToggleDashTest") == 2 then
		SetVariable("ToggleDash", 0)
	end

	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()
end

function Action_Backstep()
	SetWeightIndex()

	if DMN_EvasionAction_Mode ~= GC_MODES.EVASION_ACTIONS_DEFAULT then
		Action_Dash(1)
	else
		if IsEnableGuard() == TRUE and IsGuard() == TRUE and GetVariable("EvasionWeightIndex") ~= EVASION_WEIGHT_INDEX_OVERWEIGHT then
			SetVariable("BackStepGuardLayer", 1)
			SetVariable("EnableTAE_BackStep", false)
			ExecEvent("W_DefaultBackStep")
			ExecEvent("W_BackStepGuardOn_UpperLayer")
		else
			SetVariable("BackStepGuardLayer", 0)
			SetVariable("EnableTAE_BackStep", true)
			ExecEventAllBody("W_DefaultBackStep")
		end
	end

	if GetVariable("IsEnableToggleDashTest") == 2 then
		SetVariable("ToggleDash", 0)
	end

	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()
end

function Action_Dash(Type)
	if Type == nil or Type < 0 or 3 < Type then
		Type = 0
	end

	local Dash_Event = ""
	if DMN_EvasionAction_Mode == GC_MODES.EVASION_ACTIONS_LADYBUTTERFLY or Effect_IsActive(GC_SPEIDS.STRING_MASTER_STATUS_AIR) == TRUE then
		Dash_Event = "W_DMN_LadyButterfly_Dash"
	elseif DMN_EvasionAction_Mode == GC_MODES.EVASION_ACTIONS_SEKIRO then
		Dash_Event = "W_DMN_Dash1"
	elseif DMN_EvasionAction_Mode == GC_MODES.EVASION_ACTIONS_BLOODHOUND then
		Dash_Event = "W_DMN_Dash2"
	end

	if Type == 1 then
		Dash_Event = Dash_Event .. "_Backward"
	elseif Type == 2 then
		Dash_Event = Dash_Event .. "_Left"
	elseif Type == 3 then
		Dash_Event = Dash_Event .. "_Right"
	else
		Dash_Event = Dash_Event .. "_Forward"
	end

	if Effect_IsActive(GC_SPEIDS.STRING_MASTER_STATUS_AIR) == TRUE then
		Dash_Event = Dash_Event .. "_Air"
	end

	ExecEventAllBody(Dash_Event)
end

function Action_Jump(Type)
	SetWeightIndex()

	if GetVariable("EvasionWeightIndex") == EVASION_WEIGHT_INDEX_OVERWEIGHT and env(IsAIJumpRequested) == FALSE then
		local jumpangle = env(GetJumpAngle) * 0.009999999776482582

		if jumpangle > -45 and jumpangle < 45 then
			SetVariable("JumpOverweightIndex", 0)
		elseif jumpangle >= 0 and jumpangle <= 100 then
			SetVariable("JumpOverweightIndex", 3)
		elseif jumpangle >= -100 and jumpangle <= 0 then
			SetVariable("JumpOverweightIndex", 2)
		else
			SetVariable("JumpOverweightIndex", 1)
		end

		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()
		ExecEventAllBody("W_Jump_Overweight")

		return TRUE
	end

	local style = c_Style

	if style == HAND_RIGHT then
		SetVariable("JumpAttack_HandCondition", 0)
	elseif style == HAND_RIGHT_BOTH then
		SetVariable("JumpAttack_HandCondition", 1)
	elseif style == HAND_LEFT_BOTH then
		if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW) == TRUE then
			SetVariable("JumpAttack_HandCondition", 4)
		else
			SetVariable("JumpAttack_HandCondition", 1)
		end
	end

	SetVariable("JumpAttackForm", 0)
	SetVariable("JumpUseMotion_Bool", false)
	SetVariable("JumpMotion_Override", 0.009999999776482582)
	SetVariable("JumpAttack_Land", 0)
	SetVariable("SwingPose", 0)
	IS_ATTACKED_JUMPMAGIC = FALSE

	if GetVariable("IsEnableToggleDashTest") == 2 then
		SetVariable("ToggleDash", 0)
	end

	local JumpMoveLevel = 0

	if GetVariable("LocomotionState") == 1 and GetVariable("MoveSpeedIndex") == 2 then
		JumpMoveLevel = 2
	elseif GetVariable("MoveSpeedLevel") >= 0.6000000238418579 then
		JumpMoveLevel = 1
	end

	if Type ~= nil then
		JumpMoveLevel = Type
	end

	if JumpMoveLevel == 2 then
		if env(IsAIJumpRequested) == TRUE then
			act(NotifyAIOfJumpState)
		end

		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()
		ExecEvent("W_Jump_D")

		return TRUE
	elseif JumpMoveLevel == 1 then
		if GetVariable("IsLockon") == FALSE and env(IsPrecisionShoot) == FALSE and env(IsCOMPlayer) == FALSE then
			SetVariable("JumpDirection", 0)
			SetVariable("JumpAngle", 0)
		else
			local turn_target_angle = 0
			local jumpangle = env(GetJumpAngle) * 0.009999999776482582

			if jumpangle > -45 and jumpangle < 45 then
				turn_target_angle = jumpangle
				SetVariable("JumpDirection", 0)
				SetVariable("JumpAngle", 0)
			elseif jumpangle >= 0 and jumpangle <= 100 then
				turn_target_angle = jumpangle - 90
				SetVariable("JumpDirection", 3)
				SetVariable("JumpAngle", 90)
			elseif jumpangle >= -100 and jumpangle <= 0 then
				turn_target_angle = jumpangle + 90
				SetVariable("JumpDirection", 2)
				SetVariable("JumpAngle", -90)
			else
				turn_target_angle = jumpangle - 180
				SetVariable("JumpDirection", 1)
				SetVariable("JumpAngle", 180)
			end

			if GetVariable("IsLockon") == true then
				act(TurnToLockonTargetImmediately, turn_target_angle)
			else
				act(FaceDirection, turn_target_angle)
			end
		end

		SetVariable("IsEnableDirectionJumpTAE", true)

		if env(IsAIJumpRequested) == TRUE then
			act(NotifyAIOfJumpState)
		end

		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()
		ExecEvent("W_Jump_F")

		return TRUE
	else
		SetVariable("JumpReachSelector", 0)

		if env(IsAIJumpRequested) == TRUE then
			act(NotifyAIOfJumpState)
		end

		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()
		ExecEvent("W_Jump_N")

		return TRUE
	end
end

function Action_JumpRiding(Type)
	if Type == nil then
		Type = GetVariable("MoveSpeedLevel")
	end

	if Type >= 1.5 then
		FireRideEvent("W_RideJump2_D", "W_RideJump2_D", FALSE)
	elseif Type >= 0.6000000238418579 then
		FireRideEvent("W_RideJump2_F", "W_RideJump2_F", FALSE)
	else
		FireRideEvent("W_RideJump2_N", "W_RideJump2_N", FALSE)
	end
end

function Action_Turn()
	ExecEventAllBody("W_Dash180")
end

function Action_Escape()
	if DMN_DeflectEscape_Mode == GC_MODES.DEFLECT_ESCAPE_DISABLE then
		Stat_DecreaseHP(math.random(100, 200))
		return FALSE
	end

	Effect_AddByID(GC_SPEIDS.INVISIBLE_SHORT)
	Effect_AddByID(GC_VFXIDS.SPOT_MIST_DARK_CENTER)
	if DMN_DeflectEscape_Mode == GC_MODES.DEFLECT_ESCAPE_TURN then
		Action_Turn()
	elseif DMN_DeflectEscape_Mode == GC_MODES.DEFLECT_ESCAPE_ROLL then
		Action_Roll()
	elseif DMN_DeflectEscape_Mode == GC_MODES.DEFLECT_ESCAPE_JUMP then
		Action_Jump(GC_ACTIONS.JUMP_FORWARD)
	end

	return TRUE
end

----------------------------------------
function Action_IsGuardPossible()
	local Style = c_Style
	if Style == HAND_RIGHT_BOTH or Style == HAND_LEFT_BOTH then
		local WP_Hand = HAND_RIGHT
		if Style == HAND_LEFT_BOTH then
			WP_Hand = HAND_LEFT
		end

		local WP_Category = env(GetEquipWeaponCategory, WP_Hand)
		if WP_Category == WEAPON_CATEGORY_SMALL_ARROW or WP_Category == WEAPON_CATEGORY_ARROW or WP_Category == WEAPON_CATEGORY_LARGE_ARROW or WP_Category == WEAPON_CATEGORY_CROSSBOW or WP_Category == WEAPON_CATEGORY_BALLISTA then
			return FALSE
		end

		return TRUE
	end

	if Style == HAND_RIGHT or Style == HAND_LEFT then
		if Game_IsDualWielding() == TRUE then
			return TRUE
		else
			local WP_Category = env(GetEquipWeaponCategory, HAND_LEFT)
			if WP_Category == WEAPON_CATEGORY_FIST or WP_Category == WEAPON_CATEGORY_SMALL_SHIELD or WP_Category == WEAPON_CATEGORY_MIDDLE_SHIELD or WP_Category == WEAPON_CATEGORY_LARGE_SHIELD or WP_Category == WEAPON_CATEGORY_DUELING_SHIELD then
				return TRUE
			end
		end
	end

	return FALSE
end

function Action_IsGuardCounterPossible()
	return GV_Actions.Counter
end

function Action_SetGuardCounterPossible(IsCounterPossible)
	GV_Actions.Counter = IsCounterPossible
end

function Action_AddGuardCounterStatus()
	Action_SetGuardCounterPossible(TRUE)
	GV_Actions.TimerID_GuardCounter = Timer_AddActionOrRefresh(GV_Actions.TimerID_GuardCounter, System_MillisecondsToFrames(DMN_GuardCounter_Time), Effect_GetDurationInstant(), Action_SetGuardCounterPossible, TRUE, Action_SetGuardCounterPossible, FALSE)
end

function Action_EndGuardCounterStatus()
	Timer_EndAction(GV_Actions.TimerID_GuardCounter)
end

----------------------------------------
function Action_IsSpecial()
	return GV_Actions.Special
end

function Action_SetSpecial(IsSpecial)
	GV_Actions.Special = IsSpecial
end

function Action_IsCritical()
	return GV_Actions.Critical
end

function Action_SetCritical(IsCritical)
	GV_Actions.Critical = IsCritical
end

function Action_IsJumping()
	if env(IsLanding) == FALSE then
		return TRUE
	end

	return FALSE
end

function Action_IsEvadingPossible()
	return GV_Actions.EvadingPossible
end

function Action_SetEvadingPossible(IsEvadingPossible)
	GV_Actions.EvadingPossible = IsEvadingPossible
end

function Action_IsCasting()
	return GV_Actions.Casting
end

function Action_SetCasting(IsCasting)
	GV_Actions.Casting = IsCasting
end

----------------------------------------
function Action_IsAnimationCancel()
	return env(GetEventEzStateFlag, GC_FLAGS.ANIMATION_CANCEL)
end

function Action_IsAnimationPlaying()
	return env(GetEventEzStateFlag, GC_FLAGS.ANIMATION_PLAYING)
end

function Action_IsAnimationEnd()
	return env(GetEventEzStateFlag, GC_FLAGS.ANIMATION_END)
end

function Action_IsSpecialRequest()
	return GV_Actions.SpecialRequest
end

function Action_SetSpecialRequest(IsSpecialRequest)
	GV_Actions.SpecialRequest = IsSpecialRequest
end

function Action_CancelAnimation()
	if Action_IsAnimationPlaying() == TRUE then
		if DMN_GuardCancel_Mode ~= GC_MODES.GUARD_CANCEL_OVERRIDE and Request_IsPressed(GC_BUTTONS.L1) == TRUE and Deflect_IsSuccess() == TRUE then
			Deflect_Activate(FALSE)
			return
		end

		if Action_IsAnimationEnd() == TRUE then
			ExecEventAllBody("W_Idle")
			return
		end

		if Cancel_IsCooldown() == TRUE then
			return
		end

		if Request_IsPressed(GC_BUTTONS.R1) == TRUE then
			if DMN_CustomMovesets_Mode == GC_MODES.MOVESETS_DEFAULT then
				if Deflect_IsCounterPossible() == TRUE then
					Action_SetSpecialRequest(TRUE)
				end

				if c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH then
					ExecEventAllBody(BOTH_LIGHT1)
				else
					if Game_IsDualWielding() == TRUE then
						ExecEventAllBody(DUAL_LIGHT1)
					else
						ExecEventAllBody(RIGHT_LIGHT1)
					end
				end
			end
		elseif Request_IsPressed(GC_BUTTONS.R2) == TRUE then
			if DMN_CustomMovesets_Mode == GC_MODES.MOVESETS_DEFAULT then
				if Deflect_IsCounterPossible() == TRUE then
					Action_SetSpecialRequest(TRUE)
				end

				if c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH then
					if Action_IsGuardCounterPossible() == TRUE then
						ExecEventAllBody(BOTH_COUNTER)
					else
						ExecEventAllBody(BOTH_HEAVY1_CHARGE)
					end
				else
					if Action_IsGuardCounterPossible() == TRUE then
						ExecEventAllBody(RIGHT_COUNTER)
					else
						ExecEventAllBody(RIGHT_HEAVY1_CHARGE)
					end
				end
			end
		end
	end
end

----------------------------------------
function Action_AttackAction_onUpdate(TransAction, IsOnAir)
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1SubStart", "W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
	end

	-- MODIFY: Begin.
	if TransAction ~= nil then
		if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, GC_FLAGS.ANIMATION_END) == TRUE then
			ExecEvent(TransAction)
			return
		end
	end
	-- MODIFY: End.

end

function Action_EvasionAction_onUpdate(TransAction)

	-- MODIFY: Begin.
	if Game_IsPlayer() == TRUE then
		Movement_AdjustMultiplier(DMN_RollingDistance_Level)
	end
	-- MODIFY: End.

	act(DisallowAdditiveTurning, TRUE)
	SetThrowAtkInvalid()

	if env(GetSpEffectID, 100390) == TRUE then
		ResetDamageCount()
	end

	SetEnableAimMode()

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLightStep", "W_AttackRightHeavy1Start",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothLightStep", "W_AttackBothHeavy1Start",
		QUICKTYPE_ROLLING) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventAllBody("W_Idle")
		return
	end

	-- MODIFY: Begin.
	if TransAction ~= nil then
		if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, GC_FLAGS.ANIMATION_END) == TRUE then
			ExecEvent(TransAction)
			return
		end
	end
	-- MODIFY: End.

end

function Action_BackstepAction_onUpdate(TransAction)

	-- MODIFY: Begin.
	if Game_IsPlayer() == TRUE then
		Movement_AdjustMultiplier(DMN_BackstepDistance_Level)
	end
	-- MODIFY: End.

	act(SetCanChangeEquipmentOff)
	act(DisallowAdditiveTurning, TRUE)

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightBackstep", "W_AttackRightHeavy1Start",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothBackstep", "W_AttackBothHeavy1Start",
		QUICKTYPE_BACKSTEP) == TRUE then
		return
	end

	-- MODIFY: Begin.
	if TransAction ~= nil then
		if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, GC_FLAGS.ANIMATION_END) == TRUE then
			ExecEvent(TransAction)
			return
		end
	end
	-- MODIFY: End.

end

function Action_IdleAction_onUpdate(TransAction)
	SetEnableMimicry()

	if IdleCommonFunction() == TRUE then
		SetVariable("ArtsTransition", 0)
	end

	-- MODIFY: Begin.
	if TransAction ~= nil then
		if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, GC_FLAGS.ANIMATION_END) == TRUE then
			ExecEvent(TransAction)
			return
		end
	end
	-- MODIFY: End.

end


--------------------------------------------------------------------------------
------------------------------------ DEFLECT -----------------------------------

function Deflect_IsActive()
	return Effect_IsActive(GC_SPEIDS.DEFLECT_STATUS)
end

function Deflect_IsCooldown()
	return GV_Deflect.Cooldown
end

function Deflect_SetCooldown(IsCooldown)
	GV_Deflect.Cooldown = IsCooldown
end

function Deflect_IsRepel()
	return GV_Deflect.Repel
end

function Deflect_SetRepel(IsRepel)
	GV_Deflect.Repel = IsRepel

	Deflect_SetPerfect(FALSE)
	if IsRepel == TRUE then
		Deflect_SetSuccess(TRUE)
		Deflect_SetDuration(DMN_DeflectDuration_Time)

		if Timer_IsActive(GV_Deflect.TimerID_Perfect) == TRUE then
			Deflect_SetPerfect(TRUE)
			Gameplay_GuardStance_SetPerfect(TRUE)
		end
	end
end

function Deflect_IsRefresh()
	return GV_Deflect.Refresh
end

function Deflect_SetRefresh(IsRefresh)
	GV_Deflect.Refresh = IsRefresh
end

function Deflect_IsSuccess()
	return GV_Deflect.Success
end

function Deflect_SetSuccess(IsSuccess)
	GV_Deflect.Success = IsSuccess
end

function Deflect_IsPerfect()
	return GV_Deflect.Perfect
end

function Deflect_SetPerfect(IsPerfect)
	GV_Deflect.Perfect = IsPerfect
end

function Deflect_IsHeavy()
	return GV_Deflect.Heavy
end

function Deflect_SetHeavy(IsHeavy)
	GV_Deflect.Heavy = IsHeavy
end

function Deflect_GetDuration()
	return GV_Deflect.Duration
end

function Deflect_SetDuration(Duration)
	GV_Deflect.Duration = Duration
end

----------------------------------------
function Deflect_IsCounterAttack()
	return GV_Deflect.Counter
end

function Deflect_SetCounterAttack(IsCounter)
	GV_Deflect.Counter = IsCounter
end

function Deflect_IsInterruptAttack()
	return GV_Deflect.Interrupt
end

function Deflect_SetInterruptAttack(IsInterrupt)
	GV_Deflect.Interrupt = IsInterrupt
end

function Deflect_IsCounterPossible()
	if DMN_AttackCounter_Mode == GC_MODES.DEFLECT_ATTACK_STOP or DMN_AttackCounter_Mode == GC_MODES.DEFLECT_ATTACK_STOP_INTERRUPT or DMN_AttackCounter_Mode == GC_MODES.DEFLECT_ATTACK_CONTINUE or DMN_AttackCounter_Mode == GC_MODES.DEFLECT_ATTACK_CONTINUE_INTERRUPT then
		if Request_IsPressed(GC_BUTTONS.L1) == FALSE then
			return TRUE
		end
	end

	return FALSE
end

function Deflect_IsCounterExtends()
	if DMN_DeflectExtends_Mode == GC_MODES.DEFLECT_EXTENDS_ENABLE then
		return TRUE
	end

	return FALSE
end

function Deflect_GetCounterMaxLevel()
	return GV_Deflect.CounterMaxLevel
end

function Deflect_GetCounterLevel()
	return GV_Deflect.CounterLevel
end

function Deflect_SetCounterLevel(Level)
	GV_Deflect.CounterLevel = Level
end

function Deflect_SetGuardAnimation(GuardLevel)
	if (DMN_AttackCounter_Mode == GC_MODES.DEFLECT_ATTACK_CONTINUE or DMN_AttackCounter_Mode == GC_MODES.DEFLECT_ATTACK_CONTINUE_INTERRUPT or Deflect_IsInterruptAttack() == FALSE) and Deflect_IsCounterAttack() == TRUE then
		return
	end

	if DMN_DeflectPushback_Mode == GC_MODES.DEFLECT_PUSHBACK_DEFAULT then
		if GuardLevel < 4 then
			act(SetDamageAnimType, DAMAGE_FLAG_GUARD_SMALL)
		else
			act(SetDamageAnimType, DAMAGE_FLAG_GUARD_EXLARGE)
		end
	elseif DMN_DeflectPushback_Mode == GC_MODES.DEFLECT_PUSHBACK_MEDIUM then
		if 1 < GuardLevel and GuardLevel < 4 then
			act(SetDamageAnimType, DAMAGE_FLAG_GUARD_SMALL)
		else
			act(SetDamageAnimType, DAMAGE_FLAG_GUARD_EXLARGE)
		end
	elseif DMN_DeflectPushback_Mode == GC_MODES.DEFLECT_PUSHBACK_STRONG then
		if 4 <= GuardLevel then
			act(SetDamageAnimType, DAMAGE_FLAG_GUARD_EXLARGE)
		end
	elseif DMN_DeflectPushback_Mode == GC_MODES.DEFLECT_PUSHBACK_NONE then
		--
	end

	local VFX_Level = DMN_DeflectVFX_Level
	if VFX_Level <= 0 then
		VFX_Level = GuardLevel
	elseif 1 < VFX_Level then
		VFX_Level = VFX_Level + 1
	end

	if VFX_Level <= 1 then
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
	elseif VFX_Level <= 3 then
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
	else
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
	end

	local GC_ANIMATIONS = nil
	if DMN_DeflectAnimation_Mode == GC_MODES.DEFLECT_ANIMATION_SEKIRO then
		GC_ANIMATIONS = GC_ANIMATIONS_SEKIRO
	elseif DMN_DeflectAnimation_Mode == GC_MODES.DEFLECT_ANIMATION_LADYBUTTERFLY then
		GC_ANIMATIONS = GC_ANIMATIONS_LADYBUTTERFLY
	end

	if GC_ANIMATIONS ~= nil then
		if GV_Deflect.AnimationQueue[1] == 2 then
			GV_Deflect.AnimationQueue[1] = 1
		else
			GV_Deflect.AnimationQueue[1] = 2
		end

		local Knockback_Chance = math.random(1, 100)
		local List_Animations = GC_ANIMATIONS.DEFLECT.LEFT
		if GuardLevel <= 1 then
			if DMN_DeflectPushback_Chance < Knockback_Chance then
				if GV_Deflect.AnimationQueue[1] == 2 then
					List_Animations = GC_ANIMATIONS.DEFLECT.RIGHT
				end
			else
				List_Animations = GC_ANIMATIONS.DEFLECT.PUSH_LEFT
				if GV_Deflect.AnimationQueue[1] == 2 then
					List_Animations = GC_ANIMATIONS.DEFLECT.PUSH_RIGHT
				end

				Effect_AddByID(GC_SFXID.DEFLECT_P1)
			end
		elseif GuardLevel <= 3 and DMN_DeflectKnockback_Chance < Knockback_Chance then
			Knockback_Chance = math.random(0, #List_Animations)
			if 0 < Knockback_Chance then
				if GV_Deflect.AnimationQueue[1] == 2 then
					List_Animations = GC_ANIMATIONS.DEFLECT.RIGHT
				end
			else
				List_Animations = GC_ANIMATIONS.DEFLECT.PUSH_LEFT
				if GV_Deflect.AnimationQueue[1] == 2 then
					List_Animations = GC_ANIMATIONS.DEFLECT.PUSH_RIGHT
				end

				Effect_AddByID(GC_SFXID.DEFLECT_P1)
			end
		else
			List_Animations = GC_ANIMATIONS.DEFLECT.HEAVY
			Deflect_SetHeavy(TRUE)
		end

		local Index_Animation = math.random(1, #List_Animations)
		ExecEventAllBody(List_Animations[Index_Animation])

		local Index_Sound = math.random(1, #GC_SOUNDS.DEFLECT)
		if GV_Deflect.SoundIndex == Index_Sound then
			Index_Sound = Index_Sound + 1
			if #GC_SOUNDS.DEFLECT < Index_Sound then
				Index_Sound = 1
			end
		end

		GV_Deflect.SoundIndex = Index_Sound
		Effect_AddByID(GC_SOUNDS.DEFLECT[GV_Deflect.SoundIndex])

		local Index_Sound_Heavy = math.random(0, 1)
		if Index_Sound_Heavy == 1 then
			Effect_AddByID(GC_SFXID.DEFLECT_B1)
		end

		return
	end

	local Index_Sound = math.random(1, #GC_SOUNDS.DEFLECT)
	if GV_Deflect.SoundIndex == Index_Sound then
		Index_Sound = Index_Sound + 1
		if #GC_SOUNDS.DEFLECT < Index_Sound then
			Index_Sound = 1
		end
	end

	GV_Deflect.SoundIndex = Index_Sound
	Effect_AddByID(GC_SOUNDS.DEFLECT[GV_Deflect.SoundIndex])

	local Type = math.random(1, 2)
	if GV_Deflect.AnimationQueue[1] == GV_Deflect.AnimationQueue[2] and GV_Deflect.AnimationQueue[2] == Type then
		if Type == 1 then
			Type = 2
		else
			Type = 1
		end
	end

	GV_Deflect.AnimationQueue[1] = GV_Deflect.AnimationQueue[2]
	GV_Deflect.AnimationQueue[2] = Type

	if (DMN_DeflectAnimation_Mode == GC_MODES.DEFLECT_ANIMATION_DEFAULT or Type == 1) and (c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH or Deflect_IsCounterAttack() == FALSE) then
		if GuardLevel <= 1 then
			ExecEventAllBody("W_GuardDamageSmall")
		elseif GuardLevel <= 3 then
			ExecEventAllBody("W_GuardDamageSmall")
		elseif GuardLevel <= 4 then
			ExecEventAllBody("W_GuardDamageLarge")
		end

		return
	end

	if c_Style == HAND_RIGHT then
		if Deflect_IsCounterAttack() == TRUE then
			SetVariable("GuardDamageIndex", 0)
		else
			SetVariable("GuardDamageIndex", 2)
		end
	else
		SetVariable("GuardDamageIndex", 1)
	end

	if GuardLevel <= 3 then
		if Deflect_IsCounterAttack() == TRUE then
			ExecEventAllBody("W_Repelled_Small")
		else
			ExecEventAllBody("W_Repelled_Wall")
		end
	elseif GuardLevel <= 4 then
		ExecEventAllBody("W_GuardDamageLarge")
	end
end

function Deflect_SetAdditionalVFX()
	if DMN_DeflectVFX_Mode == GC_MODES.DEFLECT_VFX_ALL or (DMN_DeflectVFX_Mode == GC_MODES.DEFLECT_VFX_PERFECT and Deflect_IsPerfect() == TRUE) then
		Effect_AddByID(GC_VFXIDS.FLASH_HORIZONTAL_GOLDEN_IMPACT)
		Effect_AddByID(GC_VFXIDS.FLASH_HORIZONTAL_GOLDEN_SPARK)
	end
end

----------------------------------------
function Deflect_AddEffect()
	Effect_AddByID(GC_SPEIDS.DEFLECT_STATUS)
	if DMN_DeflectRepel_Mode == GC_MODES.DEFLECT_REPEL_ALL or (Combo_IsGuardStance() == TRUE and Timer_IsActive(GV_Deflect.TimerID_Perfect) == TRUE) or ((DMN_AttackCounter_Mode == GC_MODES.DEFLECT_ATTACK_STOP_INTERRUPT or DMN_AttackCounter_Mode == GC_MODES.DEFLECT_ATTACK_CONTINUE_INTERRUPT or Deflect_IsInterruptAttack() == FALSE) and Deflect_IsCounterAttack() == TRUE) then
		Effect_AddByID(GC_SPEIDS.DEFLECT_REPEL_ALL)
	elseif DMN_DeflectRepel_Mode == GC_MODES.DEFLECT_REPEL_NONE then
		Effect_AddByID(GC_SPEIDS.DEFLECT_REPEL_NONE)
	end
end

function Deflect_AddStatus()
	if 0 < DMN_DeflectDuration_Time then
		if 3 <= Deflect_GetDuration() then
			if 0 < DMN_DeflectPerfect_Time then
				GV_Deflect.TimerID_Perfect = Timer_AddActionOrRefresh(GV_Deflect.TimerID_Perfect, DMN_DeflectPerfect_Time, DMN_DeflectPerfect_Time, nil, nil, nil, nil)
			end

			if Timer_IsActive(GV_Deflect.TimerID_Status) == FALSE then
				Deflect_AddEffect()
			end

			GV_Deflect.TimerID_Status = Timer_AddActionOrRefresh(GV_Deflect.TimerID_Status, DMN_DeflectDuration_Time, Effect_GetDurationInstant(), Deflect_AddEffect, nil, Deflect_Timeout, nil)
		end

		if 0 < DMN_DeflectPenalty_Duration and (0 < DMN_DeflectPenalty_Percent or 0 < DMN_DeflectPenalty_Amount) then
			if Timer_IsActive(GV_Deflect.TimerID_Penalty) == TRUE and Deflect_IsSuccess() == FALSE and Deflect_IsRefresh() == FALSE then
				local Duration = 0
				if 0 < DMN_DeflectPenalty_Percent then
					Duration = Deflect_GetDuration() * (100 - DMN_DeflectPenalty_Percent) / 100
				else
					if 0 < DMN_DeflectPenalty_Amount then
						Duration = Deflect_GetDuration() - System_MillisecondsToFrames(DMN_DeflectPenalty_Amount)
					else
						Duration = DMN_DeflectDuration_Time
					end
				end

				if Duration < 1 then
					Duration = 1
				elseif DMN_DeflectDuration_Time < Duration then
					Duration = DMN_DeflectDuration_Time
				end

				Deflect_SetDuration(Duration)
				Timer_ChangeDuration(GV_Deflect.TimerID_Status, Deflect_GetDuration())
			else
				Deflect_SetDuration(DMN_DeflectDuration_Time)
			end

			GV_Deflect.TimerID_Penalty = Timer_AddActionOrRefresh(GV_Deflect.TimerID_Penalty, System_MillisecondsToFrames(DMN_DeflectPenalty_Duration), System_MillisecondsToFrames(DMN_DeflectPenalty_Duration), nil, nil, Deflect_SetDuration, DMN_DeflectDuration_Time)
		end

		Deflect_SetSuccess(FALSE)
		Deflect_SetRefresh(FALSE)
	end
end

function Deflect_RefreshStatus()
	Deflect_SetRefresh(TRUE)

	if Timer_IsActive(GV_Deflect.TimerID_Status) == TRUE then
		Timer_RefreshAction(GV_Deflect.TimerID_Status)
	else
		Deflect_AddStatus()
	end
end

function Deflect_EndStatus()
	Timer_EndAction(GV_Deflect.TimerID_Status)
end

function Deflect_Activate(IsCounter)
	Game_SetGuardStyle(FALSE)
	Deflect_SetCounterAttack(IsCounter)
	if Deflect_IsCooldown() == FALSE and (Timer_IsActive(GV_Deflect.TimerID_Status) == FALSE or 0 < DMN_DeflectPenalty_Duration or Deflect_IsRefresh() == TRUE or Deflect_IsSuccess() == TRUE) then
		Deflect_AddStatus()
	end
end

function Deflect_Timeout()
	if 0 < DMN_DeflectCooldown_Time then
		if Deflect_IsSuccess() == FALSE then
			GV_Deflect.TimerID_Cooldown = Timer_AddActionOrRefresh(GV_Deflect.TimerID_Cooldown, DMN_DeflectCooldown_Time, Effect_GetDurationInstant(), Deflect_SetCooldown, TRUE, Deflect_SetCooldown, FALSE)
		end
	end

	local TimeoutAction = nil
	if DMN_AccumulateDeflect_Mode == GC_MODES.DEFLECT_ACCUMULATE_BALANCE then
		TimeoutAction = Accumulate_ResetOnZero
	elseif DMN_AccumulateDeflect_Mode == GC_MODES.DEFLECT_ACCUMULATE_BYPASS then
		TimeoutAction = Accumulate_ResetOnPassed
	elseif DMN_AccumulateDeflect_Mode == GC_MODES.DEFLECT_ACCUMULATE_STRICT then
		TimeoutAction = Accumulate_ResetOnFailure
	end

	if TimeoutAction ~= nil then
		TimeoutAction()
	end
end

function Deflect_Protect(IsGuard)
	local IsProtected = FALSE
	local Damage_Angle = env(GetReceivedDamageDirection)

	if DMN_DeflectProtect_Mode == GC_MODES.DEFLECT_PROTECT_FRONT then
		if Damage_Angle == DAMAGE_DIR_FRONT then
			IsProtected = TRUE
		end
	elseif DMN_DeflectProtect_Mode == GC_MODES.DEFLECT_PROTECT_SIDES then
		if Damage_Angle ~= DAMAGE_DIR_BACK then
			IsProtected = TRUE
		end
	elseif DMN_DeflectProtect_Mode == GC_MODES.DEFLECT_PROTECT_ALL then
		IsProtected = TRUE
	end

	if IsProtected == TRUE then
		local Guard_Level = env(GetGuardLevelAction)
		if env(GetSpEffectID, 171) == TRUE and Guard_Level < 3 then
			Guard_Level = 3
		end

		if Guard_Level ~= 1 and Guard_Level ~= 3 and Guard_Level ~= 4 then
			local Damage_Level = env(GetDamageLevel)
			if Damage_Level == DAMAGE_LEVEL_EXLARGE or Damage_Level == DAMAGE_LEVEL_FLING or Damage_Level == DAMAGE_LEVEL_SMALL_BLOW or Damage_Level == DAMAGE_LEVEL_UPPER or Damage_Level == DAMAGE_LEVEL_EX_BLAST or Damage_Level == DAMAGE_LEVEL_BREATH then
				Guard_Level = 4
			elseif Damage_Level == DAMAGE_LEVEL_MIDDLE or Damage_Level == DAMAGE_LEVEL_LARGE then
				Guard_Level = 3
			else
				Guard_Level = 1
			end
		end

		Action_AddGuardCounterStatus()
		Game_SetGuardStyle(TRUE)
		Deflect_SetRepel(IsGuard)
		Deflect_SetCounterLevel(Guard_Level)
		if IsGuard == TRUE then
			Deflect_SetGuardAnimation(Guard_Level)
		end

		return TRUE
	else
		return Action_Escape()
	end
end

function Deflect_Restore()
	local RestoreHP, RestoreFP, RestoreSP = 0, 0, 0
	if DMN_DeflectRestore_Mode == GC_MODES.DEFLECT_RESTORE_SAME then
		RestoreHP = DMN_DeflectRestore_HP
		RestoreFP = DMN_DeflectRestore_FP
		RestoreSP = DMN_DeflectRestore_SP
	elseif DMN_DeflectRestore_Mode == GC_MODES.DEFLECT_RESTORE_VARY then
		local Level = System_GetValueLimit(Deflect_GetCounterLevel(), 1, Deflect_GetCounterMaxLevel())
		RestoreHP = DMN_DeflectRestore_HP * Level
		RestoreFP = DMN_DeflectRestore_FP * Level
		RestoreSP = DMN_DeflectRestore_SP * Level
	elseif DMN_DeflectRestore_Mode == GC_MODES.DEFLECT_RESTORE_STACK then
		local Stack = System_GetValueLimit(Accumulate_GetStack(), 1, Deflect_GetCounterMaxLevel())
		RestoreHP = DMN_DeflectRestore_HP * Stack
		RestoreFP = DMN_DeflectRestore_FP * Stack
		RestoreSP = DMN_DeflectRestore_SP * Stack
	end

	if 0 < RestoreHP then
		Stat_IncreaseHP(RestoreHP)
	end

	if 0 < RestoreFP then
		Stat_IncreaseFP(RestoreFP)
	end

	if 0 < RestoreSP then
		Stat_IncreaseSP(RestoreSP)
	end
end

function Deflect_UpdateStatus()
	if DMN_DeflectStatus_Mode == GC_MODES.DEFLECT_STATUS_CLEAR then
		if Deflect_IsRepel() == TRUE then
			Deflect_EndStatus()
		end
	elseif DMN_DeflectStatus_Mode == GC_MODES.DEFLECT_STATUS_KEEP then
		-- 
	elseif DMN_DeflectStatus_Mode == GC_MODES.DEFLECT_STATUS_REFRESH then
		if Deflect_IsRepel() == TRUE then
			Deflect_RefreshStatus()
		end
	end

	if DMN_DeflectStyle_Mode == GC_MODES.DEFLECT_STYLE_REMOVE then
		if Request_IsReleased(GC_BUTTONS.L1) == TRUE then
			Deflect_EndStatus()
		end
	elseif DMN_DeflectStyle_Mode == GC_MODES.DEFLECT_STYLE_KEEP then
		--
	end
end

function Deflect_RepelAttack()
	if Deflect_IsRepel() == TRUE then
		Special_DeflectRepel()
		Special_DeflectConfuse()
		Special_DeflectRecovery()

		if Deflect_IsCounterAttack() == TRUE then
			if DMN_AttackCounterRefresh_Mode == GC_MODES.DEFLECT_ATTACK_REFRESH_DISABLE then
				Deflect_EndStatus()
			end
		end

		Accumulate_Increase()
		if Accumulate_IsReady() == TRUE or DMN_AccumulateBonus_Mode == GC_MODES.DEFLECT_ACCUMULATE_BONUS_DYNAMIC then
			Accumulate_AddState()
		else
			Accumulate_AddTimeout()
		end

		Deflect_SetAdditionalVFX()
		Deflect_SetRepel(FALSE)
	end
end


--------------------------------------------------------------------------------
------------------------------ DEFLECT ACCUMULATE ------------------------------

function Accumulate_IsReady()
	if DMN_AccumulateDeflect_Number <= GV_Accumulate.Count then
		return TRUE
	end

	return FALSE
end

function Accumulate_Increase()
	GV_Accumulate.Count = GV_Accumulate.Count + 1
end

function Accumulate_ResetOnZero()
	if Deflect_IsSuccess() == FALSE then
		if 0 < GV_Accumulate.Count then
			GV_Accumulate.Count = GV_Accumulate.Count - 1
		end
	end
end

function Accumulate_ResetOnPassed()
	if Deflect_IsSuccess() == FALSE then
		GV_Accumulate.Pass = GV_Accumulate.Pass + 1
	else
		GV_Accumulate.Pass = 0
	end

	if GV_Accumulate.MaxPass < GV_Accumulate.Pass then
		GV_Accumulate.Count = 0
		GV_Accumulate.Pass = 0
	end
end

function Accumulate_ResetOnFailure()
	if Deflect_IsSuccess() == FALSE then
		GV_Accumulate.Count = 0
	end
end

function Accumulate_GetStack()
	return GV_Accumulate.Count
end

function Accumulate_BoostStats()
	local AccumulateAttack_Level = DMN_AccumulateAttack_Level
	local AccumulatePower_Level = DMN_AccumulatePower_Level
	local AccumulateDefense_Level = DMN_AccumulateDefense_Level

	if DMN_AccumulateBonus_Mode == GC_MODES.DEFLECT_ACCUMULATE_BONUS_DYNAMIC then
		AccumulateAttack_Level = Accumulate_GetStack() * DMN_AccumulateAttack_Level / DMN_AccumulateDeflect_Number
		AccumulatePower_Level = Accumulate_GetStack() * DMN_AccumulatePower_Level / DMN_AccumulateDeflect_Number
		AccumulateDefense_Level = Accumulate_GetStack() * DMN_AccumulateDefense_Level / DMN_AccumulateDeflect_Number
	end

	Effect_AddByLevel(GC_SPEIDS.BUFF_ATTACK, AccumulateAttack_Level)
	Effect_AddByLevel(GC_SPEIDS.BUFF_POWER, AccumulatePower_Level)
	Effect_AddByLevel(GC_SPEIDS.BUFF_DEFENSE, AccumulateDefense_Level)
end

function Accumulate_AddState()
	if 0 < DMN_AccumulateDuration_Time then
		GV_Accumulate.TimerID_State = Timer_AddActionOrRefresh(GV_Accumulate.TimerID_State, DMN_AccumulateDuration_Time, Effect_GetDurationLong(), Accumulate_BoostStats, nil, nil, nil)

		if DMN_AccumulateDeflect_VFX == GC_MODES.ACTION_CANCEL_VFX_ENABLE then
			GV_Accumulate.TimerID_VFX = Timer_AddActionOrRefresh(GV_Accumulate.TimerID_VFX, DMN_AccumulateDuration_Time, Effect_GetDurationShort(), Effect_AddByID, GC_VFXIDS.AURA_MIST_WHITE, nil, nil)
		end

		Accumulate_AddTimeout()
	end
end

function Accumulate_AddTimeout()
	if 0 < DMN_AccumulateTimeout_Time then
		GV_Accumulate.TimerID_Timeout = Timer_AddActionOrRefresh(GV_Accumulate.TimerID_Timeout, DMN_AccumulateTimeout_Time, DMN_AccumulateTimeout_Time, nil, nil, Accumulate_Timeout, nil)
	end
end

function Accumulate_Timeout()
	GV_Accumulate.Count = 0

	if DMN_AccumulateDeflect_VFX == GC_MODES.ACTION_CANCEL_VFX_ENABLE then
	--	Effect_AddByID(GC_VFXIDS.BLAST_SPARK_WHITE_LEFT)
	end
end


--------------------------------------------------------------------------------
--------------------------------- ACTION CANCEL --------------------------------

function Cancel_IsOverrideEvasion()
	if DMN_EvasionCancel_Mode == GC_MODES.EVASION_CANCEL_OVERRIDE or DMN_EvasionCancel_Mode == GC_MODES.EVASION_CANCEL_NODELAY then
		return TRUE
	end

	return FALSE
end

function Cancel_IsOverrideJump()
	if DMN_JumpCancel_Mode == GC_MODES.JUMP_CANCEL_OVERRIDE or DMN_JumpCancel_Mode == GC_MODES.JUMP_CANCEL_DOUBLE or DMN_JumpCancel_Mode == GC_MODES.JUMP_CANCEL_INFINITE then
		return TRUE
	end

	return FALSE
end

function Cancel_IsCooldown()
	return GV_Cancel.Cooldown
end

function Cancel_SetCooldown(IsCooldown)
	GV_Cancel.Cooldown = IsCooldown
end

function Cancel_AddCooldown(Duration)
	Cancel_SetCooldown(TRUE)
	Cancel_SetQueueReady(FALSE)
	Timer_AddAction(Duration, Effect_GetDurationInstant(), Cancel_SetCooldown, TRUE, Cancel_SetCooldown, FALSE)
	Timer_AddAction(GV_Cancel.QueueCooldown, Effect_GetDurationInstant(), Cancel_SetQueueReady, FALSE, Cancel_SetQueueReady, TRUE)
end

function Cancel_IsEvasionTimeout()
	if GV_Cancel.EvasionTimeout < GV_Cancel.EvasionDuration then
		return TRUE
	end

	return FALSE
end

function Cancel_GetEvasionDuration()
	return GV_Cancel.EvasionDuration
end

function Cancel_SetEvasionDuration(Duration)
	GV_Cancel.EvasionDuration = Duration
end

----------------------------------------
function Cancel_IsSecondJump()
	if 0 < GV_Cancel.JumpCount then
		return TRUE
	end

	return FALSE
end

function Cancel_IncreaseJumpCount()
	GV_Cancel.JumpCount = GV_Cancel.JumpCount + 1
end

function Cancel_ResetJumpCount()
	if Action_IsJumping() == FALSE then
		GV_Cancel.JumpCount = 0
	end
end

function Cancel_IsRollReady()
	return GV_Cancel.RollReady
end

function Cancel_IsBackstepReady()
	return GV_Cancel.BackstepReady
end

function Cancel_IsJumpReady()
	return GV_Cancel.JumpReady
end

function Cancel_IsQueueReady()
	return GV_Cancel.QueueReady
end

function Cancel_SetQueueReady(IsQueueReady)
	GV_Cancel.QueueReady = IsQueueReady
end

function Cancel_QueueActions(Action)
	if Action == GC_ACTIONS.EVASION_CANCEL then
		if GC_STICKS.LEVEL_MINIMUM < Game_GetStickLevel() or GetLocomotionState() == PLAYER_STATE_MOVE then
			GV_Cancel.RollReady = TRUE
		else
			GV_Cancel.BackstepReady = TRUE
		end
	elseif Action == GC_ACTIONS.JUMP_CANCEL then
		GV_Cancel.JumpReady = TRUE
	end
end

function Cancel_ResetQueue()
	GV_Cancel.RollReady = FALSE
	GV_Cancel.BackstepReady = FALSE
	GV_Cancel.JumpReady = FALSE
end

function Cancel_Execute(Action, IsDefault)
	if Cancel_IsCooldown() == TRUE then
		if Cancel_IsQueueReady() == TRUE then
			Cancel_QueueActions(Action)
		end

		return
	end

	if Action_IsSpecial() == TRUE then
		if IsDefault == FALSE then
			return
		end
	end

	if Stat_UseSP(DMN_ActionCancel_CostSP) == FALSE then
		return
	end

	Cancel_ResetQueue()

	if Action == GC_ACTIONS.GUARD_CANCEL then
		Action_Guard()
		return
	elseif Action == GC_ACTIONS.EVASION_CANCEL then
		ExecEventHalfBlend(Event_Move, ALLBODY)
		if GC_STICKS.LEVEL_MINIMUM < Game_GetStickLevel() or GetLocomotionState() == PLAYER_STATE_MOVE or Action_IsCasting() == TRUE then
			if env(GetSpEffectID, 102360) == FALSE then
				AddStamina(STAMINA_REDUCE_ROLLING)
			end

			Timer_AddAction(Effect_GetDurationInstant(), Effect_GetDurationInstant(), nil, nil, Action_Roll, nil)
			Cancel_AddCooldown(GV_Cancel.RollCooldown)
		else
			if env(GetSpEffectID, 102360) == FALSE then
				AddStamina(STAMINA_REDUCE_BACKSTEP)
			end

			Timer_AddAction(Effect_GetDurationInstant(), Effect_GetDurationInstant(), nil, nil, Action_Backstep, nil)
			Cancel_AddCooldown(GV_Cancel.StepCooldown)
		end
	elseif Action == GC_ACTIONS.JUMP_CANCEL then
		if Action_IsJumping() == TRUE and Game_IsRiding() == FALSE then
			ExecEventHalfBlend(Event_Move, ALLBODY)
		end

		if env(GetSpEffectID, 102360) == FALSE then
			AddStamina(STAMINA_REDUCE_JUMP)
		end

		if Game_IsRiding() == TRUE then
			Timer_AddAction(Effect_GetDurationInstant(), Effect_GetDurationInstant(), nil, nil, Action_JumpRiding, nil)
		else
			Timer_AddAction(Effect_GetDurationInstant(), Effect_GetDurationInstant(), nil, nil, Action_Jump, nil)
		end

		if DMN_JumpCancel_Mode == GC_MODES.JUMP_CANCEL_OVERRIDE then
			Cancel_AddCooldown(GV_Cancel.JumpNormalCooldown)
		elseif DMN_JumpCancel_Mode == GC_MODES.JUMP_CANCEL_DOUBLE then
			Cancel_AddCooldown(GV_Cancel.JumpDoubleCooldown)
		else
			Cancel_AddCooldown(GV_Cancel.JumpInfiniteCooldown)
		end

		if DMN_JumpCancel_Mode == GC_MODES.JUMP_CANCEL_DOUBLE then
			Cancel_IncreaseJumpCount()
		end
	end

	if Game_IsRiding() == FALSE then
		Effect_AddByID(GC_SPEIDS.INVISIBLE_SHORT)
		if DMN_ActionCancel_VFX == GC_MODES.ACTION_CANCEL_VFX_ENABLE then
			Effect_AddByID(GC_VFXIDS.SPOT_MIST_DARK_GROUND)
		end
	end
end

function Cancel_AdjustFrames()
	GV_Cancel.RollCooldown = System_AdjustFrames(GV_Cancel.TargetRollCooldown)
	GV_Cancel.StepCooldown = System_AdjustFrames(GV_Cancel.TargetStepCooldown)
	GV_Cancel.QueueCooldown = System_AdjustFrames(GV_Cancel.TargetQueueCooldown)

	GV_Cancel.JumpNormalCooldown = System_AdjustFrames(GV_Cancel.TargetJumpNormalCooldown)
	GV_Cancel.JumpDoubleCooldown = System_AdjustFrames(GV_Cancel.TargetJumpDoubleCooldown)
	GV_Cancel.JumpInfiniteCooldown = System_AdjustFrames(GV_Cancel.TargetJumpInfiniteCooldown)
end


--------------------------------------------------------------------------------
-------------------------------- CUSTOM MOVESETS -------------------------------

function Combo_IsCooldown()
	return GV_Combo.Cooldown
end

function Combo_SetCooldown(IsCooldown)
	GV_Combo.Cooldown = IsCooldown
end

function Combo_AddCooldown()
	Combo_SetCooldown(TRUE)

	if DMN_ComboCooldown_Multiplier < 1.0 then
		DMN_ComboCooldown_Multiplier = 1.0
	end

	local Duration = GV_Combo.DurationCooldown * DMN_ComboCooldown_Multiplier
	GV_Combo.TimerID_Cooldown = Timer_AddActionOrRefresh(GV_Combo.TimerID_Cooldown, Duration, Effect_GetDurationInstant(), Combo_SetCooldown, TRUE, Combo_SetCooldown, FALSE)
end

function Combo_EndCooldown()
	Timer_EndAction(GV_Combo.TimerID_Cooldown)
end

function Combo_IsDelay()
	return GV_Combo.Delay
end

function Combo_SetDelay(IsDelay)
	GV_Combo.Delay = IsDelay
end

function Combo_AddDelay()
	Combo_SetDelay(TRUE)
	GV_Combo.TimerID_Delay = Timer_AddActionOrRefresh(GV_Combo.TimerID_Delay, GV_Combo.DurationDelay, Effect_GetDurationInstant(), Combo_SetTimeout, TRUE, Combo_SetDelay, FALSE)
end

function Combo_EndDelay()
	Timer_EndAction(GV_Combo.TimerID_Delay)
end

function Combo_IsGuardStance()
	return GV_Combo.GuardStanceStatus
end

function Combo_SetGuardStance(IsGuardStance)
	GV_Combo.GuardStanceStatus = IsGuardStance
end

function Combo_GetGuardStanceAttack()
	return GV_Combo.GuardStanceAttack
end

function Combo_SetGuardStanceAttack(Attack)
	GV_Combo.GuardStanceAttack = Attack
end

function Combo_ExecuteGuardStanceAttack()
	local VFX_Level = DMN_DeflectVFX_Level
	if VFX_Level < 1 then
		VFX_Level = 1
	elseif 3 < VFX_Level then
		VFX_Level = 3
	end

	if VFX_Level <= 1 then
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
	elseif VFX_Level <= 2 then
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
	else
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_RED)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
		Effect_AddByID(GC_VFXIDS.PARTICLE_SPARK_ORANGE)
	end

	GV_Combo.ComboIndex = 1
	GV_Combo.ComboActions = {Combo_GetGuardStanceAttack()}
	ExecAttack(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, FALSE, ALLBODY, FALSE, FALSE, FALSE)
end

----------------------------------------
function Combo_IsOverrideAttack()
	if DMN_CustomMovesets_Mode == GC_MODES.MOVESETS_CUSTOM then
		return TRUE
	end

	return FALSE
end

function Combo_IsOverrideRequest(Request)
	if Request == ATTACK_REQUEST_INVALID or Request == ATTACK_REQUEST_RIGHT_LIGHT or Request == ATTACK_REQUEST_RIGHT_HEAVY or Request == ATTACK_REQUEST_BOTH_LIGHT or Request == ATTACK_REQUEST_BOTH_HEAVY then
		return TRUE
	end

	return FALSE
end

function Combo_GetComboTable()
	return GV_Combo.ComboTable
end

function Combo_SwitchComboTable(Table)
	GV_Combo.ComboTable = Table
	GV_Combo.ComboActions = {GV_Combo.ComboActions[#GV_Combo.ComboActions]}
	GV_Combo.ComboIndex = 1
end

function Combo_GetComboActions()
	return GV_Combo.ComboActions
end

function Combo_GetLastComboAction()
	return GV_Combo.ComboActions[Combo_GetComboIndex()]
end

function Combo_QueueComboAction()
	if Request_IsPressed(GC_BUTTONS.R1) == TRUE then
		GV_Combo.ComboActions[Combo_GetComboIndex()] = R1
	elseif Request_IsPressed(GC_BUTTONS.R2) == TRUE then
		GV_Combo.ComboActions[Combo_GetComboIndex()] = R2
	end
end

function Combo_ResetComboActions()
	GV_Combo.ComboTable = {}
	GV_Combo.ComboActions = {}
	GV_Combo.ComboIndex = 1
end

function Combo_ShiftComboActions()
	GV_Combo.ComboIndex = 1
	GV_Combo.ComboActions = {GV_Combo.ComboActions[#GV_Combo.ComboActions]}
end

function Combo_GetComboIndex()
	return GV_Combo.ComboIndex
end

function Combo_IncreaseComboIndex()
	GV_Combo.ComboIndex = GV_Combo.ComboIndex + 1
end

function Combo_GetMovesetsIndex()
	return GV_Combo.MovesetsIndex
end

function Combo_SwitchToNextMovesets()
	GV_Combo.MovesetsIndex = GV_Combo.MovesetsIndex + 1
end

function Combo_SwitchToPreviousMovesets()
	GV_Combo.MovesetsIndex = GV_Combo.MovesetsIndex - 1
end

function Combo_GetWieldingTable()
	local Hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		Hand = HAND_LEFT
	end

	local WP = env(GetEquipWeaponCategory, Hand)
	local WeaponTable = DMN_CustomMovesets_Table[WP]
	if WeaponTable == nil then
		return nil
	elseif #WeaponTable == 0 then
		return {}
	end

	if GV_Combo.MovesetsIndex < 1 then
		GV_Combo.MovesetsIndex = #WeaponTable
	elseif #WeaponTable < Combo_GetMovesetsIndex() then
		GV_Combo.MovesetsIndex = 1
	end

	local WieldingTable = WeaponTable[Combo_GetMovesetsIndex()].ONE_HAND
	if c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH then
		WieldingTable = WeaponTable[Combo_GetMovesetsIndex()].TWO_HAND
	elseif c_Style == HAND_RIGHT then
		if Game_IsDualWielding() == TRUE then
			WieldingTable = WeaponTable[Combo_GetMovesetsIndex()].DUAL_WIELD
		end
	end

	if WieldingTable == nil then
		WieldingTable = {}
	end

	return WieldingTable
end

function Combo_FindNextAttack(ComboTable)
	local AttackIndex = 0
	local CurrentActions = Combo_GetComboActions()
	for i = 1, #ComboTable, 2 do
		local ComboActions = ComboTable[i]
		local ComboAttacks = ComboTable[i + 1]
		if ComboActions == nil or ComboAttacks == nil or #ComboActions ~= #ComboAttacks then
			AttackIndex = 0
			break
		end

		for Index = 1, #CurrentActions, 1 do
			if CurrentActions[Index] == ComboActions[Index] then
				AttackIndex = Index
			else
				AttackIndex = 0
				break
			end
		end

		if 1 <= AttackIndex then
			return ComboAttacks[AttackIndex]
		end
	end

	return nil
end

function Combo_FindAttackInComboTable(r1, r2, b1, b2)
	local WieldingTable = Combo_GetWieldingTable()
	if WieldingTable == nil then
		return nil
	end

	local ComboTable = nil
	if r1 == RIGHT_DASH1 or r2 == RIGHT_DASH2 or b1 == BOTH_DASH1 or b2 == BOTH_DASH2 then
		ComboTable = WieldingTable.DASH_COMBO
	elseif r1 == RIGHT_ROLL or b1 == BOTH_ROLL then
		ComboTable = WieldingTable.ROLL_COMBO
	elseif r1 == RIGHT_STEP or b1 == BOTH_STEP then
		ComboTable = WieldingTable.BACKSTEP_COMBO
	elseif r1 == RIGHT_STEALTH or b1 == BOTH_STEALTH then
		ComboTable = WieldingTable.STEALTH_COMBO
	elseif Combo_IsGuardStance() == TRUE then
		Combo_SetGuardStance(FALSE)
		Action_SetSpecialRequest(TRUE)
		ComboTable = WieldingTable.GUARD_STANCE
		if GV_Combo.Custom == GC_MODES.MOVESETS_DEFAULT or ComboTable == nil or #ComboTable == 0 then
			ComboTable = GC_COMBO.GUARD_STANCE1
		end
	elseif Action_IsGuardCounterPossible() == TRUE then
		Action_EndGuardCounterStatus()
		ComboTable = WieldingTable.GUARD_COUNTER
		if ComboTable == nil or #ComboTable == 0 then
			if c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH then
				ComboTable = GC_COMBO.GUARD_COUNTER2
			else
				ComboTable = GC_COMBO.GUARD_COUNTER1
			end
		end
	else
		if 0 < #Combo_GetComboTable() then
			ComboTable = Combo_GetComboTable()
		else
			ComboTable = WieldingTable.NORMAL_COMBO
		end
	end

	if ComboTable == nil or #ComboTable == 0 then
		ComboTable = {}
	else
		if Combo_GetComboTable() ~= ComboTable then
			Combo_ShiftComboActions()
			Combo_SwitchComboTable(ComboTable)
		end
	end

	local AttackIndex = 0
	local CurrentActions = Combo_GetComboActions()
	local NextAttack = Combo_FindNextAttack(ComboTable)
	if NextAttack == nil and WieldingTable.NORMAL_COMBO ~= nil and (1 < #CurrentActions or Action_IsGuardCounterPossible() == TRUE) then
		Combo_ShiftComboActions()
		Combo_SwitchComboTable(WieldingTable.NORMAL_COMBO)
		NextAttack = Combo_FindNextAttack(WieldingTable.NORMAL_COMBO)
	end

	return NextAttack
end

function Combo_OverrideAttack(Request, r1, r2, b1, b2)
	if Action_IsCritical() == TRUE then
		return FALSE, nil, Request, r1, r2, b1, b2
	end

	if Combo_IsDelay() == FALSE then
		Combo_QueueComboAction()
	end

	if DMN_ComboCooldown_Multiplier <= 0 then
		if Request == ATTACK_REQUEST_INVALID and Action_IsAnimationCancel() == FALSE then
			return FALSE, nil, Request, r1, r2, b1, b2
		end
	end

	if Combo_IsCooldown() == TRUE or Combo_GetLastComboAction() == nil or (Cancel_IsCooldown() == TRUE and Action_IsAnimationCancel() == FALSE) then
		return FALSE, nil, ATTACK_REQUEST_INVALID, r1, r2, b1, b2
	end

	if Deflect_IsHeavy() == TRUE then
		Deflect_SetHeavy(FALSE)
		Combo_ResetComboActions()
		return FALSE, nil, ATTACK_REQUEST_INVALID, r1, r2, b1, b2
	end

	local NextAttack = nil
	if Request_IsButton(GC_BUTTONS.L1) == TRUE then
		if Request_IsPressed(GC_BUTTONS.R1) == TRUE and (DMN_GuardStance_Mode == GC_MODES.GUARDSTANCE_R1 or DMN_GuardStance_Mode == GC_MODES.GUARDSTANCE_ALL) then
			Combo_SetGuardStanceAttack(R1)
			NextAttack = "W_DMN_GuardStance1_Start"
		elseif Request_IsPressed(GC_BUTTONS.R2) == TRUE and (DMN_GuardStance_Mode == GC_MODES.GUARDSTANCE_R2 or DMN_GuardStance_Mode == GC_MODES.GUARDSTANCE_ALL) then
			Combo_SetGuardStanceAttack(R2)
			NextAttack = "W_DMN_GuardStance1_Start"
		end
	end

	if NextAttack == nil then
		NextAttack = Combo_FindAttackInComboTable(r1, r2, b1, b2)
	else
		Combo_SetGuardStance(TRUE)
		Action_SetSpecialRequest(TRUE)
	end

	if c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH then
		if Request_IsPressed(GC_BUTTONS.R1) == TRUE or Combo_GetLastComboAction() == R1 then
			Request = ATTACK_REQUEST_BOTH_LIGHT
			if NextAttack ~= nil then
				b1 = NextAttack
			end
		elseif Request_IsPressed(GC_BUTTONS.R2) == TRUE or Combo_GetLastComboAction() == R2 then
			Request = ATTACK_REQUEST_BOTH_HEAVY
			if NextAttack ~= nil then
				b2 = NextAttack
			else
				if Action_IsGuardCounterPossible() == TRUE then
					b2 = BOTH_COUNTER
				end
			end
		end
	else
		if Request_IsPressed(GC_BUTTONS.R1) == TRUE or Combo_GetLastComboAction() == R1 then
			Request = ATTACK_REQUEST_RIGHT_LIGHT
			if NextAttack ~= nil then
				r1 = NextAttack
			end
		elseif Request_IsPressed(GC_BUTTONS.R2) == TRUE or Combo_GetLastComboAction() == R2 then
			Request = ATTACK_REQUEST_RIGHT_HEAVY
			if NextAttack ~= nil then
				r2 = NextAttack
			else
				if Action_IsGuardCounterPossible() == TRUE then
					r2 = RIGHT_COUNTER
				end
			end
		end
	end

	if NextAttack ~= nil then
		Combo_IncreaseComboIndex()
	else
		Combo_ResetComboActions()
	end

	Combo_AddDelay()
	if 0 < DMN_ComboCooldown_Multiplier then
		Combo_AddCooldown()
	end

	return TRUE, NextAttack, Request, r1, r2, b1, b2
end

function Combo_AdjustFrames()
	GV_Combo.DurationCooldown = System_AdjustFrames(GV_Combo.TargetDurationCooldown)
	GV_Combo.DurationDelay = System_AdjustFrames(GV_Combo.TargetDurationDelay)
end


--------------------------------------------------------------------------------
--------------------------------- SPECIAL ARTS ---------------------------------

function Special_DeflectRepel()
	if 0 < DMN_ActionCancel_CostSP then
		Stat_IncreaseSP(DMN_ActionCancel_CostSP)
	end

	Deflect_Restore()

	local DamageBonus = DMN_DeflectDamage_Bonus
	local PowerBonus = DMN_DeflectPower_Bonus

	if DamageBonus < 0 or Deflect_IsPerfect() == FALSE then
		DamageBonus = 0
	end

	if PowerBonus < 0 or Deflect_IsPerfect() == FALSE then
		PowerBonus = 0
	end

	local DamageLevel = DMN_DeflectDamage_Level + DamageBonus
	local PowerLevel = DMN_DeflectPower_Level + PowerBonus
	if DMN_DeflectCounter_Mode == GC_MODES.DEFLECT_COUNTER_SAME then
		--
	elseif DMN_DeflectCounter_Mode == GC_MODES.DEFLECT_COUNTER_VARY then
		if 0 < DamageLevel then
			DamageLevel = DamageLevel + math.floor((DMN_AccumulateAttack_Level / Deflect_GetCounterMaxLevel()) * Deflect_GetCounterLevel())
		end

		if 0 < PowerLevel then
			PowerLevel = PowerLevel + math.floor((DMN_AccumulatePower_Level / Deflect_GetCounterMaxLevel()) * Deflect_GetCounterLevel())
		end
	elseif DMN_DeflectCounter_Mode == GC_MODES.DEFLECT_COUNTER_STACK then
		local Stack = Accumulate_GetStack()
		if DMN_AccumulateDeflect_Number < Stack then
			Stack = DMN_AccumulateDeflect_Number
		end

		if 0 < DamageLevel and 0 < DMN_AccumulateDeflect_Number then
			DamageLevel = DamageLevel + math.floor((DMN_AccumulateAttack_Level / DMN_AccumulateDeflect_Number) * Stack)
		end

		if 0 < PowerLevel and 0 < DMN_AccumulateDeflect_Number then
			PowerLevel = PowerLevel + math.floor((DMN_AccumulateAttack_Level / DMN_AccumulateDeflect_Number) * Stack)
		end
	else
		DamageLevel = 0
		PowerLevel = 0
	end

	if 0 < DamageLevel and 0 < PowerLevel then
		Effect_AddByLevel(GC_SPEIDS.BOOST_ATTACK, DamageLevel)
		Effect_AddByLevel(GC_SPEIDS.BOOST_POWER, PowerLevel)
		if DMN_DeflectEffect_Mode == GC_MODES.DEFLECT_EFFECT_ALL then
			Effect_AddByID(GC_ARTIDS.DEFLECT_REPEL_ALL)
		else
			Effect_AddByID(GC_ARTIDS.DEFLECT_REPEL_ALL_SINGLE)
		end
	elseif 0 < DamageLevel then
		Effect_AddByLevel(GC_SPEIDS.BOOST_ATTACK, DamageLevel)
		if DMN_DeflectEffect_Mode == GC_MODES.DEFLECT_EFFECT_ALL then
			Effect_AddByID(GC_ARTIDS.DEFLECT_REPEL_ATTACK)
		else
			Effect_AddByID(GC_ARTIDS.DEFLECT_REPEL_ATTACK_SINGLE)
		end
	elseif 0 < PowerLevel then
		Effect_AddByLevel(GC_SPEIDS.BOOST_POWER, PowerLevel)
		if DMN_DeflectEffect_Mode == GC_MODES.DEFLECT_EFFECT_ALL then
			Effect_AddByID(GC_ARTIDS.DEFLECT_REPEL_POWER)
		else
			Effect_AddByID(GC_ARTIDS.DEFLECT_REPEL_POWER_SINGLE)
		end
	end
end

function Special_DeflectConfuse()
	local Chance = math.random(1, 100)
	if DMN_EnemyConfusion_Chance < Chance or Deflect_IsPerfect() == FALSE then
		return
	end

	if DMN_EnemyConfusion_Time == GC_MODES.ENEMY_CONFUSE_SHORT then
		Effect_AddByID(GC_ARTIDS.ENEMY_CONFUSE_SHORT)
	elseif DMN_EnemyConfusion_Time == GC_MODES.ENEMY_CONFUSE_MEDIUM then
		Effect_AddByID(GC_ARTIDS.ENEMY_CONFUSE_MEDIUM)
	elseif DMN_EnemyConfusion_Time == GC_MODES.ENEMY_CONFUSE_LONG then
		Effect_AddByID(GC_ARTIDS.ENEMY_CONFUSE_LONG)
	end
end

function Special_DeflectRecovery()
	if Deflect_IsPerfect() == FALSE then
		return
	end

	if DMN_EnemyRecoveryCooldown_Time == GC_MODES.ENEMY_RECOVERY_SHORT then
		Effect_AddByID(GC_ARTIDS.ENEMY_RECOVERY_SHORT)
	elseif DMN_EnemyRecoveryCooldown_Time == GC_MODES.ENEMY_RECOVERY_MEDIUM then
		Effect_AddByID(GC_ARTIDS.ENEMY_RECOVERY_MEDIUM)
	elseif DMN_EnemyRecoveryCooldown_Time == GC_MODES.ENEMY_RECOVERY_LONG then
		Effect_AddByID(GC_ARTIDS.ENEMY_RECOVERY_LONG)
	end
end


--------------------------------------------------------------------------------
------------------------------ MOVEMENT & ACTIONS ------------------------------

function Movement_IsSprinting()
	return GV_Movement.Sprinting
end

function Movement_SetSprinting(IsSprinting)
	GV_Movement.Sprinting = IsSprinting
end

function Movement_GetMultiplier()
	return GV_Movement.Multiplier
end

function Movement_AdjustMultiplier(Level)
	if 1 <= Level and Level <= Effect_GetMaxLevel() then
		act(SetMovementScaleMult, 1.0 + Movement_GetMultiplier() * Level)
	end
end

function Movement_AdjustSprinting()
	local StickLevel = Game_GetStickLevel()
	if DMN_Sprinting_Mode == GC_MODES.SPRINTING_KEEP then
		if GC_STICKS.LEVEL_EXLARGE < StickLevel then
			Movement_SetSprinting(TRUE)
		elseif StickLevel < GC_STICKS.LEVEL_MINIMUM then
			Movement_SetSprinting(FALSE)
		end

		if GC_STICKS.LEVEL_LARGE < StickLevel then
			if Movement_IsSprinting() == FALSE then
				StickLevel = GC_STICKS.LEVEL_LARGE
			end
		end
	elseif DMN_Sprinting_Mode == GC_MODES.SPRINTING_LOCK then
		if GC_STICKS.LEVEL_LARGE < StickLevel and StickLevel < GC_STICKS.LEVEL_EXLARGE then
			if Game_IsLockon() == TRUE then
				StickLevel = GC_STICKS.LEVEL_LARGE
			end
		end
	elseif DMN_Sprinting_Mode == GC_MODES.SPRINTING_FREE then
		--
	else
		return FALSE
	end

	if GC_STICKS.LEVEL_LARGE < StickLevel then
		if env(GetSpEffectID, 100020) == TRUE then
			ChangeMoveSpeedIndex(1)
			SetVariable("ToggleDash", 0)
		else
			act(LockonFixedAngleCancel)
			ChangeMoveSpeedIndex(2)
		end
	elseif GC_STICKS.LEVEL_SMALL < StickLevel then
		ChangeMoveSpeedIndex(1)
		if env(GetSpEffectID, 100002) == FALSE and (2 <= GetVariable("IsEnableToggleDashTest") or env(GetSpEffectID, 100301) == FALSE) then
			SetVariable("ToggleDash", 0)
		end
	else
		ChangeMoveSpeedIndex(0)
		if env(GetSpEffectID, 100002) == FALSE and (2 <= GetVariable("IsEnableToggleDashTest") or env(GetSpEffectID, 100301) == FALSE) then
			SetVariable("ToggleDash", 0)
		end
	end

	if env(GetSpEffectID, 100002) == TRUE then
		act(SetStaminaRecoveryDisabled)
	end

	return TRUE
end


--------------------------------------------------------------------------------
------------------------------------ PLAYER ------------------------------------

function Player_IsRevivePossible()
	if 0 < DMN_AutoRevive_Number then
		return TRUE
	end

	return FALSE
end

function Player_Revive()
	DMN_AutoRevive_Number = DMN_AutoRevive_Number - 1
	Effect_AddByID(GC_VFXIDS.FIELD_GOLDEN_SPARK)

	Stat_IncreaseHP(10000)
	ExecEventAllBody("W_Stealth_to_Idle")
end

function Player_AutoRevive()
	Stat_IncreaseHP(1)
	Effect_AddByID(GC_ARTIDS.ENEMY_CLEAR_TARGET)
	Timer_AddAction(System_SecondsToFrames(4.5), System_SecondsToFrames(4.5), nil, nil, Player_Revive, nil)
end


--------------------------------------------------------------------------------
----------------------------------- GAMEPLAY -----------------------------------

function Gameplay_UpdateEffects()
	Gameplay_StringMaster_Update()
end

----------------------------------------
function Gameplay_GuardStance_Update()
	if GV_Combo.Custom == GC_MODES.MOVESETS_DEFAULT then
		if Request_IsButton(GC_BUTTONS.L1) == TRUE then
			if Request_IsPressed(GC_BUTTONS.R1) == TRUE and (DMN_GuardStance_Mode == GC_MODES.GUARDSTANCE_R1 or DMN_GuardStance_Mode == GC_MODES.GUARDSTANCE_ALL) then
				DMN_CustomMovesets_Mode = GC_MODES.MOVESETS_CUSTOM
			elseif Request_IsPressed(GC_BUTTONS.R2) == TRUE and (DMN_GuardStance_Mode == GC_MODES.GUARDSTANCE_R2 or DMN_GuardStance_Mode == GC_MODES.GUARDSTANCE_ALL) then
				DMN_CustomMovesets_Mode = GC_MODES.MOVESETS_CUSTOM
			end
		else
			DMN_CustomMovesets_Mode = GC_MODES.MOVESETS_DEFAULT
		end
	end
end

function Gameplay_GuardStance_SetPerfect(IsPerfect)
	GV_GuardStance.Perfect = IsPerfect
end

function Gameplay_GuardStance_IsPerfect()
	return GV_GuardStance.Perfect
end

----------------------------------------
function Gameplay_StringMaster_Update()
	if DMN_StringMaster_Mode == GC_MODES.STRING_MASTER_ENABLE then
		if GV_Gameplay.StringMaster_Flag1 + 3 <= g_FrameCount then
			if Effect_IsActive(GC_SPEIDS.STRING_MASTER_WIRE_LEFT) == TRUE then
				if GV_Gameplay.StringMaster_Stacks < DMN_StringMaster_MaxStacks then
					Effect_AddByID(GC_VFXIDS.STRING_MASTER_WIRE_LEFT)
				else
					Effect_AddByID(GC_VFXIDS.STRING_MASTER_WIRE_CRIMSON_LEFT)
				end
			elseif Effect_IsActive(GC_SPEIDS.STRING_MASTER_WIRE_RIGHT) == TRUE then
				if GV_Gameplay.StringMaster_Stacks < DMN_StringMaster_MaxStacks then
					Effect_AddByID(GC_VFXIDS.STRING_MASTER_WIRE_RIGHT)
				else
					Effect_AddByID(GC_VFXIDS.STRING_MASTER_WIRE_CRIMSON_RIGHT)
				end
			else
				return
			end

			GV_Gameplay.StringMaster_Flag1 = g_FrameCount
			GV_Gameplay.StringMaster_Stacks = GV_Gameplay.StringMaster_Stacks + 1

			GV_Gameplay.TimerID_StringMaster_Timeout = Timer_AddActionOrRefresh(GV_Gameplay.TimerID_StringMaster_Timeout, System_SecondsToFrames(DMN_StringMaster_Timeout), Effect_GetDurationLong(), nil, nil, Gameplay_StringMaster_Reset, nil)
		end
	end
end

function Gameplay_StringMaster_Reset()
	GV_Gameplay.StringMaster_Flag1 = 0
	GV_Gameplay.StringMaster_Stacks = 0
end

----------------------------------------
function Gameplay_AirRetreat_Update()
	if DMN_StringMaster_AirRetreat == GC_MODES.AIR_RETREAT_ENABLE then
		if Request_IsPressed(GC_BUTTONS.A) == TRUE then
			GV_Gameplay.AirRetreat_Ready = TRUE
		end

		if Action_IsAnimationCancel() == TRUE and Gameplay_AirRetreat_IsReady() == TRUE then
			ExecEventAllBody("W_DMN_LadyButterfly_Jump2")
			GV_Gameplay.AirRetreat_Ready = FALSE

			return TRUE
		end
	end

	return FALSE
end

function Gameplay_AirRetreat_IsReady()
	return GV_Gameplay.AirRetreat_Ready
end


--------------------------------------------------------------------------------
-------------------------------------- AI --------------------------------------

function AI_IsEnemyAlert()
	if DMN_EnemyAlert_Mode == GC_MODES.AI_ENEMY_ALERT_SMALL or DMN_EnemyAlert_Mode == GC_MODES.AI_ENEMY_ALERT_LARGE or DMN_EnemyAlert_Mode == GC_MODES.AI_ENEMY_ALERT_EXLARGE then
		return TRUE
	end

	return FALSE
end

function AI_TriggerEnemyAlert()
	if DMN_EnemyAlert_Mode == GC_MODES.AI_ENEMY_ALERT_SMALL then
		if Effect_IsActive(GC_SPEIDS.ENEMY_ALERT_SMALL) == FALSE then
			Effect_AddByID(GC_SPEIDS.ENEMY_ALERT_SMALL)
		end
	elseif DMN_EnemyAlert_Mode == GC_MODES.AI_ENEMY_ALERT_LARGE then
		if Effect_IsActive(GC_SPEIDS.ENEMY_ALERT_LARGE) == FALSE then
			Effect_AddByID(GC_SPEIDS.ENEMY_ALERT_LARGE)
		end
	elseif DMN_EnemyAlert_Mode == GC_MODES.AI_ENEMY_ALERT_EXLARGE then
		if Effect_IsActive(GC_SPEIDS.ENEMY_ALERT_EXLARGE) == FALSE then
			Effect_AddByID(GC_SPEIDS.ENEMY_ALERT_EXLARGE)
		end
	end
end


--------------------------------------------------------------------------------
------------------------------------ EVENTS ------------------------------------

function DMN_LadyButterfly_Dash_Forward_onUpdate()
	Action_EvasionAction_onUpdate()
end

function DMN_LadyButterfly_Dash_Forward_Air_onUpdate()
	Action_EvasionAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_Dash_Backward_onUpdate()
	Action_BackstepAction_onUpdate()
end

function DMN_LadyButterfly_Dash_Backward_Air_onUpdate()
	Action_BackstepAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_Dash_Left_onUpdate()
	Action_EvasionAction_onUpdate()
end

function DMN_LadyButterfly_Dash_Left_Air_onUpdate()
	Action_EvasionAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_Dash_Right_onUpdate()
	Action_EvasionAction_onUpdate()
end

function DMN_LadyButterfly_Dash_Right_Air_onUpdate()
	Action_EvasionAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_Idle_onUpdate()
	Action_IdleAction_onUpdate("W_DMN_LadyButterfly_Idle_Ground")
end

function DMN_LadyButterfly_Idle_Air_onUpdate()
	Action_IdleAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_Jump1_onUpdate()
	Action_AttackAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_Jump2_onUpdate()
	Action_AttackAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_DeflectS_Left1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_DeflectS_Left2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_DeflectS_Left3_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_DeflectS_Right1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_DeflectS_Right2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_DeflectM_Left1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_DeflectM_Right1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_DeflectH_Left1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_DeflectH_Right1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_DeflectP_Left1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack3_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack4_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack5_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack6_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack7_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack8_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack9_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack10_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack11_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack12_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack13_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Attack14_onUpdate()
	Action_AttackAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_Combo1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Combo2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Combo3_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Combo4_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Combo5_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Combo6_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Combo7_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Combo8_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Kunai1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Kunai2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Kunai3_onUpdate()
	Action_AttackAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_Special1_onUpdate()
	if Effect_IsActive(GC_SPEIDS.STRING_MASTER_STATUS_AIR) == TRUE then
		ExecEventAllBody("W_DMN_LadyButterfly_Special1_Air")
		return
	end

	GV_Gameplay.StringMaster_Stacks = 0
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Special1_Empty_onUpdate()
	if Effect_IsActive(GC_SPEIDS.STRING_MASTER_STATUS_AIR) == TRUE then
		ExecEventAllBody("W_DMN_LadyButterfly_Special1_Air_Empty")
		return
	end

	if DMN_StringMaster_MaxStacks <= GV_Gameplay.StringMaster_Stacks then
		ExecEventAllBody("W_DMN_LadyButterfly_Special1")
		return
	end

	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Special1_Air_onUpdate()
	if Effect_IsActive(GC_SPEIDS.STRING_MASTER_STATUS_AIR) == FALSE then
		ExecEventAllBody("W_DMN_LadyButterfly_Special1")
		return
	end

	GV_Gameplay.StringMaster_Stacks = 0
	Action_AttackAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_Special1_Air_Empty_onUpdate()
	if Effect_IsActive(GC_SPEIDS.STRING_MASTER_STATUS_AIR) == FALSE then
		ExecEventAllBody("W_DMN_LadyButterfly_Special1_Empty")
		return
	end

	if DMN_StringMaster_MaxStacks <= GV_Gameplay.StringMaster_Stacks then
		ExecEventAllBody("W_DMN_LadyButterfly_Special1_Air")
		return
	end

	Action_AttackAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_Special2_onUpdate()
	if Effect_IsActive(GC_SPEIDS.STRING_MASTER_STATUS_AIR) == TRUE then
		ExecEventAllBody("W_DMN_LadyButterfly_Special2_Air")
		return
	end

	GV_Gameplay.StringMaster_Stacks = 0
	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Special2_Empty_onUpdate()
	if Effect_IsActive(GC_SPEIDS.STRING_MASTER_STATUS_AIR) == TRUE then
		ExecEventAllBody("W_DMN_LadyButterfly_Special2_Air_Empty")
		return
	end

	if DMN_StringMaster_MaxStacks <= GV_Gameplay.StringMaster_Stacks then
		ExecEventAllBody("W_DMN_LadyButterfly_Special2")
		return
	end

	Action_AttackAction_onUpdate()
end

function DMN_LadyButterfly_Special2_Air_onUpdate()
	if Effect_IsActive(GC_SPEIDS.STRING_MASTER_STATUS_AIR) == FALSE then
		ExecEventAllBody("W_DMN_LadyButterfly_Special2")
		return
	end

	GV_Gameplay.StringMaster_Stacks = 0
	Action_AttackAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

function DMN_LadyButterfly_Special2_Air_Empty_onUpdate()
	if Effect_IsActive(GC_SPEIDS.STRING_MASTER_STATUS_AIR) == FALSE then
		ExecEventAllBody("W_DMN_LadyButterfly_Special2")
		return
	end

	if DMN_StringMaster_MaxStacks <= GV_Gameplay.StringMaster_Stacks then
		ExecEventAllBody("W_DMN_LadyButterfly_Special2_Air")
		return
	end

	Action_AttackAction_onUpdate("W_DMN_LadyButterfly_Idle_Air")
end

----------------------------------------
function DMN_UnlimitedBladeWorks1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_ExplosionSphere1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_ShatteringArrow1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_PiercingArrow1_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_DeflectS_Up1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DeflectS_Left1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DeflectS_Right1_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_DeflectM_Left1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DeflectM_Left2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DeflectM_Right1_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_DeflectH_Left1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DeflectH_Left2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DeflectH_Right1_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_DeflectH_Back1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DeflectH_Back2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DeflectH_Back3_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_DeflectP_Up1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DeflectP_Left1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DeflectP_Right1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DeflectP_Right2_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_BlockS_Up1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_BlockS_Left1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_BlockS_Left2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_BlockS_Left3_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_BlockS_Right1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_BlockS_Right2_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_BlockM_Up1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_BlockM_Up2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_BlockM_Left1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_BlockM_Left2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_BlockM_Right1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_BlockM_Right2_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_BlockH_Back1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_BlockH_Back2_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_GuardStance1_Start_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
		act(DisallowAdditiveTurning, TRUE)
	else
		act(DisallowAdditiveTurning, FALSE)
	end

	if GuardCommonFunction(FALSE, blend_type, FALSE) == TRUE then
		return
	end

	if HalfBlendLowerCommonFunction(Event_GuardStart, lower_state, FALSE) == TRUE then
		return
	end

	if Request_IsReleased(GC_BUTTONS.L1) == TRUE or Stat_GetSP() <= 0 then
		ExecEvent("W_DMN_GuardStance1_End")
		return
	end

	if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		ExecEvent("W_DMN_GuardStance1_Idle")
		return
	end
end

function DMN_GuardStance1_Idle_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
		act(DisallowAdditiveTurning, TRUE)
	else
		act(DisallowAdditiveTurning, FALSE)
	end

	if GuardCommonFunction(FALSE, blend_type, FALSE) == TRUE then
		return
	end

	if HalfBlendLowerCommonFunction(Event_GuardOn, lower_state, FALSE) == TRUE then
		return
	end

	if Request_IsReleased(GC_BUTTONS.L1) == TRUE or Stat_GetSP() <= 0 then
		ExecEvent("W_DMN_GuardStance1_End")
		return
	end

	if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		ExecEvent("W_DMN_GuardStance1_Idle")
		return
	end
end

function DMN_GuardStance1_End_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
		act(DisallowAdditiveTurning, TRUE)
	else
		act(DisallowAdditiveTurning, FALSE)
	end

	Combo_SetGuardStance(FALSE)

	if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		ExecEvent("W_Idle")
		return
	end

	if GuardCommonFunction(TRUE, blend_type, FALSE) == TRUE then
		return
	end

	if lower_state == LOWER_MOVE and (env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE) then
		ExecEventHalfBlendNoReset(Event_MoveQuick, UPPER)
		return
	end

	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end

	if HalfBlendLowerCommonFunction(Event_GuardEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function DMN_GuardStance1_Normal_onUpdate()
	if Gameplay_GuardStance_IsPerfect() == TRUE then
		Gameplay_GuardStance_SetPerfect(FALSE)
		ExecEventAllBody(GC_COMBO.GUARD_STANCE2[2][1])
		return
	end

	Action_AttackAction_onUpdate()
end

function DMN_GuardStance1_Perfect_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_Dash1_Forward_onUpdate()
	Action_EvasionAction_onUpdate()
end

function DMN_Dash1_Backward_onUpdate()
	Action_BackstepAction_onUpdate()
end

function DMN_Dash1_Left_onUpdate()
	Action_EvasionAction_onUpdate()
end

function DMN_Dash1_Right_onUpdate()
	Action_EvasionAction_onUpdate()
end

function DMN_Dash2_Forward_onUpdate()
	Action_EvasionAction_onUpdate()
end

function DMN_Dash2_Backward_onUpdate()
	Action_BackstepAction_onUpdate()
end

function DMN_Dash2_Left_onUpdate()
	Action_EvasionAction_onUpdate()
end

function DMN_Dash2_Right_onUpdate()
	Action_EvasionAction_onUpdate()
end

----------------------------------------

function DMN_Sekiro1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Sekiro2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Sekiro3_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Sekiro4_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Sekiro5_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Sekiro6_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Sekiro7_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Sekiro8_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Sekiro9_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Sekiro10_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Sekiro11_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Sekiro12_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_LoadedShuriken1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoadedShuriken2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoadedShuriken3_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_WhirlwindSlash1_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_NightjarSlash1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_NightjarSlash2_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_Ichimonji1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Ichimonji2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Ichimonji3_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_DragonFlash1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_DragonFlash2_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_AshinaCross1_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_OneMind1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_OneMind2_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_FloatingPassage1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_FloatingPassage2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_FloatingPassage3_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_FloatingPassage4_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_FloatingPassage5_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_FloatingPassage6_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_SenpouLeapingKicks1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_SenpouLeapingKicks2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_SenpouLeapingKicks3_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_PrayingStrikes1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_PrayingStrikes2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_PrayingStrikes3_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_Shadowrush1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Shadowrush2_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_SakuraDance1_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_Genichiro1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro3_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro4_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro5_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro6_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro7_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro8_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro9_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro10_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro11_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro12_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro13_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro14_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro15_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro16_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro17_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro18_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro19_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro20_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro21_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro22_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_Genichiro_Bow1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro_Bow2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro_Bow3_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro_Bow4_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro_Bow5_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro_Bow6_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro_Bow7_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro_Bow8_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro_Bow9_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro_Bow10_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro_Bow11_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Genichiro_Bow12_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_GreatShinobiOwl1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl3_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl4_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl5_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl6_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl7_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl8_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl9_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl10_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl11_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl12_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl13_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl14_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl15_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl16_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl17_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl18_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_GreatShinobiOwl19_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_LoneShadow1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoneShadow2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoneShadow3_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoneShadow4_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoneShadow5_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoneShadow6_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoneShadow7_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoneShadow8_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoneShadow9_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoneShadow10_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_LoneShadow11_onUpdate()
	Action_AttackAction_onUpdate()
end

----------------------------------------
function DMN_Isshin1_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin2_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin3_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin4_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin5_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin6_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin7_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin8_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin9_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin10_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin11_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin12_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin13_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin14_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin15_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin16_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin17_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin18_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin19_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin20_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin21_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin22_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin23_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin24_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin25_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin26_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin27_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin28_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin29_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin30_onUpdate()
	Action_AttackAction_onUpdate()
end

function DMN_Isshin31_onUpdate()
	Action_AttackAction_onUpdate()
end


--############################################################################--
-- CUSTOM: End.


------------------------------------------
-- Fixed decompiled c0000.hks for ELDEN RING
-- Refined from decompiles by Vawser
-- Curated at: https://github.com/ividyon/EldenRingHKS
------------------------------------------
-- Version 16 (For ER HKS last updated in 1.15.1)
------------------------------------------
-- Changelog:
-- 2022-12-15 - AshenOne: ExecMagic (line 2090), moving an if block so left-hand casting works as intended
-- 2022-12-16 - ivi: Updated for 1.08.1
-- 2022-12-28 - Kirnifr: fixed Torrent dash
-- 2023-01-27 - Massive overhaul and improvements by Vawser from Vigil
--              Properly fixes Torrent dash as well as flick animation issues
--              proper act/env naming instead of IDs, proper spacing, useful comments
-- 2023-01-27 - Minor oversight fixes
-- 2023-01-27 - Put on GitHub via philiquaz' initiative
-- 2023-02-14 - Minor comment changes
-- 2023-03-19 - Support for custom Ashes of War
-- 2023-09-22 - Halvard: updated for 1.10
--              - fixed the function declaration of "ExecComboMagic", it was missing two parameters.
--              - removed an "act(SetAttackType, -1)" from the function "DamageBind_onUpdate()",
--                all act 109 were removed many patches ago, this one was overlooked when updating this file.
--              - Updated the function "DrawStanceRightLoop_Upper_onUpdate()" to match changes done in 1.09
--                that change the follow-up attacks done after the "spinning wheel" ash of war.
--              - Added a note in the "ExecJump()" function, as it is changed compared to the raw decompile
--                I'm not sure if this was intended by previous authors of this file or simply a mistake.
--                For now I'm only adding a note to highlight that it was changed and leaving it at that.
--              - manually read through the entire file to make sure no other changes done by
--                FromSoftware in previous patch updates were still missing.
-- 2024-06-28 - Exelot: Updated to ER v1.12.1 [DLC Initial Release]
--              - Recreated the entire HKS file from a fresh (raw) decompiled.
--                 This added all the new functions that were missing.
--                 It also fixed a bunch of logic that was incorrect due to the non-raw decompile.
--                 The reason for this is because of the attempt on a 1-on-1 update had a lot of issues with it.
--              - Fixed a error in ExecAttack where the 9 in arts_cat == 9 replaced with: 
--                 SWORD_ART_DIFF_CAT_LARGE_WEAPON_LARGE_SHIELD instead of 
--                 SWORD_ART_DIFF_CAT_POLEARM_LARGE_SHIELD.
--              - Reintroduced missing variables that were in use (blend time related).
--              - Recreation fixed the torrent bugs
-- 2024-06-29 - ivi: Fixed a bug with IsAttackSwordArts which prevented Ashes of War from working
-- 2024-07-17 - Exelot: 
--              - Fixed a bug with SetSwordArtsPointInfo causing various ashes to not having the right Ash of War
--                while not having enough stats.
--              - Added a missing check for jumping.
--              - Fixed a bug that would cause Ashes of War such as Carian Grandeur to not have the ability to be cast uncharged.
-- 2024-07-18 - ivi: Fixed SwordArtsDiffCategory & SwordArtsPutOppositeWeapon function changes not carried over from new common_define (Twinblade AotC: Wings)
-- 2024-07-23 - Exelot:
--              - Renamed env GetWeaponID into a less confusing name: GetSwordArtID
--              - Renamed act Test_SpEffectDelete into ClearSpEffect and added a comment for it's args.
--              - Added a new logic expansion section with a new function that allows for easy addition of new Weapon Catalysts.
-- 2024-07-30 - Exelot: Updated to ER v1.13
-- 2024-08-29 - ivi: Fixed SwordArtsCategory table missing variations of existing arts for new weapon types
-- 2024-09-11 - Exelot: Updated to ER v1.14
-- 2024-10-02 - ivi: Updated to ER v1.15
-- 2024-10-03 - Exelot: Named almost all remaining acts and envs thanks to a list provided by ElaDiDu. Some of the existing ones have been renamed.
------------------------------------------
-- Known issues:
-- N/A

------------------------------------------
-- Core: Functions
------------------------------------------
function ExecEvent(state)
	ResetRequest()
	hkbFireEvent(state)
end

function ExecEventSync(state)
	ResetRequest()
	act(PlayEventSync, state)
end

function ExecEventNoReset(state)
	hkbFireEvent(state)
end

function ExecEventSyncNoReset(state)
	act(PlayEventSync, state)
end

function ExecEvents(...)
	local buff = {...}

	for i = 1, #buff, 1 do
		ExecEvent(buff[i])
	end
end

function GetVariable(variable)
	return hkbGetVariable(variable)
end

function ExecEventHalfBlend(event_table, blend_type)
	if blend_type == ALLBODY then
		SetVariable("MoveSpeedLevelReal", 0)
		local lower_event = event_table[1]
		local upper_event = lower_event .. "_Upper"

		ExecEvents(lower_event, upper_event)

		for i = 2, #event_table, 1 do
			SetVariable("LowerDefaultState0" .. i - 2, event_table[i])
			SetVariable("UpperDefaultState0" .. i - 2, event_table[i])
		end
	elseif blend_type == LOWER then
		ExecEvent(event_table[1])

		for i = 2, #event_table, 1 do
			SetVariable("LowerDefaultState0" .. i - 2, event_table[i])
		end
	elseif blend_type == UPPER then
		ExecEvent(event_table[1] .. "_Upper")

		for i = 2, #event_table, 1 do
			SetVariable("UpperDefaultState0" .. i - 2, event_table[i])
		end
	end
end

function ExecEventHalfBlendNoReset(event_table, blend_type)
	if blend_type == ALLBODY then
		local lower_event = event_table[1]
		local upper_event = lower_event .. "_Upper"

		ExecEventNoReset(lower_event)
		ExecEventNoReset(upper_event)

		for i = 2, #event_table, 1 do
			SetVariable("LowerDefaultState0" .. i - 2, event_table[i])
			SetVariable("UpperDefaultState0" .. i - 2, event_table[i])
		end
	elseif blend_type == LOWER then
		ExecEventNoReset(event_table[1])

		for i = 2, #event_table, 1 do
			SetVariable("LowerDefaultState0" .. i - 2, event_table[i])
		end
	elseif blend_type == UPPER then
		ExecEventNoReset(event_table[1] .. "_Upper")

		for i = 2, #event_table, 1 do
			SetVariable("UpperDefaultState0" .. i - 2, event_table[i])
		end
	end
end

function ExecEventAllBody(event)
	SetVariable("MoveSpeedLevelReal", 0)
	ExecEvent(event)
end

function IsNodeActive(...)
	local buff = {...}

	for i = 1, #buff, 1 do
		if hkbIsNodeActive(buff[i]) then
			return TRUE
		end
	end
	return FALSE
end

function ResetEventState()
	SetVariable("MoveSpeedLevelReal", 0)
	ResetRequest()
end

function ResetMimicry()
	act(AddSpEffect, 503041)
end

function SetEnableMimicry()
	g_EnableMimicry = TRUE
end

function SetWeightIndex()
	local weight = math.mod(env(GetMoveAnimParamID), 20)

	if weight == WEIGHT_LIGHT then
		SetVariable("MoveWeightIndex", MOVE_WEIGHT_LIGHT)
		SetVariable("EvasionWeightIndex", EVASION_WEIGHT_INDEX_LIGHT)
	elseif weight == WEIGHT_NORMAL then
		SetVariable("MoveWeightIndex", MOVE_WEIGHT_NORMAL)
		SetVariable("EvasionWeightIndex", EVASION_WEIGHT_INDEX_MEDIUM)
	elseif weight == WEIGHT_HEAVY then
		SetVariable("MoveWeightIndex", MOVE_WEIGHT_HEAVY)
		SetVariable("EvasionWeightIndex", EVASION_WEIGHT_INDEX_HEAVY)
	elseif weight == WEIGHT_OVERWEIGHT then
		SetVariable("MoveWeightIndex", MOVE_WEIGHT_HEAVY)
		SetVariable("EvasionWeightIndex", EVASION_WEIGHT_INDEX_OVERWEIGHT)
	elseif weight == WEIGHT_SUPERLIGHT then
		SetVariable("MoveWeightIndex", MOVE_WEIGHT_SUPERLIGHT)
		SetVariable("EvasionWeightIndex", EVASION_WEIGHT_INDEX_SUPERLIGHT)
	else
		SetVariable("MoveWeightIndex", 0)
	end

	if env(GetSpEffectID, 503520) == TRUE and weight ~= WEIGHT_OVERWEIGHT then
		SetVariable("MoveWeightIndex", MOVE_WEIGHT_HEAVY)
		SetVariable("EvasionWeightIndex", EVASION_WEIGHT_INDEX_HEAVY)
	elseif env(GetSpEffectID, 5520) == TRUE and weight ~= WEIGHT_OVERWEIGHT then
		SetVariable("MoveWeightIndex", MOVE_WEIGHT_HEAVY)
		SetVariable("EvasionWeightIndex", EVASION_WEIGHT_INDEX_HEAVY)
	elseif env(GetSpEffectID, 425) == TRUE and weight ~= WEIGHT_OVERWEIGHT then
		SetVariable("MoveWeightIndex", MOVE_WEIGHT_HEAVY)
		SetVariable("EvasionWeightIndex", EVASION_WEIGHT_INDEX_HEAVY)
	elseif env(GetSpEffectID, 4101) == TRUE and weight ~= WEIGHT_OVERWEIGHT then
		SetVariable("MoveWeightIndex", MOVE_WEIGHT_HEAVY)
		SetVariable("EvasionWeightIndex", EVASION_WEIGHT_INDEX_HEAVY)
	elseif env(GetSpEffectID, 4100) == TRUE and weight ~= WEIGHT_OVERWEIGHT then
		SetVariable("MoveWeightIndex", MOVE_WEIGHT_HEAVY)
	elseif env(GetSpEffectID, 19670) == TRUE and weight ~= WEIGHT_OVERWEIGHT then
		SetVariable("MoveWeightIndex", MOVE_WEIGHT_HEAVY)
		SetVariable("EvasionWeightIndex", EVASION_WEIGHT_INDEX_HEAVY)
	end
end

function SetAIActionState()
	act(SetAIAttackState, env(GetNpcAIAttackRequestIDAfterBlend))
end

function SetAttackHand(hand)
	act(WeaponParameterReference, hand)
end

function SetGuardHand(hand)
	act(SetThrowPossibilityState_Attacker, hand)
end

function SetEnableAimMode()
	if env(ActionDuration, ACTION_ARM_ACTION) > 0 then
		return
	end

	local style = c_Style
	local isRide = env(IsOnMount)

	if isRide == TRUE then
		if style == HAND_LEFT_BOTH then
			if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_CROSSBOW)
				== TRUE then
				act(SetIsPreciseShootingPossible)
			end
		elseif GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_CROSSBOW)
			== TRUE then
			act(SetIsPreciseShootingPossible)
		end
	elseif style == HAND_LEFT_BOTH then
		if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_LARGE_ARROW,
			WEAPON_CATEGORY_CROSSBOW, WEAPON_CATEGORY_BALLISTA) == TRUE then
			act(SetIsPreciseShootingPossible)
		end
	elseif style == HAND_RIGHT_BOTH
		and GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_LARGE_ARROW,
			WEAPON_CATEGORY_CROSSBOW, WEAPON_CATEGORY_BALLISTA) == TRUE then
		act(SetIsPreciseShootingPossible)
	end
end

function Replanning()
	act(DoAIReplanningAtCancelTiming)
end

function AddStamina(num)
	act(SetStaminaRecoveryDisabled)
	act(ChangeStamina, num)
end

function GetLocomotionState()
	local state = GetVariable("LowerDefaultState00")

	if state == MOVE_DEF0 or state == STEALTHMOVE_DEF0 then
		if env(GetSpEffectID, 100000) == TRUE then
			return PLAYER_STATE_MOVE
		elseif env(GetSpEffectID, 100001) == TRUE then
			return PLAYER_STATE_MOVE
		elseif env(GetSpEffectID, 100002) == TRUE then
			return PLAYER_STATE_MOVE
		end
	end
	return PLAYER_STATE_IDLE
end

function SetInterruptType(num)
	act(AINotifyAttackType, num)
end

function SetTurnSpeed(turn_speed)
	act(SetTurnSpeed, turn_speed)
end

function SetRollingTurnCondition(is_selftrans)
	local rolling_angle = "RollingAngleReal"

	if is_selftrans == TRUE then
		rolling_angle = "RollingAngleRealSelftrans"
	end

	if GetVariable("IsLockon") == true then
		local angle = GetVariable("TurnAngleReal")
		if angle > 180 then
			SetTurnSpeed(0)
		elseif angle > 90 then
			SetTurnSpeed(360)
		end
	elseif env(IsPrecisionShoot) == TRUE then
		SetTurnSpeed(0)
		SetVariable("TurnAngleReal", 300)
	elseif math.abs(GetVariable(rolling_angle)) > 0.0010000000474974513 then
		SetTurnSpeed(0)
	elseif GetVariable("TurnAngleReal") > 200 then
		SetTurnSpeed(0)
	end
end

function IsLowerQuickTurn()
	if GetVariable("LowerDefaultState00") == QUICKTURN_DEF0 and env(GetSpEffectID, 100010) == TRUE then
		return TRUE
	end
	return FALSE
end

function IsLowerBackStep()
	if GetVariable("LowerDefaultState00") == BACKSTEP_DEF0 then
		return TRUE
	end
	return FALSE
end

function IsDualBladeSpecific(hand)
	if hand == HAND_LEFT then
		return env(IsTwinSwords, 0)
	else
		return env(IsTwinSwords, 1)
	end
end

function GetEquipType(hand, ...)
	local buff = {...}
	local kind = {}
	local num = 1

	if hand == HAND_BOTH then
		kind[1] = env(GetEquipWeaponCategory, HAND_LEFT)
		kind[2] = env(GetEquipWeaponCategory, HAND_RIGHT)
		num = 2
	else
		kind[1] = env(GetEquipWeaponCategory, hand)
	end

	for i = 1, num, 1 do
		for j = 1, #buff, 1 do
			if kind[i] == buff[j] then
				return TRUE
			end
		end
	end
	return FALSE
end

function GetEquipTypeHandStyle(arg)
	if c_Style == HAND_LEFT_BOTH then
		local kind = env(GetEquipWeaponCategory, HAND_LEFT)
		return kind
	else
		local kind = env(GetEquipWeaponCategory, HAND_RIGHT)
		return kind
	end
end

function IsHandStyleBoth(arg)
	if c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH then
		return TRUE
	end
	return FALSE
end

function SetVariable(name, value)
	act(SetHavokVariable, name, value)
end

function IsWeaponCanGuard()
	local style = c_Style
	local kind = 0
	local pos = 0
	if style == HAND_RIGHT then
		kind = env(GetEquipWeaponCategory, HAND_LEFT)
		pos = 2
	elseif style == HAND_LEFT_BOTH then
		kind = env(GetEquipWeaponCategory, HAND_LEFT)
		pos = 3
	else
		kind = env(GetEquipWeaponCategory, HAND_RIGHT)
		pos = 3
	end

	for i = 1, #WeaponCategoryID, 1 do
		if WeaponCategoryID[i][1] == kind then
			local canguard = WeaponCategoryID[i][pos]
			return canguard
		end
	end
end

function IsEnableGuard()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if Action_IsGuardPossible() == TRUE then
			return TRUE
		end
	end
	-- CUSTOM: End.

	local style = c_Style
	local hand = HAND_LEFT

	if style == HAND_RIGHT_BOTH then
		hand = HAND_RIGHT
	end

	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, hand)

	if style == HAND_RIGHT and GetEquipType(hand, WEAPON_CATEGORY_STAFF) == TRUE then
		return FALSE
	end
	if sp_kind == 249 and (style == HAND_LEFT_BOTH or style == HAND_RIGHT_BOTH) then
		return FALSE
	end
	if IsWeaponCanGuard() == FALSE then
		return FALSE
	end
	if IsEnableDualWielding() ~= -1 then
		return FALSE
	end
	return TRUE
end

function ExecGuard(event, blend_type)
	if env(ActionDuration, ACTION_ARM_ACTION) > 0 then
		return FALSE
	end
	if c_IsStealth == TRUE then
		blend_type = ALLBODY
	end
	if env(ActionRequest, ACTION_ARM_L1) == TRUE or env(ActionDuration, ACTION_ARM_L1) > 0 then
		if env(GetStamina) <= 0 then
			return FALSE
		end
		if IsEnableGuard() == TRUE then
			local style = c_Style
			local hand = HAND_LEFT

			if style == HAND_RIGHT_BOTH then
				hand = HAND_RIGHT
			end

			local kind = env(GetEquipWeaponCategory, hand)
			local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, hand)
			local guardindex = env(GetGuardMotionCategory, hand)

			if kind == WEAPON_CATEGORY_DUELING_SHIELD then
				guardindex = GUARD_STYLE_DUELINGSHIELD
			end

			-- Set Torch Color
			if kind == WEAPON_CATEGORY_TORCH and style == HAND_RIGHT then
				guardindex = GUARD_STYLE_TORCH

				if sp_kind == 291 then
					SetVariable("IndexTorchColor", 1) -- Ghostflame Torch
				elseif sp_kind == 292 then
					SetVariable("IndexTorchColor", 2) -- St. Trina's Torch
				elseif sp_kind == 288 then
					SetVariable("IndexTorchColor", 3) -- Nanaya's Torch
				else
					SetVariable("IndexTorchColor", 0) -- Torch
				end
			elseif sp_kind == 240 and style == HAND_RIGHT then
				guardindex = GUARD_STYLE_TORCH
			elseif style == HAND_RIGHT_BOTH or style == HAND_LEFT_BOTH then
				if env(GetStayAnimCategory) ~= 15 and env(GetStayAnimCategory) ~= 0 and env(GetStayAnimCategory) ~= 2
					and env(GetStayAnimCategory) ~= 3 then
					guardindex = GUARD_STYLE_DEFAULT
				end
				if kind == WEAPON_CATEGORY_DUELING_SHIELD then
					guardindex = GUARD_STYLE_DUELINGSHIELD
				end
			end

			if env(GetSpEffectID, 172) == TRUE then
				SetVariable("GuardStartType", 1)
			else
				SetVariable("GuardStartType", 0)
			end

			SetVariable("IndexGuardStyle", guardindex)

			-- CUSTOM: Begin.
			if Game_IsPlayer() == TRUE then
				Game_SetGuardStyle(FALSE)
				if Deflect_IsCounterExtends() == TRUE or kind ~= WEAPON_CATEGORY_TORCH then
					if Request_GetDuration(GC_BUTTONS.L1) < 50 then
						Deflect_Activate(FALSE)
					end
				end
			end
			-- CUSTOM: End.

			if blend_type == ALLBODY and MoveStart(LOWER, Event_MoveLong, FALSE) == TRUE then
				blend_type = UPPER
			end

			if env(GetSpEffectID, 102000) == TRUE and event ~= Event_GuardOn then
				local is_after_additive_just_guard = FALSE
				if env(GetSpEffectID, 102020) == TRUE or env(GetSpEffectID, 102022) == TRUE then
					is_after_additive_just_guard = TRUE
				end
				if env(GetSpEffectID, 102002) == TRUE and is_after_additive_just_guard == FALSE then
					event = Event_GuardStart_JustGuard2
				elseif env(GetSpEffectID, 102003) == TRUE and is_after_additive_just_guard == FALSE then
					event = Event_GuardStart_JustGuard3
				elseif env(GetSpEffectID, 102004) == TRUE and is_after_additive_just_guard == FALSE then
					if IsNodeActive("GuardStart_JustGuard4_Upper Selector") == TRUE then
						event = Event_GuardStart_JustGuard4_SelfTrans
					else
						event = Event_GuardStart_JustGuard4
					end
				elseif event ~= Event_GuardStart then
				elseif IsNodeActive("GuardStart_JustGuard_Upper Selector") == TRUE then
					event = Event_GuardStart_JustGuard_SelfTrans
				else
					event = Event_GuardStart_JustGuard
				end
			end

			act(AddSpEffect, 102021)
			ExecEventHalfBlend(event, blend_type)

			return TRUE
		end
	end
	return FALSE
end

function ResetRequest()
	act(ResetInputQueue)
end

function CheckActionRequest()
	return env(HasActionRequest)
end

function ExecStop()
	-- 100200 "[HKS] Gesture Anim"

	if GetVariable("MoveSpeedLevel") > 0 and env(GetSpEffectID, 100200) == FALSE then
		return FALSE
	end

	local stop_speed = GetVariable("MoveSpeedLevelReal")
	local movedirection = GetVariable("MoveDirection")
	local stop_speed_threshold = 0.3499999940395355

	SetVariable("ToggleDash", 0)
	SetWeightIndex()

	if GetVariable("EvasionWeightIndex") == EVASION_WEIGHT_INDEX_OVERWEIGHT and stop_speed > 0.3499999940395355 then
		stop_speed = stop_speed_threshold
	end

	if stop_speed >= 0 and stop_speed <= 1 then
		if stop_speed <= stop_speed_threshold then
			if c_IsStealth == TRUE then
				ExecEventAllBody("W_Stealth_Idle")
			else
				ExecEventAllBody("W_Idle")
			end
		elseif c_IsStealth == TRUE then
			if movedirection == 0 then
				ExecEventAllBody("W_StealthRunStopFront")
			elseif movedirection == 1 then
				ExecEventAllBody("W_StealthRunStopBack")
			elseif movedirection == 2 then
				ExecEventAllBody("W_StealthRunStopLeft")
			elseif movedirection == 3 then
				ExecEventAllBody("W_StealthRunStopRight")
			end
		elseif movedirection == 0 then
			ExecEventAllBody("W_RunStopFront")
		elseif movedirection == 1 then
			ExecEventAllBody("W_RunStopBack")
		elseif movedirection == 2 then
			ExecEventAllBody("W_RunStopLeft")
		elseif movedirection == 3 then
			ExecEventAllBody("W_RunStopRight")
		end
	elseif stop_speed > 1 then
		if c_IsStealth == TRUE then
			ExecEventAllBody("W_StealthDashStop")
		else
			ExecEventAllBody("W_DashStop")
		end
	elseif c_IsStealth == TRUE then
		ExecEventAllBody("W_Stealth_Idle")
	else
		ExecEventAllBody("W_Idle")
	end
	return TRUE
end

function ExecStopHalfBlend(event, to_idle)
	-- 100200 "[HKS] Gesture Anim"

	if GetVariable("MoveSpeedLevel") > 0 and env(GetSpEffectID, 100200) == FALSE then
		return FALSE
	end

	SetVariable("LocomotionState", 0)
	if to_idle == TRUE then
		ExecEventNoReset("W_Idle")
		return TRUE
	end

	ExecEventHalfBlendNoReset(event, LOWER)
	return TRUE
end

function MoveStart(blend_type, event, gen_hand)
	-- 100200 "[HKS] Gesture Anim"

	if GetVariable("MoveSpeedLevel") <= 0 then
		return FALSE
	end

	if env(GetSpEffectID, 100200) == TRUE then
		return FALSE
	end

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		Action_SetSpecial(FALSE)
		Action_SetCritical(FALSE)
		Combo_SetGuardStance(FALSE)
		Combo_ResetComboActions()
	end
	-- CUSTOM: End.

	if blend_type ~= LOWER then
		if gen_hand == FALSE then
			SetVariable("ArtsTransition", 0)
		else
			SetArtsGeneratorTransitionIndex()
		end
	end

	SetBonfireIndex()

	local stealth_state = GetVariable("StealthState")

	if (stealth_state == STEALTH_TO_STEALTHIDLE or stealth_state == STEALTH_TO_IDLE)
		and GetVariable("StealthTransitionIndex") > 0 then
		ExecEventHalfBlendNoReset(event, blend_type)
		return TRUE
	end

	if GetLocomotionState() ~= PLAYER_STATE_MOVE then
		SetVariable("MoveSpeedLevelReal", 0)
		SpeedUpdate()
	end

	ExecEventHalfBlend(event, blend_type)

	return TRUE
end

function MoveStartonCancelTiming(event, gen_hand)
	if env(IsMoveCancelPossible) == TRUE then
		if GetLocomotionState() == PLAYER_STATE_MOVE then
			if MoveStart(UPPER, event, gen_hand) == TRUE then
				return TRUE
			end
		elseif MoveStart(ALLBODY, event, gen_hand) == TRUE then
			return TRUE
		end
	end
	return FALSE
end

function SetBaseCategory()
	SetVariable("IndexBaseCategory", GetBaseCategory())
end

function GetBaseCategory()
	-- Stay Anim is Weapon Motion Position ID
	local basecategoryid = 0
	local index = 0
	basecategoryid = env(GetStayAnimCategory)

	if basecategoryid == 0 then
		index = 0
	elseif basecategoryid == 2 or basecategoryid == 12 then
		index = 1
	elseif basecategoryid == 3 or basecategoryid == 13 then
		index = 2
	end
	return index
end

function SetArtCancelType()
	if IsEnableSwordArts() == TRUE then
		act(SetWeaponCancelType, env(GetWeaponCancelType, c_SwordArtsHand))
	else
		act(SetWeaponCancelType, 0)
	end
end

function GetSwordArtInfo()
	local style = c_Style
	local is_both = FALSE

	if style >= HAND_LEFT_BOTH then
		is_both = TRUE
	end

	local art_id = 0
	local art_hand = 0

	if is_both == TRUE then
		if style == HAND_RIGHT_BOTH then
			art_hand = HAND_RIGHT
		elseif style == HAND_LEFT_BOTH then
			art_hand = HAND_LEFT
		end

		art_id = env(GetSwordArtID, art_hand)
	else
		local weaponswordartid = env(GetSwordArtID, HAND_LEFT)

		if IsShieldArts(weaponswordartid) == FALSE and IsArrowStanceArts(weaponswordartid) == FALSE then
			art_hand = HAND_RIGHT
			art_id = env(GetSwordArtID, HAND_RIGHT)
		else
			art_hand = HAND_LEFT
			art_id = weaponswordartid
		end
	end

	if env(GetSpEffectID, 102150) == TRUE then
		art_id = 0
	elseif env(GetSpEffectID, 102151) == TRUE then
		art_id = 0
	end

	return art_id, art_hand
end

function IsEnableSwordArts()
	-- 17 is Torch Attack

	local style = c_Style
	local arts_id = c_SwordArtsID

	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)

	if env(IsOnMount) == TRUE then
		return FALSE
	end

	if style ~= HAND_LEFT_BOTH and c_SwordArtsHand == 0 then
		if IsWeaponCatalyst(sp_kind) == TRUE then
			return FALSE
		end
		if IsShieldArts(arts_id) == TRUE then
			return TRUE
		else
			return FALSE
		end
	else
		if style == HAND_RIGHT and IsWeaponCatalyst(sp_kind) == TRUE then
			return FALSE
		end
		if arts_id ~= 17 and arts_id ~= SWORDARTS_INVALID then
			return TRUE
		end
	end
	return FALSE
end

function GreyOutSwordArtFE()
	if c_IsEnableSwordArts == FALSE then
		act(SetArtsPointFEDisplayState, 1)
		return
	end

	if c_SwordArtsID == SWORDARTS_PARRY then
		act(SetArtsPointFEDisplayState, 1)
	else
		act(SetArtsPointFEDisplayState, 0)
	end
end

function IsAttackSwordArts(arts_id)
	local aow_blacklist = {
		157, -- Raptor of the Mists
		160  -- White Shadow's Lure
	}
	local aow_whitelist = {
		273, -- Raging Beast
		276, -- Blind Spot
		313, -- Dynastic Sickleplay
		348  -- Discus Hurl
	}

	if IsShieldArts(arts_id) == TRUE or IsRollingArts(arts_id) == TRUE or IsEnchantArts(arts_id) == TRUE
		or Contains(aow_blacklist, arts_id) == TRUE then
		if Contains(aow_whitelist, arts_id) then
			return TRUE
		else
			return FALSE
		end
	else
		return TRUE
	end
end

function IsHalfBlendArts(arts_id)
	local aow_list = {
		20, -- Spinning Weapon
		58, -- Gravitas
		168, -- Zamor Ice Storm
		182, -- Knowledge Above All
		183, -- Devourer of Worlds
		184, -- Familal Rancor
		199, -- Spinning Weapon
		202, -- Tongues of Fire
		203, -- Oracular Bubble
		206, -- Sea of Magma
		213, -- Soul Stifler
		217, -- Glintstone Dart

		264, -- Wall of Sparks
		328, -- Euporia Vortex
		334, -- Feeble Lord's Frenzied Flame
		335  -- Repeating Fire
	}

	if Contains(aow_list, arts_id) == TRUE then
		return TRUE
	else
		return FALSE
	end
end

function IsEnchantArts(arts_id)
	if 130 <= arts_id and arts_id <= 140 then
		return TRUE
	else
		return FALSE
	end
end

function IsShieldArts(arts_id)
	local aow_list = {
		17, -- Torch Attack
		71, -- Firebreather
		90, -- Shield Bash
		91, -- Barricade Shield
		92, -- Parry
		93, -- Buckler Parry
		95, -- Carian Retaliation
		96, -- Storm Wall
		97, -- Golden Parry
		98, -- Shield Crash
		99, -- Thops's Barrier
		151, -- Vow of the Indomitable
		152, -- Holy Ground
		195, -- Fires of Slumber
		196, -- Golden Retaliation
		197, -- Contagious Fury
		201, -- Flame Spit
		202, -- Tongues of Fire
		207, -- Viper Bite
		211, -- Bear Witness!

		322, -- Sleep Evermore
		324, -- Moore's Charge
		348, -- Discus Hurl
		352, -- Revenge of the Night
		354, -- Blindfold of Happiness
		355, -- Blindfold of Happiness (2?)
		359, -- Roaring Bash
		399, -- Shield Strike
		334  -- Feeble Lord's Frenzied Flame
	}

	if Contains(aow_list, arts_id) == TRUE then
		return TRUE
	else
		return FALSE
	end
end

function IsStanceArts(arts_id)
	local aow_list = {
		10, -- Wild Strikes
		11, -- Spinning Strikes
		14, -- Unsheathe
		15, -- Square Off
		21, -- UNUSED
		25, -- Spinning Chain
		100, -- Through and Through
		101, -- Barrage
		102, -- Mighty Shot
		103, -- Enchanted Shot
		104, -- UNUSED
		105, -- Rain of Arrows
		106, -- UNUSED
		107, -- UNUSED
		108, -- Sky Shot
		169, -- Radahn's Rain
		178, -- Transient Moonlight
		219, -- Night-and-Flame Stance
		239, -- Spinning Wheel

		278, -- Overhead Stance
		279, -- Wing Stance
		309, -- Unending Dance
		318, -- Moon-and-Fire Stance
		335, -- Repeating Fire
		337, -- Fan Shot
		340, -- UNUSED
		341, -- UNUSED
		342, -- UNUSED
		343, -- UNUSED
		346, -- UNUSED
		347, -- UNUSED
		357, -- Igor's Drake Hunt
		371  -- Rancor Shot
	}

	if Contains(aow_list, arts_id) == TRUE then
		return TRUE
	else
		return FALSE
	end
end

function IsArrowStanceArts(arts_id)
	local aow_list = {
		100, -- Through and Through
		101, -- Barrage
		102, -- Mighty Shot
		103, -- Enchanted Shot
		104, -- UNUSED
		105, -- Rain of Arrows
		106, -- UNUSED
		107, -- UNUSED
		108, -- Sky Shot
		169, -- Radahn's Rain

		337, -- Fan Shot
		357, -- Igor's Drake Hunt
		371  -- Rancor Shot
	}

	if Contains(aow_list, arts_id) == TRUE then
		return TRUE
	else
		return FALSE
	end
end

function IsAttackStanceArts(arts_id)
	local aow_list = {
		10, -- Wild Strikes
		11, -- Spinning Strikes
		25, -- Spinning Chain
		239, -- Spinning Wheel

		309, -- Unending Dance
		340, -- UNUSED
		341  -- UNUSED
	}

	if Contains(aow_list, arts_id) == TRUE then
		return TRUE
	else
		return FALSE
	end
end

function IsRollingArts(arts_id)
	local aow_list = {
		155, -- Quickstep
		156, -- Bloodhound's Step

		273, -- Raging Beast
		276, -- Blind Spot
		313  -- Dynastic Sickleplay
	}

	if Contains(aow_list, arts_id) == TRUE then
		return TRUE
	else
		return FALSE
	end
end

function GetSwordArtsRequestNew()
	local style = c_Style
	local is_both = FALSE
	local arts_hand = c_SwordArtsHand
	local arts_id = c_SwordArtsID
	local request = SWORDART_REQUEST_INVALID
	local arts_category = arts_id + 600
	local animID = SWORDARTS_ANIM_ID_RIGHT_NORMAL

	if IsStanceArts(arts_id) == TRUE then
		request = SWORDARTS_REQUEST_RIGHT_STANCE
		animID = SWORDARTS_ANIM_ID_RIGHT_STANCE_START
	elseif env(GetSpEffectID, 100052) == TRUE then
		request = SWORDARTS_REQUEST_RIGHT_COMBO_1
		animID = SWORDARTS_ANIM_ID_RIGHT_COMBO_1
	elseif env(GetSpEffectID, 100053) == TRUE then
		request = SWORDARTS_REQUEST_RIGHT_COMBO_2
		animID = SWORDARTS_ANIM_ID_RIGHT_COMBO_2
	elseif IsRollingArts(arts_id) == TRUE then
		request = SWORDARTS_REQUEST_RIGHT_STEP
		animID = SWORDARTS_ANIM_ID_RIGHT_STEP_FRONT
	elseif (style == HAND_LEFT_BOTH or style == HAND_RIGHT_BOTH) and IsShieldArts(arts_id) == TRUE then
		request = SWORDARTS_REQUEST_BOTH_NORMAL
		animID = SWORDARTS_ANIM_ID_BOTH_NORMAL
	elseif arts_hand == HAND_LEFT and IsShieldArts(arts_id) == TRUE then
		request = SWORDARTS_REQUEST_LEFT_NORMAL
		animID = SWORDARTS_ANIM_ID_LEFT_NORMAL
	else
		request = SWORDARTS_REQUEST_RIGHT_NORMAL
		animID = SWORDARTS_ANIM_ID_RIGHT_NORMAL
	end

	act(DebugLogOutput,
		"SwordArtRequest " .. request .. " artsId=" .. arts_id .. "animID=a" .. arts_category .. "_" .. animID)

	return request
end

function HasSwordArtPoint(button, hand)
	return env(HasEnoughArtsPoints, button, hand)
end

function SetSwordArtsPointInfo(button, is_point_consume, to_state_event)
	local aow_list_noFPUse = {
		17, -- Torch Attack
		92, -- Parry
		93, -- Buckler Parry
		94, -- UNUSED
		112 -- Kick
	}

	local hand = c_SwordArtsHand

	if is_point_consume == TRUE then
		act(ReserveArtsPointsUse, button, hand)
	end

	local sel = 0
	local isNoMPUse = FALSE
	local artsID = env(GetSwordArtID, hand)

	if Contains(aow_list_noFPUse, artsID) == TRUE then
		isNoMPUse = TRUE
	end

	if env(HasEnoughArtsPoints, button, hand) == FALSE and isNoMPUse == FALSE then
		sel = 1
		act(DebugLogOutput, "no artspoint , hand=" .. hand)
	elseif env(IsAbilityInsufficient, hand) == TRUE and isNoMPUse == FALSE then
		sel = 1
		act(DebugLogOutput, "no ability , hand=" .. hand)
	end

	local val = "IsEnoughArtPointsL2"

	if button == ACTION_ARM_R1 then
		if c_SwordArtsID == 318 and IsNodeActive("DrawStanceRightAttackLight_Selector") == TRUE then
			val = "IsEnoughArtPointsR2_MesmerSowrdArts"
		else
			val = "IsEnoughArtPointsR1"
		end
	elseif button == ACTION_ARM_R2 then
		val = "IsEnoughArtPointsR2"
	elseif button == ACTION_ARM_L2 and c_SwordArtsID == 334
		and (IsNodeActive("SwordArtsOneShot Selector00") == TRUE
			or IsNodeActive("SwordArtsHalfOneShotShieldBoth_Upper Selector") == TRUE
			or IsNodeActive("SwordArtsOneShotShieldLeft Selector01") == TRUE) then
		val = "IsEnoughArtPointsL2_MadTorchEnd"
	end

	if to_state_event ~= nil then
		if to_state_event == "W_SwordArtsOneShotComboEnd_2" then
			val = "IsEnoughArtPointsR2_2"
		elseif to_state_event == "W_SwordArtsOneShotComboEnd" then
			val = "IsEnoughArtPointsR2"
		end
	end

	if artsID == 309 or artsID == 318 then
		SetVariable("IsEnoughArtPointsL2_DrawStanceRightStart", sel)
	else
		SetVariable("IsEnoughArtPointsL2_DrawStanceRightStart", 0)
	end
	if artsID == 318 then
		SetVariable("IsEnoughArtPointsL2_DrawStanceRightEnd", sel)
	else
		SetVariable("IsEnoughArtPointsL2_DrawStanceRightEnd", 0)
	end
	if artsID == 334 then
		SetVariable("IsEnoughArtPointsL2_MadTorchEnd", sel)
	else
		SetVariable("IsEnoughArtPointsL2_MadTorchEnd", 0)
	end
	if artsID == 309 and IsNodeActive("DrawStanceNoSyncLoop_Upper Selector00") == TRUE then
		SetVariable("IsEnoughArtPointsL2_DrawStanceNoSyncLoop", sel)
	else
		SetVariable(val, sel)
	end
end

function RequestArtPointConsumption(button, hand)
	act(ReserveArtsPointsUse, button, hand)
end

function CheckIfNonGeneratorTransition()
	local kind_right = env(GetEquipWeaponCategory, HAND_RIGHT)
	local kind_left = env(GetEquipWeaponCategory, HAND_LEFT)

	if kind_left == WEAPON_CATEGORY_FIST then
		return TRUE
	end
	return FALSE
end

function SetArtsGeneratorTransitionIndex()
	if GetSwordArtsPutOppositeWeapon() == FALSE then
		SetVariable("ArtsTransition", 0)
		return
	end

	local style = c_Style

	if style == HAND_RIGHT then
		if CheckIfNonGeneratorTransition() == TRUE then
			SetVariable("ArtsTransition", 0)
			return
		end

		local hand = HAND_LEFT

		if c_SwordArtsHand == HAND_LEFT then
			hand = HAND_RIGHT
		end

		local changetype = GetHandChangeType(hand)

		if changetype == WEAPON_CHANGE_REQUEST_LEFT_WAIST then
			SetVariable("ArtsTransition", 1)
		elseif changetype == WEAPON_CHANGE_REQUEST_LEFT_BACK then
			SetVariable("ArtsTransition", 2)
		elseif changetype == WEAPON_CHANGE_REQUEST_LEFT_SHOULDER then
			SetVariable("ArtsTransition", 3)
		elseif changetype == WEAPON_CHANGE_REQUEST_LEFT_SPEAR then
			SetVariable("ArtsTransition", 4)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_WAIST then
			SetVariable("ArtsTransition", 5)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_BACK then
			SetVariable("ArtsTransition", 6)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_SHOULDER then
			SetVariable("ArtsTransition", 7)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_SPEAR then
			SetVariable("ArtsTransition", 8)
		else
			SetVariable("ArtsTransition", 0)
		end
	else
		local idle_cat = env(GetStayAnimCategory)

		if env(GetEquipWeaponCategory, c_SwordArtsHand) == 53 or env(GetEquipWeaponCategory, c_SwordArtsHand) == 58 then
			if c_SwordArtsHand == HAND_RIGHT then
				SetVariable("ArtsTransition", 1)
			else
				SetVariable("ArtsTransition", 2)
			end
			return
		elseif idle_cat < 10 then
			SetVariable("ArtsTransition", 0)
			return
		end
		SetVariable("ArtsTransition", 9)
	end
end

function SetMagicGeneratorTransitionIndex()
	if GetMagicPutOppositeWeapon() == FALSE then
		SetVariable("ArtsTransition", 0)
		return
	end

	local style = c_Style

	if style == HAND_RIGHT then
		local hand = HAND_LEFT

		if g_Magichand == HAND_LEFT then
			hand = HAND_RIGHT
		end

		local changetype = GetHandChangeType(hand)

		if changetype == WEAPON_CHANGE_REQUEST_LEFT_WAIST then
			SetVariable("ArtsTransition", 1)
		elseif changetype == WEAPON_CHANGE_REQUEST_LEFT_BACK then
			SetVariable("ArtsTransition", 2)
		elseif changetype == WEAPON_CHANGE_REQUEST_LEFT_SHOULDER then
			SetVariable("ArtsTransition", 3)
		elseif changetype == WEAPON_CHANGE_REQUEST_LEFT_SPEAR then
			SetVariable("ArtsTransition", 4)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_WAIST then
			SetVariable("ArtsTransition", 5)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_BACK then
			SetVariable("ArtsTransition", 6)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_SHOULDER then
			SetVariable("ArtsTransition", 7)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_SPEAR then
			SetVariable("ArtsTransition", 8)
		else
			SetVariable("ArtsTransition", 0)
		end
	else
		SetVariable("ArtsTransition", 9)
	end
end

function SetRightSpecialHeavyAttackGeneratorTransitionIndex()
	-- NOT Ornamental Straight Sword
	if env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT) ~= 852 then
		SetVariable("ArtsTransition", 0)
		return
	end

	local style = c_Style

	if style == HAND_RIGHT then
		local hand = HAND_LEFT

		if g_Magichand == HAND_LEFT then
			hand = HAND_RIGHT
		end

		local changetype = GetHandChangeType(hand)

		if changetype == WEAPON_CHANGE_REQUEST_LEFT_WAIST then
			SetVariable("ArtsTransition", 1)
		elseif changetype == WEAPON_CHANGE_REQUEST_LEFT_BACK then
			SetVariable("ArtsTransition", 2)
		elseif changetype == WEAPON_CHANGE_REQUEST_LEFT_SHOULDER then
			SetVariable("ArtsTransition", 3)
		elseif changetype == WEAPON_CHANGE_REQUEST_LEFT_SPEAR then
			SetVariable("ArtsTransition", 4)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_WAIST then
			SetVariable("ArtsTransition", 5)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_BACK then
			SetVariable("ArtsTransition", 6)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_SHOULDER then
			SetVariable("ArtsTransition", 7)
		elseif changetype == WEAPON_CHANGE_REQUEST_RIGHT_SPEAR then
			SetVariable("ArtsTransition", 8)
		else
			SetVariable("ArtsTransition", 0)
		end
	else
		SetVariable("ArtsTransition", 9)
	end
end

function IsMagicAnimExists(magic_type, anim_id)
	return env(DoesAnimExist, magic_type + 400, anim_id)
end

function IsQuickMagic()
	local magic_type = env(GetMagicAnimType)

	local magic_type_list = {
		MAGIC_REQUEST_STONE_SHOTGUN,
		MAGIC_REQUEST_QUICKENBULLET,
		MAGIC_REQUEST_QUICKSLASH,
		MAGIC_REQUEST_QUICK_FLAME
	}

	if (magic_type == MAGIC_REQUEST_WEAPON_ENCHANT2 and c_Style == HAND_RIGHT) or Contains(magic_type_list, magic_type) == TRUE then
		return TRUE
	end
	return FALSE
end

function IsWeaponEnchantMagic()
	local magic_type = env(GetMagicAnimType)

	local magic_type_list = {
		MAGIC_REQUEST_WEAPON_ENCHANT,
		MAGIC_REQUEST_WEAPON_ENCHANT2,
		MAGIC_REQUEST_WEAPON_ENCHANT_B,
		MAGIC_REQUEST_THUNDER_ENCHANT,
		MAGIC_REQUEST_HOLY_ENCHANT
	}

	if Contains(magic_type_list, magic_type) == TRUE then
		return TRUE
	end
	return FALSE
end

function IsJumpMagic()
	local magic_type = env(GetMagicAnimType)

	local magic_type_list = {
		MAGIC_REQUEST_FLYING_BREATH,
		MAGIC_REQUEST_ELDER_DRAGON_BREATH
	}

	if Contains(magic_type_list, magic_type) == TRUE then
		return TRUE
	end
	return FALSE
end

function IsComboMagic()
	return IsMagicAnimExists(env(GetMagicAnimType), 45020)
end

function IsChargeMagic()
	return IsMagicAnimExists(env(GetMagicAnimType), 45011)
end

function CheckIfHoldMagic()
	local magic_type = env(GetMagicAnimType)
	local has_hold_anim = IsMagicAnimExists(magic_type, 45012)

	if not has_hold_anim then
		if magic_type ~= 35 then
			has_hold_anim = false
		else
			has_hold_anim = true
		end
	end
	return has_hold_anim
end

function IsStealthMagic(magic_type)
	local magic_type_list = {
		26,
		114
	}

	if Contains(magic_type_list, magic_type) == TRUE then
		return TRUE
	end
	return FALSE
end

function IsRollingMagic(magic_type)
	local magic_type_list = {
		127
	}

	if Contains(magic_type_list, magic_type) == TRUE then
		return TRUE
	end
	return FALSE
end

function SetMoveType()
	-- 100130 "[HKS] Stance - SetMoveType 1"
	-- 100140 "[HKS] Stance - SetMoveType 2"
	-- 100150 "[HKS] Stance - SetMoveType 0"
	-- 100160 "[HKS] Stance - SetMoveType 3"
	-- Unknown (DLC) "[HKS] Stance - SetMoveType 4"
	-- Unknown (DLC) "[HKS] Stance - SetMoveType 5"

	if env(GetSpEffectID, 100130) == TRUE then
		SetVariable("MoveType", ConvergeValue(1, hkbGetVariable("MoveType"), 5, 5))
		SetVariable("StanceMoveType", 1)
	elseif env(GetSpEffectID, 100140) == TRUE then
		SetVariable("MoveType", ConvergeValue(1, hkbGetVariable("MoveType"), 5, 5))
		SetVariable("StanceMoveType", 2)
	elseif env(GetSpEffectID, 100150) == TRUE then
		SetVariable("MoveType", ConvergeValue(1, hkbGetVariable("MoveType"), 5, 5))
		SetVariable("StanceMoveType", 0)
	elseif env(GetSpEffectID, 100160) == TRUE then
		SetVariable("MoveType", ConvergeValue(1, hkbGetVariable("MoveType"), 5, 5))
		SetVariable("StanceMoveType", 3)
	elseif env(GetSpEffectID, 19920) == TRUE then
		SetVariable("MoveType", ConvergeValue(1, hkbGetVariable("MoveType"), 5, 5))
		SetVariable("StanceMoveType", 4)
	elseif env(GetSpEffectID, 19930) == TRUE then
		SetVariable("MoveType", ConvergeValue(1, hkbGetVariable("MoveType"), 5, 5))
		SetVariable("StanceMoveType", 5)
	else
		SetVariable("MoveType", ConvergeValue(0, hkbGetVariable("MoveType"), 5, 5))
	end
end

function SetStyleSpecialEffect()
	-- 100620 "[HKS] Right Hand Style"
	-- 100621 "[HKS] Left Hand Style"

	if c_Style == HAND_LEFT_BOTH then
		if env(GetSpEffectID, 100621) == FALSE then
			act(AddSpEffect, 100621)
		end
	elseif env(GetSpEffectID, 100620) == FALSE then
		act(AddSpEffect, 100620)
	end
end

function GetAttackRequest(is_guard)
	local style = c_Style
	local is_both = FALSE
	local is_both_right = FALSE

	if style >= HAND_LEFT_BOTH then
		is_both = TRUE
	end

	if style == HAND_RIGHT_BOTH then
		is_both_right = TRUE
	end

	local hand = HAND_RIGHT
	if style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end

	local is_arrow = GetEquipType(hand, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_LARGE_ARROW)
	local is_crossbow = GetEquipType(hand, WEAPON_CATEGORY_CROSSBOW)
	local is_ballista = GetEquipType(hand, WEAPON_CATEGORY_BALLISTA)
	local is_staff = GetEquipType(hand, WEAPON_CATEGORY_STAFF)
	local request_r1 = env(ActionRequest, ACTION_ARM_R1)
	local request_r2 = env(ActionRequest, ACTION_ARM_R2)
	local request_l1 = env(ActionRequest, ACTION_ARM_L1)
	local request_l2 = env(ActionRequest, ACTION_ARM_L2)

	if env(ActionDuration, ACTION_ARM_ACTION) > 0 then
		request_r1 = FALSE
		request_r2 = FALSE
		request_l1 = FALSE
		request_l2 = FALSE
	end

	-- R2
	if request_r1 == TRUE and is_staff == FALSE or request_r2 == TRUE and is_staff == TRUE then
		if is_both == TRUE then
			if is_arrow == TRUE then
				g_ArrowSlot = 0
				act(ChooseBowAndArrowSlot, 0)

				if style == HAND_LEFT_BOTH then
					return ATTACK_REQUEST_ARROW_FIRE_LEFT
				else
					return ATTACK_REQUEST_ARROW_FIRE_RIGHT
				end
			elseif is_crossbow == TRUE or is_ballista == TRUE then
				g_ArrowSlot = 0
				act(ChooseBowAndArrowSlot, 0)

				return ATTACK_REQUEST_BOTHRIGHT_CROSSBOW
			else
				return ATTACK_REQUEST_BOTH_LIGHT
			end
		elseif is_guard == TRUE then
			local is_spear = GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_SPEAR)
			local is_rapier = GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_RAPIER)
			local is_large_spear = GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_LARGE_SPEAR)
			local is_large_rapier = GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_LARGE_RAPIER)

			-- Shield Poke
			if is_spear == TRUE or is_rapier == TRUE or is_large_spear == TRUE or is_large_rapier == TRUE then
				if env(ActionDuration, ACTION_ARM_L1) > 0 then
					return ATTACK_REQUEST_ATTACK_WHILE_GUARD
				else
					return ATTACK_REQUEST_RIGHT_LIGHT
				end
			else
				if is_arrow == TRUE or is_ballista == TRUE then
					return ATTACK_REQUEST_ARROW_BOTH_RIGHT
				end

				if is_crossbow == TRUE then
					g_ArrowSlot = 0
					act(ChooseBowAndArrowSlot, 0)
					return ATTACK_REQUEST_RIGHT_CROSSBOW
				end
				return ATTACK_REQUEST_RIGHT_LIGHT
			end
		else
			if is_arrow == TRUE or is_ballista == TRUE then
				return ATTACK_REQUEST_ARROW_BOTH_RIGHT
			end

			if is_crossbow == TRUE then
				g_ArrowSlot = 0
				act(ChooseBowAndArrowSlot, 0)

				return ATTACK_REQUEST_RIGHT_CROSSBOW
			end
			return ATTACK_REQUEST_RIGHT_LIGHT
		end
	end

	-- R2
	if request_r2 == TRUE then
		-- Bow / Greatbow
		if is_arrow == TRUE then
			if is_both == TRUE then
				g_ArrowSlot = 1
				act(ChooseBowAndArrowSlot, 1)
				if style == HAND_LEFT_BOTH then
					return ATTACK_REQUEST_ARROW_FIRE_LEFT2
				else
					return ATTACK_REQUEST_ARROW_FIRE_RIGHT2
				end
			else
				return ATTACK_REQUEST_ARROW_BOTH_RIGHT
			end
			-- Crossbow
		elseif is_crossbow == TRUE then
			if is_both == TRUE then
				g_ArrowSlot = 1
				act(ChooseBowAndArrowSlot, 1)
				return ATTACK_REQUEST_BOTHRIGHT_CROSSBOW2
			else
				g_ArrowSlot = 1
				act(ChooseBowAndArrowSlot, 1)

				return ATTACK_REQUEST_RIGHT_CROSSBOW2
			end
			-- Ballista
		elseif is_ballista == TRUE then
			if is_both == TRUE then
				g_ArrowSlot = 1
				act(ChooseBowAndArrowSlot, 1)

				return ATTACK_REQUEST_BOTHRIGHT_CROSSBOW2
			else
				return ATTACK_REQUEST_ARROW_BOTH_RIGHT
			end
			-- 2H Heavy
		else
			local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, hand)
			if IsWeaponCatalyst(sp_kind) == TRUE then
				return ATTACK_REQUEST_INVALID
			end
			if is_both == TRUE then
				return ATTACK_REQUEST_BOTH_HEAVY
				-- R1 Heavy
			else
				return ATTACK_REQUEST_RIGHT_HEAVY
			end
		end
	end
	-- L1
	if request_l1 == TRUE then
		if env(IsPrecisionShoot) == TRUE then
			return ATTACK_REQUEST_INVALID
		end
		local is_shield_left = GetEquipType(HAND_LEFT, WEAPON_CATEGORY_SMALL_SHIELD, WEAPON_CATEGORY_MIDDLE_SHIELD,
			WEAPON_CATEGORY_LARGE_SHIELD, WEAPON_CATEGORY_TORCH)
		local is_shield_right = GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_SMALL_SHIELD, WEAPON_CATEGORY_MIDDLE_SHIELD,
			WEAPON_CATEGORY_LARGE_SHIELD, WEAPON_CATEGORY_TORCH)
		local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, hand)
		if is_both == TRUE and sp_kind == 249 then
			return ATTACK_REQUEST_BOTH_LEFT
		end
		if is_shield_left == TRUE then
			return ATTACK_REQUEST_INVALID
		end
		if is_shield_right == TRUE and is_both_right == TRUE then
			return ATTACK_REQUEST_INVALID
		end
		is_arrow = GetEquipType(HAND_LEFT, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW,
			WEAPON_CATEGORY_LARGE_ARROW, WEAPON_CATEGORY_BALLISTA)
		is_crossbow = GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW)
		if is_arrow == TRUE then
			if is_both == FALSE then
				return ATTACK_REQUEST_ARROW_BOTH_LEFT
			else
				return ATTACK_REQUEST_INVALID
			end
		elseif is_crossbow == TRUE then
			if is_both == FALSE then
				g_ArrowSlot = 0
				act(ChooseBowAndArrowSlot, 0)
				return ATTACK_REQUEST_LEFT_CROSSBOW
			else
				return ATTACK_REQUEST_INVALID
			end
		end
		is_staff = GetEquipType(HAND_LEFT, WEAPON_CATEGORY_STAFF)
		if is_staff == TRUE then
			return ATTACK_REQUEST_INVALID
		end
		is_arrow = GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW,
			WEAPON_CATEGORY_LARGE_ARROW, WEAPON_CATEGORY_CROSSBOW, WEAPON_CATEGORY_BALLISTA)
		if is_arrow == TRUE and is_both == TRUE then
			return ATTACK_REQUEST_INVALID
		end
		is_crossbow = GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_CROSSBOW)
		if is_crossbow == TRUE and is_both == TRUE then
			return ATTACK_REQUEST_INVALID
		end
		local isEnableDualWielding = IsEnableDualWielding()
		if isEnableDualWielding == HAND_RIGHT then
			return ATTACK_REQUEST_DUAL_RIGHT
		elseif isEnableDualWielding == HAND_LEFT then
			return ATTACK_REQUEST_DUAL_LEFT
		end
		if IsWeaponCanGuard() == TRUE then
			return ATTACK_REQUEST_INVALID
		end
		return ATTACK_REQUEST_LEFT_HEAVY
	end
	-- L2
	if request_l2 == TRUE then
		act(DebugLogOutput, "action request ACTION_ARM_L2")
		if is_both == FALSE then
			is_arrow = GetEquipType(HAND_LEFT, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW,
				WEAPON_CATEGORY_LARGE_ARROW, WEAPON_CATEGORY_BALLISTA)
			is_crossbow = GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW)
			if is_arrow == TRUE then
				return ATTACK_REQUEST_ARROW_BOTH_LEFT
			elseif is_crossbow == TRUE then
				g_ArrowSlot = 1
				act(ChooseBowAndArrowSlot, 1)
				return ATTACK_REQUEST_LEFT_CROSSBOW2
			end
			local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)
			if IsWeaponCatalyst(sp_kind) == TRUE then
				return ATTACK_REQUEST_INVALID
			end
		end
		if c_SwordArtsID == 399 then
			if is_both == FALSE then
				return ATTACK_REQUEST_LEFT_HEAVY
			else
				return ATTACK_REQUEST_BOTH_LIGHT
			end
		end
		if c_IsEnableSwordArts == TRUE then
			local swordartrequest = GetSwordArtsRequestNew()
			local is_arrowright = GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW,
				WEAPON_CATEGORY_LARGE_ARROW, WEAPON_CATEGORY_BALLISTA)
			if swordartrequest == SWORDARTS_REQUEST_RIGHT_STANCE and is_arrowright == TRUE then
				if style ~= HAND_RIGHT_BOTH then
					return ATTACK_REQUEST_ARROW_BOTH_RIGHT
				else
					return swordartrequest
				end
			else
				return swordartrequest
			end
		elseif is_both == TRUE then
			if GetEquipType(hand, WEAPON_CATEGORY_STAFF) == TRUE then
				return ATTACK_REQUEST_BOTH_LIGHT
			else
				return ATTACK_REQUEST_BOTH_HEAVY
			end
		else
			return ATTACK_REQUEST_LEFT_HEAVY
		end
	end
	return ATTACK_REQUEST_INVALID
end

function ExecAttack(r1, r2, l1, l2, b1, b2, is_guard, blend_type, artsr1, artsr2, is_stealth_rolling)
	local cur_stamina = env(GetStamina)

	if cur_stamina <= 0 and GetVariable("StaminaComboResetTest") == 1 then
		g_ComboReset = TRUE
	end

	local request = GetAttackRequest(is_guard)

	-- CUSTOM: Begin.
	local Result, IsGuardPossible, IsSpecialAttack, NextAttack, R1, R2, B1, B2 = FALSE, FALSE, FALSE, nil, nil, nil, nil, nil
	if Game_IsPlayer() == TRUE then
		if Gameplay_AirRetreat_Update() == TRUE then
			return FALSE
		end

		Gameplay_GuardStance_Update()

		Action_CancelAnimation()

		if Combo_IsOverrideAttack() == TRUE and Combo_IsOverrideRequest(request) == TRUE and artsr1 == FALSE and artsr2 == FALSE then
			Result, NextAttack, request, R1, R2, B1, B2 = Combo_OverrideAttack(request, r1, r2, b1, b2)
		end

		if Action_IsSpecialRequest() == TRUE or request ~= ATTACK_REQUEST_INVALID then
			IsGuardPossible = Action_IsGuardPossible()
			Deflect_SetInterruptAttack(TRUE)
			if System_IsExistInTable(c_SwordArtsID, DMN_DeflectAoWs_Table) == TRUE and ((IsStanceArts(c_SwordArtsID) == TRUE and (artsr1 == TRUE or artsr2 == TRUE)) or (IsStanceArts(c_SwordArtsID) == FALSE and Request_IsPressed(GC_BUTTONS.L2) == TRUE)) then
				IsSpecialAttack = TRUE
				Deflect_SetInterruptAttack(FALSE)
			end

			if Action_IsSpecialRequest() == TRUE or Deflect_IsCounterPossible() == TRUE or IsSpecialAttack == TRUE then
				Deflect_Activate(TRUE)
			end

			if AI_IsEnemyAlert() == TRUE then
				if IsGuardPossible == FALSE or Request_IsPressed(GC_BUTTONS.L1) == FALSE then
					AI_TriggerEnemyAlert()
				end
			end

			Action_SetSpecialRequest(FALSE)
		else
			return FALSE
		end
	end
	-- CUSTOM: End.

	if request == ATTACK_REQUEST_INVALID then
		return FALSE
	end

	act(DebugLogOutput, "ExecAttack request=" .. request)

	local style = c_Style
	local swordartpoint_hand = HAND_RIGHT
	local atk_hand = HAND_RIGHT
	local guard_hand = HAND_RIGHT
	local is_find_atk = TRUE

	if cur_stamina <= 0 then
		ResetRequest()
		return FALSE
	end

	local is_Dual = FALSE
	g_ComboReset = FALSE

	if c_Style == HAND_LEFT_BOTH then
		swordartpoint_hand = HAND_LEFT
	end

	act(SetDamageMotionBlendRatio, 0)

	if env(IsSpecialTransitionPossible) == TRUE then
		r1 = "W_AttackRightLight1"
		l1 = "W_AttackLeftLight1"
		b1 = "W_AttackBothLight1"

		-- 132 "[HKS] Recovery Window: Heavy Attack"
		-- Applied in TAE
		if env(GetSpEffectID, 132) == FALSE then
			r2 = "W_AttackRightHeavy1Start"
			l2 = "W_AttackLeftHeavy1"
			b2 = "W_AttackBothHeavy1Start"
		end
	end

	-- 133 "[HKS] Switch Heavy to Heavy Sub"
	-- Applied in TAE
	if env(GetSpEffectID, 133) == TRUE then
		if r2 == "W_AttackRightHeavy1Start" then
			r2 = "W_AttackRightHeavy1SubStart"
		end

		if b2 == "W_AttackBothHeavy1Start" then
			b2 = "W_AttackBothHeavy1SubStart"
		end
		-- 134 "[HKS] Switch Heavy Sub to Heavy"
		-- Applied in TAE
	elseif env(GetSpEffectID, 134) == TRUE then
		if r2 == "W_AttackRightHeavy1SubStart" then
			r2 = "W_AttackRightHeavy1Start"
		end

		if b2 == "W_AttackBothHeavy1SubStart" then
			b2 = "W_AttackBothHeavy1Start"
		end
	end

	local isAfterAdditiveJustGuard = FALSE
	if IsNodeActive("Guard_Upper LayerGenerator") == TRUE and env(GetSpEffectID, 102020) == TRUE then
		isAfterAdditiveJustGuard = TRUE
	end

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if Combo_IsOverrideAttack() == TRUE and Result == TRUE then
			r1 = R1
			r2 = R2
			b1 = B1
			b2 = B2
		end
	end
	-- CUSTOM: End.

	-- 173 "[HKS] Guard Counter: End"
	-- 174 "[HKS] Guard Counter: Window"
	if env(GetSpEffectID, 173) == TRUE or env(GetSpEffectID, 174) == TRUE or isAfterAdditiveJustGuard == TRUE then
		if c_Style == HAND_RIGHT_BOTH then
			atk_hand = HAND_RIGHT
			guard_hand = HAND_RIGHT
		elseif c_Style == HAND_LEFT_BOTH then
			atk_hand = HAND_LEFT
			guard_hand = HAND_LEFT
		end

		-- Guard Counter Window
		-- If the player is holding a valid weapon, and has pressed R2, play Guard Counter anim
		if GetEquipType(atk_hand, WEAPON_CATEGORY_STAFF, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW,
			WEAPON_CATEGORY_LARGE_ARROW, WEAPON_CATEGORY_CROSSBOW, WEAPON_CATEGORY_BALLISTA) == FALSE
			and env(ActionRequest, ACTION_ARM_R2) == TRUE then
			if c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH then
				ExecEventAllBody("W_AttackBothHeavyCounter")
			else
				ExecEventAllBody("W_AttackRightHeavyCounter")
			end

			return TRUE
		end
		-- Otherwise, if in Guard Counter Window, mulch the request
		if env(GetSpEffectID, 174) == TRUE then

			-- CUSTOM: Begin.
			if Game_IsPlayer() == TRUE then
				if NextAttack ~= nil then
					ExecEventAllBody(NextAttack)

					if is_find_atk == TRUE then
						SetInterruptType(INTERRUPT_FINDATTACK)
					end

					if style == HAND_RIGHT_BOTH then
						atk_hand = HAND_RIGHT
					elseif style == HAND_LEFT_BOTH then
						atk_hand = HAND_LEFT
					end

					SetAttackHand(atk_hand)
					SetGuardHand(guard_hand)

					if is_Dual == TRUE then
						act(SetThrowPossibilityState_Defender, 400000)
					end

					act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
					SetAIActionState()

					return TRUE
				end
			end
			-- CUSTOM: End.

			return FALSE
		end
	end

	-- 100630 "[HKS] Throw related"
	if env(GetSpEffectID, 100630) == TRUE and ExecFallAttack() == TRUE then
		return TRUE
	end
	if request == ATTACK_REQUEST_RIGHT_LIGHT then
		if artsr1 == TRUE then
			SetSwordArtsPointInfo(ACTION_ARM_R1, TRUE, r1)

			if r1 == "W_DrawStanceRightAttackLight" then
				SetSwordArtsWepCategory_DrawStanceRightAttackLight()
			end
		end

		if c_SwordArtsID == 318 then
			if r1 == "W_SwordArtsOneShotComboEnd_MesmerSowrdArts" then
				SetSwordArtsPointInfo(ACTION_ARM_R1, TRUE)
			elseif r1 == "W_SwordArtsOneShotComboEnd_2" then
				SetSwordArtsPointInfo(ACTION_ARM_R1, TRUE)
				local val = GetVariable("IsEnoughArtPointsR1")
				SetVariable("IsEnoughArtPointsR2", val)
			end
		end

		--- 135 "[HKS] Light Sub Start Type 0"
		--- 136 "[HKS] Light Sub Start Type 1"
		--- 137 "[HKS] Light Sub Start Type 2"
		--- 138 "[HKS] Light Sub Start Type 3"
		if r1 == "W_AttackRightLightSubStart" then
			if env(GetSpEffectID, 135) == TRUE then
				SetVariable("AttackLightSubStartType", 0)
			elseif env(GetSpEffectID, 136) == TRUE then
				SetVariable("AttackLightSubStartType", 1)
			elseif env(GetSpEffectID, 137) == TRUE then
				SetVariable("AttackLightSubStartType", 2)
			elseif env(GetSpEffectID, 138) == TRUE then
				SetVariable("AttackLightSubStartType", 3)
			else
				r1 = "W_AttackRightLight2"
			end
		end

		if r1 == "W_AttackRightLightStealth" and IsUseStealthAttack(FALSE) == FALSE then
			r1 = "W_AttackRightLightStep"
		end

		if GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_STAFF) == TRUE and r1 ~= "W_AttackRightLight2" and r1
			~= "W_AttackRightLight3" then
			r1 = "W_AttackRightLight1"
		end

		if env(GetSpEffectID, 19903) == TRUE then
			r1 = "W_AttackRightLight3"
		elseif env(GetSpEffectID, 19904) == TRUE then
			r1 = "W_AttackRightLight4"
		end
		if env(GetSpEffectID, 19915) == TRUE then
			r1 = "W_AttackRightLight2"
		end

		-- CUSTOM: Begin.
		if IsGuardPossible == TRUE and (DMN_CustomMovesets_Mode == GC_MODES.MOVESETS_DEFAULT or NextAttack == nil) and Game_IsDualWielding() == TRUE and artsr1 == FALSE then
			is_Dual = TRUE

			if r1 == "W_AttackRightLightDash" then
				r1 = "W_AttackDualDash"
			elseif r1 == "W_AttackRightLightStep" then
				r1 = "W_AttackDualRolling"
			elseif r1 == "W_AttackRightBackstep" then
				r1 = "W_AttackDualBackStep"
			elseif r1 == "W_AttackRightLightStealth" then
				if IsUseStealthAttack(TRUE) == FALSE then
					r1 = "W_AttackDualRolling"
				else
					r1 = "W_AttackDualStealth"
				end
			elseif l1 == "W_AttackLeftLight1" then
				r1 = "W_AttackDualLight1"
			elseif l1 == "W_AttackLeftLight2" then
				r1 = "W_AttackDualLight2"
			elseif l1 == "W_AttackLeftLight3" then
				r1 = "W_AttackDualLight3"
			elseif l1 == "W_AttackLeftLight4" then
				r1 = "W_AttackDualLight4"
			elseif l1 == "W_AttackLeftLight5" then
				r1 = "W_AttackDualLight5"
			elseif l1 == "W_AttackLeftLight6" then
				r1 = "W_AttackDualLight6"
			else
				r1 = "W_AttackDualLight1"
			end
		end
		-- CUSTOM: End.

		ExecEventAllBody(r1)

	elseif request == ATTACK_REQUEST_RIGHT_HEAVY then
		if (c_SwordArtsID == 313 or c_SwordArtsID == 273)
			and (r2 == "W_SwordArtsOneShotComboEnd" or r2 == "W_SwordArtsOneShotComboEnd_2") then
			artsr2 = TRUE
			SetVariable("SwordArtsOneShotComboCategory", 0)
		end

		if artsr2 == TRUE then
			SetSwordArtsPointInfo(ACTION_ARM_R2, TRUE, r2)
		end

		local IsEnableSpecialAttack = FALSE

		-- Barbaric Roar: Heavy Special
		if env(GetSpEffectID, 1681) == TRUE or env(GetSpEffectID, 1686) == TRUE then
			IsEnableSpecialAttack = TRUE
			SetVariable("AttackRightHeavySpecialType", 0)
		end

		-- War Cry: Heavy Special
		if env(GetSpEffectID, 1811) == TRUE or env(GetSpEffectID, 1816) == TRUE then
			IsEnableSpecialAttack = TRUE
			SetVariable("AttackRightHeavySpecialType", 1)
		end

		-- Unknown: Heavy Special
		if env(GetSpEffectID, 1716) == TRUE then
			IsEnableSpecialAttack = TRUE
			SetVariable("AttackRightHeavySpecialType", 0)
		end

		-- Unknown: Heavy Special
		if env(GetSpEffectID, 1721) == TRUE then
			IsEnableSpecialAttack = TRUE
			SetVariable("AttackRightHeavySpecialType", 0)
		end

		-- Unknown (DLC): Heavy Special
		if env(GetSpEffectID, 102101) == TRUE then
			IsEnableSpecialAttack = TRUE
			SetVariable("AttackRightHeavySpecialType", 0)
		end

		if IsEnableSpecialAttack == TRUE then
			if r2 == "W_AttackRightHeavy1Start" then
				r2 = "W_AttackRightHeavySpecial1Start"
			elseif r2 == "W_AttackRightHeavy1SubStart" then
				r2 = "W_AttackRightHeavySpecial1SubStart"
			elseif r2 == "W_AttackRightHeavy2Start" then
				r2 = "W_AttackRightHeavySpecial2Start"
			end
		end

		if env(GetSpEffectID, 1681) == FALSE and env(GetSpEffectID, 1686) == FALSE and env(GetSpEffectID, 1811) == FALSE
			and env(GetSpEffectID, 1816) == FALSE and env(GetSpEffectID, 19912) == TRUE then
			r2 = "W_AttackRightHeavy2Start"
		end

		ExecEventAllBody(r2)
	elseif request == ATTACK_REQUEST_LEFT_LIGHT then
		atk_hand = HAND_LEFT
		guard_hand = HAND_LEFT
		ExecEventAllBody(l1)
	elseif request == ATTACK_REQUEST_LEFT_HEAVY then

		-- CUSTOM: Begin.
		if IsGuardPossible == TRUE then
			local WP_Category = env(GetEquipWeaponCategory, HAND_LEFT)
			if WP_Category ~= WEAPON_CATEGORY_DUELING_SHIELD then
				l2 = ""
			end
		end
		-- CUSTOM: End.

		atk_hand = HAND_LEFT
		guard_hand = HAND_LEFT
		ExecEventAllBody(l2)
	elseif request == ATTACK_REQUEST_BOTH_LIGHT then
		if c_SwordArtsID == 318 and r1 == "W_SwordArtsOneShotComboEnd_MesmerSowrdArts" then
			artsr1 = TRUE
		end
		if artsr1 == TRUE then
			SetSwordArtsPointInfo(ACTION_ARM_R1, TRUE, b1)
			if b1 == "W_DrawStanceRightAttackLight" then
				SetSwordArtsWepCategory_DrawStanceRightAttackLight()
			end
		end

		--- 135 "[HKS] Light Sub Start Type 0"
		--- 136 "[HKS] Light Sub Start Type 1"
		--- 137 "[HKS] Light Sub Start Type 2"
		--- 138 "[HKS] Light Sub Start Type 3"
		if b1 == "W_AttackBothLightSubStart" then
			if env(GetSpEffectID, 135) == TRUE then
				SetVariable("AttackLightSubStartType", 0)
			elseif env(GetSpEffectID, 136) == TRUE then
				SetVariable("AttackLightSubStartType", 1)
			elseif env(GetSpEffectID, 137) == TRUE then
				SetVariable("AttackLightSubStartType", 2)
			elseif env(GetSpEffectID, 138) == TRUE then
				SetVariable("AttackLightSubStartType", 3)
			else
				b1 = "W_AttackBothLight2"
			end
		end

		if b1 == "W_AttackBothLightStealth" and IsUseStealthAttack(FALSE) == FALSE then
			b1 = "W_AttackBothLightStep"
		end

		local staff_hand = HAND_RIGHT

		if c_Style == HAND_LEFT_BOTH then
			staff_hand = HAND_LEFT
		end

		if GetEquipType(staff_hand, WEAPON_CATEGORY_STAFF) == TRUE and b1 ~= "W_AttackBothLight2" and b1
			~= "W_AttackBothLight3" then
			b1 = "W_AttackBothLight1"
		end

		if env(GetSpEffectID, 19903) == TRUE then
			b1 = "W_AttackBothLight3"
		elseif env(GetSpEffectID, 19904) == TRUE then
			b1 = "W_AttackBothLight4"
		end

		if env(GetSpEffectID, 19915) == TRUE then
			b1 = "W_AttackBothLight2"
		end

		if style == HAND_RIGHT_BOTH then
			atk_hand = HAND_RIGHT
		elseif style == HAND_LEFT_BOTH then
			atk_hand = HAND_LEFT
		end

		if env(GetEquipWeaponCategory, atk_hand) == WEAPON_CATEGORY_DUELING_SHIELD then
			guard_hand = atk_hand
			if is_guard == TRUE and env(ActionDuration, ACTION_ARM_L1) > 0 then
				b1 = "W_AttackBothLightGuard"
			end
		end

		ExecEventAllBody(b1)
	elseif request == ATTACK_REQUEST_BOTH_LEFT then
		if l1 ~= "W_AttackBothLeftSpecial2" and l1 ~= "W_AttackBothLeftSpecial3" and l1 ~= "W_AttackBothLeftSpecial4"
			and l1 ~= "W_AttackBothLeftSpecial5" then
			l1 = "W_AttackBothLeftSpecial1"
		end

		-- CUSTOM: Begin.
		if IsGuardPossible == TRUE then
			l1 = ""
		end
		-- CUSTOM: End.

		ExecEventAllBody(l1)
	elseif request == ATTACK_REQUEST_BOTH_HEAVY then
		-- DLC 1.13.1: Dynastic Sickleplay, Raging Beast
		if (c_SwordArtsID == 313 or c_SwordArtsID == 273) and (r2 == "W_SwordArtsOneShotComboEnd" or r2 == "W_SwordArtsOneShotComboEnd_2") then
			artsr2 = TRUE
			SetVariable("SwordArtsOneShotComboCategory", 0)
		end

		if artsr2 == TRUE then
			SetSwordArtsPointInfo(ACTION_ARM_R2, TRUE, b2)
		end

		local IsEnableSpecialAttack = FALSE

		-- Barbaric Roar: Heavy Special
		if c_Style == HAND_RIGHT_BOTH then
			if env(GetSpEffectID, 1681) == TRUE or env(GetSpEffectID, 1686) == TRUE then
				IsEnableSpecialAttack = TRUE
				SetVariable("AttackRightHeavySpecialType", 0)
			end
		elseif c_Style == HAND_LEFT_BOTH and (env(GetSpEffectID, 1683) == TRUE or env(GetSpEffectID, 1688) == TRUE) then
			IsEnableSpecialAttack = TRUE
			SetVariable("AttackRightHeavySpecialType", 0)
		end

		-- War Cry: Heavy Special
		if c_Style == HAND_RIGHT_BOTH then
			if env(GetSpEffectID, 1811) == TRUE or env(GetSpEffectID, 1816) == TRUE or env(GetSpEffectID, 1861) == TRUE then
				IsEnableSpecialAttack = TRUE
				SetVariable("AttackRightHeavySpecialType", 1)
			end
		elseif c_Style == HAND_LEFT_BOTH
			and (env(GetSpEffectID, 1813) == TRUE or env(GetSpEffectID, 1818) == TRUE or env(GetSpEffectID, 1863) == TRUE) then
			IsEnableSpecialAttack = TRUE
			SetVariable("AttackRightHeavySpecialType", 1)
		end

		-- Unknown: Heavy Special
		if c_Style == HAND_RIGHT_BOTH then
			if env(GetSpEffectID, 1716) == TRUE then
				IsEnableSpecialAttack = TRUE
				SetVariable("AttackRightHeavySpecialType", 0)
			end
		elseif c_Style == HAND_LEFT_BOTH and env(GetSpEffectID, 1718) == TRUE then
			IsEnableSpecialAttack = TRUE
			SetVariable("AttackRightHeavySpecialType", 0)
		end

		-- Unknown: Heavy Special
		if c_Style == HAND_RIGHT_BOTH then
			if env(GetSpEffectID, 1721) == TRUE then
				IsEnableSpecialAttack = TRUE
				SetVariable("AttackRightHeavySpecialType", 0)
			end
		elseif c_Style == HAND_LEFT_BOTH and env(GetSpEffectID, 1723) == TRUE then
			IsEnableSpecialAttack = TRUE
			SetVariable("AttackRightHeavySpecialType", 0)
		end

		if c_Style == HAND_RIGHT_BOTH then
			if env(GetSpEffectID, 102101) == TRUE then
				IsEnableSpecialAttack = TRUE
				SetVariable("AttackRightHeavySpecialType", 0)
			end
		elseif c_Style == HAND_LEFT_BOTH and env(GetSpEffectID, 102106) == TRUE then
			IsEnableSpecialAttack = TRUE
			SetVariable("AttackRightHeavySpecialType", 0)
		end

		if IsEnableSpecialAttack == TRUE then
			if b2 == "W_AttackBothHeavy1Start" then
				b2 = "W_AttackBothHeavySpecial1Start"
			elseif b2 == "W_AttackBothHeavy1SubStart" then
				b2 = "W_AttackBothHeavySpecial1SubStart"
			elseif b2 == "W_AttackBothHeavy2Start" then
				b2 = "W_AttackBothHeavySpecial2Start"
			end
		end

		if env(GetSpEffectID, 1681) == FALSE and env(GetSpEffectID, 1686) == FALSE and env(GetSpEffectID, 1811) == FALSE
			and env(GetSpEffectID, 1816) == FALSE and env(GetSpEffectID, 19912) == TRUE then
			b2 = "W_AttackBothHeavy2Start"
		end
		if style == HAND_RIGHT_BOTH then
			atk_hand = HAND_RIGHT
		elseif style == HAND_LEFT_BOTH then
			atk_hand = HAND_LEFT
		end
		if env(GetEquipWeaponCategory, atk_hand) == WEAPON_CATEGORY_DUELING_SHIELD then
			guard_hand = atk_hand
		end

		ExecEventAllBody(b2)
	elseif request == ATTACK_REQUEST_DUAL_RIGHT then
		if r1 == "W_AttackRightLightDash" then
			l1 = "W_AttackDualDash"
		elseif r1 == "W_AttackRightLightStep" then
			l1 = "W_AttackDualRolling"
		elseif r1 == "W_AttackRightBackstep" then
			l1 = "W_AttackDualBackStep"
		elseif r1 == "W_AttackRightLightStealth" then
			if IsUseStealthAttack(TRUE) == FALSE then
				l1 = "W_AttackDualRolling"
			else
				l1 = "W_AttackDualStealth"
			end
		elseif l1 == "W_AttackLeftLight1" then
			l1 = "W_AttackDualLight1"
		elseif l1 == "W_AttackLeftLight2" then
			l1 = "W_AttackDualLight2"
		elseif l1 == "W_AttackLeftLight3" then
			l1 = "W_AttackDualLight3"
		elseif l1 == "W_AttackLeftLight4" then
			l1 = "W_AttackDualLight4"
		elseif l1 == "W_AttackLeftLight5" then
			l1 = "W_AttackDualLight5"
		elseif l1 == "W_AttackLeftLight6" then
			l1 = "W_AttackDualLight6"
		elseif l1 == "W_AttackDualLightSubStart" then
			l1 = "W_AttackDualLightSubStart"
		else
			l1 = "W_AttackDualLight1"
		end

		if env(GetSpEffectID, 19903) == TRUE then
			l1 = "W_AttackDualLight3"
		elseif env(GetSpEffectID, 19904) == TRUE then
			l1 = "W_AttackDualLight4"
		end

		if l1 == "W_AttackDualLightSubStart" then
			if env(GetSpEffectID, 135) == TRUE then
				SetVariable("AttackLightSubStartType", 0)
			else
				l1 = "W_AttackDualLight2"
			end
		end

		-- CUSTOM: Begin.
		if IsGuardPossible == TRUE then
			Action_Guard()

			l1 = ""
		end
		-- CUSTOM: End.

		is_Dual = TRUE
		ExecEventAllBody(l1)
	elseif request == ATTACK_REQUEST_ARROW_BOTH_RIGHT then
		if c_Style ~= HAND_RIGHT_BOTH and c_Style ~= HAND_LEFT_BOTH and ExecHandChange(HAND_RIGHT, TRUE, blend_type)
			== TRUE then
			return TRUE
		end
		return FALSE
	elseif request == ATTACK_REQUEST_ARROW_BOTH_LEFT then
		if c_Style ~= HAND_RIGHT_BOTH and c_Style ~= HAND_LEFT_BOTH and ExecHandChange(HAND_LEFT, TRUE, blend_type)
			== TRUE then
			return TRUE
		end
		return FALSE
	elseif request == ATTACK_REQUEST_LEFT_REVERSAL then
		ExecEventAllBody("W_AttackLeftReversal")
	elseif request == SWORDARTS_REQUEST_LEFT_NORMAL then
		SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)
		atk_hand = HAND_LEFT
		guard_hand = HAND_LEFT

		if IsAttackSwordArts(c_SwordArtsID) == FALSE then
			is_find_atk = FALSE
		end

		local idle_cat = env(GetStayAnimCategory)
		local wep_cat = env(GetEquipWeaponCategory, c_SwordArtsHand)
		local arts_cat = GetSwordArtsDiffCategory(c_SwordArtsID, idle_cat, wep_cat)
		local arts_idx = 0

		if arts_cat == SWORD_ART_DIFF_CAT_LARGE_WEAPON then
			arts_idx = 1
		elseif arts_cat == SWORD_ART_DIFF_CAT_POLEARM then
			arts_idx = 2
		elseif arts_cat == SWORD_ART_DIFF_CAT_LARGE_WEAPON_SMALL_SHIELD then
			arts_idx = 3
		elseif arts_cat == SWORD_ART_DIFF_CAT_POLEARM_SMALL_SHIELD then
			arts_idx = 4
		elseif arts_cat == SWORD_ART_DIFF_CAT_LARGE_WEAPON_LARGE_SHIELD then
			arts_idx = 5
		elseif arts_cat == SWORD_ART_DIFF_CAT_POLEARM_LARGE_SHIELD then
			arts_idx = 6
		elseif arts_cat == WEAPON_CATEGORY_SHORT_SWORD then
			arts_idx = 7
		elseif arts_cat == WEAPON_CATEGORY_CURVEDSWORD then
			arts_idx = 8
		elseif arts_cat == WEAPON_CATEGORY_LARGE_SHIELD then
			arts_idx = 9
		elseif arts_cat == WEAPON_CATEGORY_SMALL_SHIELD then
			arts_idx = 10
		elseif arts_cat == WEAPON_CATEGORY_DUELING_SHIELD then
			arts_idx = 11
		end

		SetVariable("SwordArtsOneShotShieldCategory", arts_idx)

		-- Torch Attack
		if c_SwordArtsID == 17 then
			SetVariable("SwordArtsOneShotComboCategory", 0)
		end

		if IsHalfBlendArts(c_SwordArtsID) == TRUE then
			ExecEventHalfBlend(Event_SwordArtsHalfOneShotShieldLeft, blend_type)
		else
			ExecEventAllBody("W_SwordArtsOneShotShieldLeft")
		end
	elseif request == SWORDARTS_REQUEST_BOTH_NORMAL then
		SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)

		if IsAttackSwordArts(c_SwordArtsID) == FALSE then
			is_find_atk = FALSE
		end

		local idle_cat = env(GetStayAnimCategory)
		local wep_cat = env(GetEquipWeaponCategory, c_SwordArtsHand)
		local arts_cat = GetSwordArtsDiffCategory(c_SwordArtsID, idle_cat, wep_cat)

		if IsHalfBlendArts(c_SwordArtsID) == TRUE and c_SwordArtsID ~= 334 and c_SwordArtsID ~= 354 and c_SwordArtsID
			~= 355 then
			if c_SwordArtsHand == HAND_LEFT then
				local arts_idx = 0

				if arts_cat == SWORD_ART_DIFF_CAT_LARGE_WEAPON then
					arts_idx = 1
				elseif arts_cat == SWORD_ART_DIFF_CAT_POLEARM then
					arts_idx = 2
				elseif arts_cat == SWORD_ART_DIFF_CAT_LARGE_WEAPON_SMALL_SHIELD then
					arts_idx = 3
				elseif arts_cat == SWORD_ART_DIFF_CAT_POLEARM_SMALL_SHIELD then
					arts_idx = 4
				elseif arts_cat == SWORD_ART_DIFF_CAT_LARGE_WEAPON_LARGE_SHIELD then
					arts_idx = 5
				elseif arts_cat == SWORD_ART_DIFF_CAT_POLEARM_LARGE_SHIELD then
					arts_idx = 6
				elseif arts_cat == WEAPON_CATEGORY_SHORT_SWORD then
					arts_idx = 7
				elseif arts_cat == WEAPON_CATEGORY_CURVEDSWORD then
					arts_idx = 8
				elseif arts_cat == WEAPON_CATEGORY_LARGE_SHIELD then
					arts_idx = 9
				elseif arts_cat == WEAPON_CATEGORY_SMALL_SHIELD then
					arts_idx = 10
				elseif arts_cat == WEAPON_CATEGORY_DUELING_SHIELD then
					arts_idx = 11
				end

				SetVariable("SwordArtsOneShotShieldCategory", arts_idx)
				ExecEventHalfBlend(Event_SwordArtsHalfOneShotShieldLeft, blend_type)
			else
				local arts_idx = 0

				if arts_cat == SWORD_ART_DIFF_CAT_LARGE_WEAPON then
					arts_idx = 1
				elseif arts_cat == SWORD_ART_DIFF_CAT_POLEARM then
					arts_idx = 2
				elseif arts_cat == WEAPON_CATEGORY_SHORT_SWORD or arts_cat == WEAPON_CATEGORY_THROW_DAGGER then
					arts_idx = 3
				elseif arts_cat == WEAPON_CATEGORY_TWINBLADE then
					arts_idx = 4
				elseif arts_cat == WEAPON_CATEGORY_CURVEDSWORD then
					arts_idx = 5
				elseif arts_cat == WEAPON_CATEGORY_FIST or arts_cat == WEAPON_CATEGORY_MARTIAL_ARTS or arts_cat
					== WEAPON_CATEGORY_PERFUME_BOTTLE or arts_cat == WEAPON_CATEGORY_BEAST_CLAW then
					arts_idx = 6
				elseif arts_cat == WEAPON_CATEGORY_LARGE_SHIELD then
					arts_idx = 7
				elseif arts_cat == WEAPON_CATEGORY_SMALL_SHIELD then
					arts_idx = 8
				elseif arts_cat == WEAPON_CATEGORY_BACKHAND_SWORD then
					arts_idx = 9
				elseif arts_cat == WEAPON_CATEGORY_DUELING_SHIELD then
					arts_idx = 10
				end

				SetVariable("SwordArtsOneShotCategory", arts_idx)
				ExecEventHalfBlend(Event_SwordArtsHalfOneShot, blend_type)
			end
		else
			local arts_idx = 0

			if arts_cat == WEAPON_CATEGORY_SHORT_SWORD then
				arts_idx = 1
			elseif arts_cat == WEAPON_CATEGORY_CURVEDSWORD then
				arts_idx = 2
			elseif arts_cat == WEAPON_CATEGORY_LARGE_SHIELD then
				arts_idx = 3
			elseif arts_cat == WEAPON_CATEGORY_SMALL_SHIELD then
				arts_idx = 4
			elseif arts_cat == WEAPON_CATEGORY_DUELING_SHIELD then
				arts_idx = 5
			end

			SetVariable("SwordArtsOneShotShieldCategory", arts_idx)
			if IsHalfBlendArts(c_SwordArtsID) == TRUE then
				ExecEventHalfBlend(Event_SwordArtsHalfOneShotShieldBoth, blend_type)
			else
				ExecEventAllBody("W_SwordArtsOneShotShieldBoth")
			end
		end
	elseif request == SWORDARTS_REQUEST_RIGHT_NORMAL then
		SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)

		if IsAttackSwordArts(c_SwordArtsID) == FALSE then
			is_find_atk = FALSE
		end

		local idle_cat = env(GetStayAnimCategory)
		local wep_cat = env(GetEquipWeaponCategory, c_SwordArtsHand)
		local arts_cat = GetSwordArtsDiffCategory(c_SwordArtsID, idle_cat, wep_cat)
		local arts_idx = 0

		if arts_cat == SWORD_ART_DIFF_CAT_LARGE_WEAPON or arts_cat == WEAPON_CATEGORY_LARGE_KATANA then
			arts_idx = 1
		elseif arts_cat == SWORD_ART_DIFF_CAT_POLEARM then
			arts_idx = 2
		elseif arts_cat == WEAPON_CATEGORY_SHORT_SWORD or arts_cat == WEAPON_CATEGORY_THROW_DAGGER then
			arts_idx = 3
		elseif arts_cat == WEAPON_CATEGORY_TWINBLADE then
			arts_idx = 4
		elseif arts_cat == WEAPON_CATEGORY_CURVEDSWORD then
			arts_idx = 5
		elseif arts_cat == WEAPON_CATEGORY_FIST or arts_cat == WEAPON_CATEGORY_MARTIAL_ARTS or arts_cat
			== WEAPON_CATEGORY_PERFUME_BOTTLE or arts_cat == WEAPON_CATEGORY_BEAST_CLAW then
			arts_idx = 6
		elseif arts_cat == WEAPON_CATEGORY_LARGE_SHIELD then
			arts_idx = 7
		elseif arts_cat == WEAPON_CATEGORY_SMALL_SHIELD then
			arts_idx = 8
		elseif arts_cat == WEAPON_CATEGORY_BACKHAND_SWORD then
			arts_idx = 9
		elseif arts_cat == WEAPON_CATEGORY_DUELING_SHIELD then
			arts_idx = 10
		elseif c_SwordArtsID == 328 and env(GetSpEffectID, 19875) == TRUE and GetVariable("IsEnoughArtPointsL2") == 0 then
			arts_idx = 12
		elseif c_SwordArtsID == 328 and env(GetSpEffectID, 19874) == TRUE and GetVariable("IsEnoughArtPointsL2") == 0 then
			arts_idx = 11
		end

		SetVariable("SwordArtsOneShotCategory", arts_idx)
		local combo_idx = 0

		if arts_cat == SWORD_ART_DIFF_CAT_LARGE_WEAPON then
			combo_idx = 1
		elseif arts_cat == SWORD_ART_DIFF_CAT_POLEARM then
			combo_idx = 2
		elseif arts_cat == WEAPON_CATEGORY_TWINBLADE then
			combo_idx = 3
		elseif arts_cat == WEAPON_CATEGORY_CURVEDSWORD or arts_cat == WEAPON_CATEGORY_MARTIAL_ARTS or arts_cat
			== WEAPON_CATEGORY_BEAST_CLAW then
			combo_idx = 4
		elseif arts_cat == WEAPON_CATEGORY_BACKHAND_SWORD then
			combo_idx = 5
		elseif arts_cat == WEAPON_CATEGORY_DUELING_SHIELD then
			combo_idx = 6
		end

		SetVariable("SwordArtsOneShotComboCategory", combo_idx)
		SetVariable("SwordArtsSubCategory", 0)

		if c_SwordArtsID == 261 then
			if env(GetSpEffectID, 102355) == TRUE then
				SetVariable("SwordArtsSubCategory", 0)
				ExecEventAllBody("W_SwordArtsOneShot_Sub")
			elseif env(GetSpEffectID, 102356) == TRUE then
				SetVariable("SwordArtsSubCategory", 1)
				ExecEventAllBody("W_SwordArtsOneShot_Sub")
			else
				ExecEventAllBody("W_SwordArtsOneShot")
			end
		elseif IsHalfBlendArts(c_SwordArtsID) == TRUE then
			ExecEventHalfBlend(Event_SwordArtsHalfOneShot, blend_type)
		else
			ExecEventAllBody("W_SwordArtsOneShot")
		end
	elseif request == SWORDARTS_REQUEST_RIGHT_STEP then
		act(DebugLogOutput, "SwordArtsRolling request" .. request)

		if IsAttackSwordArts(c_SwordArtsID) == FALSE then
			is_find_atk = FALSE
		end

		local rollingAngle = c_ArtsRollingAngle

		if GetVariable("MoveSpeedLevel") > 0.20000000298023224 then
			rollingAngle = GetVariable("MoveAngle")
		end

		local turn_target_angle = 0
		local rollingDirection = 0
		local turn_angle_real = 200
		local is_self_trans = FALSE
		local is_self_trans_2 = FALSE
		local arts_id = c_SwordArtsID
		if IsNodeActive("SwordArtsRolling Selector MP") == TRUE
			or IsNodeActive("SwordArtsRolling Selector MP_SelfTrans2") == TRUE then
			is_self_trans = TRUE
		elseif (arts_id == 155 or arts_id == 156)
			and (IsNodeActive("SwordArtsRolling Selector MP_SelfTrans") == TRUE or env(GetSpEffectID, 100710) == TRUE) then
			is_self_trans_2 = TRUE
		end

		if GetVariable("IsLockon") == false and env(IsPrecisionShoot) == FALSE and env(IsCOMPlayer) == FALSE
			or env(GetSpEffectID, 100002) == TRUE then
			rollingDirection = 0
		else
			if rollingAngle <= GetVariable("RollingAngleThresholdRightFrontTest") and rollingAngle
				>= GetVariable("RollingAngleThresholdLeftFrontTest") then
				rollingDirection = 0
				turn_target_angle = rollingAngle
			elseif rollingAngle > GetVariable("RollingAngleThresholdRightFrontTest") and rollingAngle
				< GetVariable("RollingAngleThresholdRightBackTest") then
				rollingDirection = 3
				turn_target_angle = rollingAngle - 90
			elseif rollingAngle < GetVariable("RollingAngleThresholdLeftFrontTest") and rollingAngle
				> GetVariable("RollingAngleThresholdLeftBackTest") then
				rollingDirection = 2
				turn_target_angle = rollingAngle + 90
			else
				rollingDirection = 1
				turn_target_angle = rollingAngle - 180
			end

			if arts_id == 276 then
				if rollingAngle <= 0 and rollingAngle >= -180 then
					rollingDirection = 2
					turn_target_angle = rollingAngle + 90
				elseif rollingAngle > 0 and rollingAngle < 180 then
					rollingDirection = 3
					turn_target_angle = rollingAngle - 90
				else
					rollingDirection = 2
					turn_target_angle = rollingAngle + 90
				end
			end

			if arts_id == 313 then
				if GetVariable("MoveSpeedLevel") < 0.20000000298023224 then
					rollingDirection = 0
					turn_target_angle = rollingAngle
				elseif rollingAngle <= 0 and rollingAngle >= -120 then
					rollingDirection = 2
					turn_target_angle = rollingAngle + 90
				elseif rollingAngle > 0 and rollingAngle < 120 then
					rollingDirection = 3
					turn_target_angle = rollingAngle - 90
				else
					rollingDirection = 1
					turn_target_angle = rollingAngle - 180
				end
			end

			turn_angle_real = math.abs(GetVariable("TurnAngle") - rollingAngle)

			if turn_angle_real > 180 then
				turn_angle_real = 360 - turn_angle_real
			end

			if arts_id ~= 276 then
				if GetVariable("IsLockon") == true then
					act(TurnToLockonTargetImmediately, turn_target_angle)
				else
					act(FaceDirection, turn_target_angle)
				end
			end
		end

		if is_self_trans == TRUE then
			if arts_id == 155 or arts_id == 156 then
				SetVariable("SwordArtsRollingArtsCategory", 0)
			else
				SetVariable("SwordArtsRollingArtsCategory", 1)
			end
			SetVariable("SwordArtsRollingDirection_SelfTrans", rollingDirection)
			SetVariable("RollingAngleRealSelftrans", rollingAngle)
		elseif is_self_trans_2 == TRUE then
			SetVariable("SwordArtsRollingDirection_SelfTrans2", rollingDirection)
			SetVariable("RollingAngleReal", rollingAngle)
		else
			SetVariable("SwordArtsRollingDirection", rollingDirection)
			SetVariable("RollingAngleReal", rollingAngle)
		end

		SetVariable("TurnAngleReal", turn_angle_real)
		SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)

		if env(GetSpEffectID, 102360) == FALSE and arts_id ~= 313 then
			if GetVariable("IsEnoughArtPointsL2") == 1 then
				AddStamina(STAMINA_REDUCE_ARTS_QUICKSTEP * STAMINA_CONSUMERATE_LOWSTATUS)
			else
				AddStamina(STAMINA_REDUCE_ARTS_QUICKSTEP)
			end
		end
		local arts_idx = 0
		if arts_id == 155 or arts_id == 156 then
			SetWeightIndex()
			if GetVariable("EvasionWeightIndex") == MOVE_WEIGHT_LIGHT then
				arts_idx = 1
			end
		end
		SetVariable("SwordArtsRollingWeightCategory", arts_idx)
		act(AddSpEffect, 100710)
		if is_self_trans == TRUE then
			ExecEventAllBody("W_SwordArtsRolling_SelfTrans")
		elseif is_self_trans_2 == TRUE then
			ExecEventAllBody("W_SwordArtsRolling_SelfTrans2")
		elseif (arts_id == 276 or arts_id == 313) and GetVariable("IsLockon") == true and env(GetSpEffectID, 100002)
			== TRUE then
			ExecEventAllBody("W_SwordArtsRolling_Sub")
		else
			ExecEventAllBody("W_SwordArtsRolling")
		end
	elseif request == SWORDARTS_REQUEST_RIGHT_COMBO_1 then
		if IsAttackSwordArts(c_SwordArtsID) == FALSE then
			is_find_atk = FALSE
		end

		SetSwordArtsPointInfo(ACTION_ARM_R2, TRUE)

		if IsHalfBlendArts(c_SwordArtsID) == TRUE then
			ExecEventHalfBlend(Event_SwordArtsHalfOneShotCombo1, blend_type)
		else
			ExecEventAllBody("W_SwordArtsOneShotComboEnd")
		end
	elseif request == SWORDARTS_REQUEST_RIGHT_COMBO_2 then
		if IsAttackSwordArts(c_SwordArtsID) == FALSE then
			is_find_atk = FALSE
		end

		SetSwordArtsPointInfo(ACTION_ARM_R2, TRUE, "W_SwordArtsOneShotComboEnd_2")

		if IsHalfBlendArts(c_SwordArtsID) == TRUE then
			ExecEventHalfBlend(Event_SwordArtsHalfOneShotCombo2, blend_type)
		else
			ExecEventAllBody("W_SwordArtsOneShotComboEnd_2")
		end
	elseif request == ATTACK_REQUEST_ARROW_FIRE_RIGHT or request == ATTACK_REQUEST_ARROW_FIRE_RIGHT2 then
		is_find_atk = FALSE

		if env(IsOutOfAmmo, 1) == TRUE then
			ExecEventAllBody("W_NoArrow")
		elseif env(GetEquipWeaponCategory, HAND_RIGHT) == WEAPON_CATEGORY_LARGE_ARROW then
			ExecEventHalfBlend(Event_AttackArrowRightStart, ALLBODY)
		elseif GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_SMALL_ARROW) == TRUE
			and (c_IsStealth == FALSE and r1 == "W_AttackRightLightStep" or is_stealth_rolling == TRUE or r1
				== "W_AttackRightLightDash" or r1 == "W_AttackRightBackstep") then
			ExecEventAllBody("W_AttackArrowRightFireStep")
		elseif c_IsStealth == TRUE then
			ExecEventHalfBlend(Event_StealthAttackArrowStart, ALLBODY)
		else
			ExecEventHalfBlend(Event_AttackArrowRightStart, blend_type)
		end
	elseif request == ATTACK_REQUEST_ARROW_FIRE_LEFT or request == ATTACK_REQUEST_ARROW_FIRE_LEFT2 then
		is_find_atk = FALSE

		if env(IsOutOfAmmo, 0) == TRUE then
			ExecEventAllBody("W_NoArrow")
		elseif env(GetEquipWeaponCategory, HAND_LEFT) == WEAPON_CATEGORY_LARGE_ARROW then
			ExecEventHalfBlend(Event_AttackArrowLeftStart, ALLBODY)
		elseif GetEquipType(HAND_LEFT, WEAPON_CATEGORY_SMALL_ARROW) == TRUE
			and (c_IsStealth == FALSE and r1 == "W_AttackRightLightStep" or is_stealth_rolling == TRUE or r1
				== "W_AttackRightLightDash" or r1 == "W_AttackRightBackstep") then
			ExecEventAllBody("W_AttackArrowLeftFireStep")
		elseif c_IsStealth == TRUE then
			ExecEventHalfBlend(Event_StealthAttackArrowStart, ALLBODY)
		else
			ExecEventHalfBlend(Event_AttackArrowLeftStart, blend_type)
		end
	elseif request == ATTACK_REQUEST_RIGHT_CROSSBOW or request == ATTACK_REQUEST_RIGHT_CROSSBOW2 then
		is_find_atk = FALSE

		if blend_type == ALLBODY then
			local move_event = Event_Move

			if c_IsStealth == TRUE then
				move_event = Event_Stealth_Move
			end

			if MoveStart(LOWER, move_event, FALSE) == TRUE then
				blend_type = UPPER
			end
		end

		local crossbowHand = HAND_RIGHT

		if c_Style == HAND_LEFT_BOTH then
			crossbowHand = HAND_LEFT
		end

		if env(IsOutOfAmmo, 1) == TRUE then
			if c_IsStealth == TRUE and GetEquipType(crossbowHand, WEAPON_CATEGORY_BALLISTA) == FALSE then
				ExecEventHalfBlend(Event_StealthAttackCrossbowRightEmpty, blend_type)
			else
				ExecEventHalfBlend(Event_AttackCrossbowRightEmpty, blend_type)
			end
		elseif env(GetBoltLoadingState, 1) == FALSE and GetEquipType(crossbowHand, WEAPON_CATEGORY_BALLISTA) == FALSE then
			if c_IsStealth == TRUE then
				ExecEventHalfBlend(Event_StealthAttackCrossbowRightReload, blend_type)
			else
				ExecEventHalfBlend(Event_AttackCrossbowRightReload, blend_type)
			end
		elseif c_IsStealth == TRUE and GetEquipType(crossbowHand, WEAPON_CATEGORY_BALLISTA) == FALSE then
			ExecEventHalfBlend(Event_StealthAttackCrossbowRightStart, blend_type)
		else
			ExecEventHalfBlend(Event_AttackCrossbowRightStart, blend_type)
		end
	elseif request == ATTACK_REQUEST_LEFT_CROSSBOW or request == ATTACK_REQUEST_LEFT_CROSSBOW2 then
		is_find_atk = FALSE
		atk_hand = HAND_LEFT
		guard_hand = HAND_LEFT

		if blend_type == ALLBODY then
			local move_event = Event_Move

			if c_IsStealth == TRUE and GetEquipType(HAND_LEFT, WEAPON_CATEGORY_BALLISTA) == FALSE then
				move_event = Event_Stealth_Move
			end

			if MoveStart(LOWER, move_event, FALSE) == TRUE then
				blend_type = UPPER
			end
		end

		if env(IsOutOfAmmo, 0) == TRUE then
			if c_IsStealth == TRUE and GetEquipType(HAND_LEFT, WEAPON_CATEGORY_BALLISTA) == FALSE then
				ExecEventHalfBlend(Event_StealthAttackCrossbowLeftEmpty, blend_type)
			else
				ExecEventHalfBlend(Event_AttackCrossbowLeftEmpty, blend_type)
			end
		elseif env(GetBoltLoadingState, 0) == FALSE and GetEquipType(HAND_LEFT, WEAPON_CATEGORY_BALLISTA) == FALSE then
			if c_IsStealth == TRUE then
				ExecEventHalfBlend(Event_StealthAttackCrossbowLeftReload, blend_type)
			else
				ExecEventHalfBlend(Event_AttackCrossbowLeftReload, blend_type)
			end
		elseif c_IsStealth == TRUE and GetEquipType(HAND_LEFT, WEAPON_CATEGORY_BALLISTA) == FALSE then
			ExecEventHalfBlend(Event_StealthAttackCrossbowLeftStart, blend_type)
		else
			ExecEventHalfBlend(Event_AttackCrossbowLeftStart, blend_type)
		end
	elseif request == ATTACK_REQUEST_BOTHRIGHT_CROSSBOW or request == ATTACK_REQUEST_BOTHRIGHT_CROSSBOW2 then
		is_find_atk = FALSE

		if blend_type == ALLBODY then
			local move_event = Event_Move

			if c_IsStealth == TRUE then
				move_event = Event_Stealth_Move
			end

			if MoveStart(LOWER, move_event, FALSE) == TRUE then
				blend_type = UPPER
			end
		end

		local arrowHand = 0

		if c_Style == HAND_RIGHT_BOTH then
			arrowHand = 1
		end

		if env(IsOutOfAmmo, arrowHand) == TRUE then
			if c_IsStealth == TRUE and GetEquipType(arrowHand, WEAPON_CATEGORY_BALLISTA) == FALSE then
				ExecEventHalfBlend(Event_StealthAttackCrossbowBothRightEmpty, blend_type)
			else
				ExecEventHalfBlend(Event_AttackCrossbowBothRightEmpty, blend_type)
			end
		elseif env(GetBoltLoadingState, arrowHand) == FALSE and GetEquipType(arrowHand, WEAPON_CATEGORY_BALLISTA)
			== FALSE then
			local reloadEvent = Event_AttackCrossbowBothRightReload

			if c_IsStealth == TRUE then
				if c_Style == HAND_LEFT_BOTH then
					reloadEvent = Event_StealthAttackCrossbowBothLeftReload
				else
					reloadEvent = Event_StealthAttackCrossbowBothRightReload
				end
			elseif c_Style == HAND_LEFT_BOTH then
				reloadEvent = Event_AttackCrossbowBothLeftReload
			else
				reloadEvent = Event_AttackCrossbowBothRightReload
			end
			ExecEventHalfBlend(reloadEvent, blend_type)
		elseif c_IsStealth == TRUE and GetEquipType(arrowHand, WEAPON_CATEGORY_BALLISTA) == FALSE then
			ExecEventHalfBlend(Event_StealthAttackCrossbowBothRightStart, blend_type)
		else
			ExecEventHalfBlend(Event_AttackCrossbowBothRightStart, blend_type)
		end
	elseif request == ATTACK_REQUEST_BOTHLEFT_CROSSBOW or request == ATTACK_REQUEST_BOTHLEFT_CROSSBOW2 then
		is_find_atk = FALSE

		if blend_type == ALLBODY then
			local move_event = Event_Move

			if c_IsStealth == TRUE then
				move_event = Event_Stealth_Move
			end

			if MoveStart(LOWER, move_event, FALSE) == TRUE then
				blend_type = UPPER
			end
		end

		if env(IsOutOfAmmo, 0) == TRUE then
			if c_IsStealth == TRUE and GetEquipType(HAND_LEFT, WEAPON_CATEGORY_BALLISTA) == FALSE then
				ExecEventHalfBlend(Event_StealthAttackCrossbowBothLeftEmpty, blend_type)
			else
				ExecEventHalfBlend(Event_AttackCrossbowBothLeftEmpty, blend_type)
			end
		elseif env(GetBoltLoadingState, 0) == FALSE and GetEquipType(HAND_LEFT, WEAPON_CATEGORY_BALLISTA) == FALSE then
			if c_IsStealth == TRUE then
				ExecEventHalfBlend(Event_AttackCrossbowBothLeftReload, blend_type)
			else
				ExecEventHalfBlend(Event_AttackCrossbowBothLeftReload, blend_type)
			end
		elseif c_IsStealth == TRUE and GetEquipType(HAND_LEFT, WEAPON_CATEGORY_BALLISTA) == FALSE then
			ExecEventHalfBlend(Event_StealthAttackCrossbowBothLeftStart, blend_type)
		else
			ExecEventHalfBlend(Event_AttackCrossbowBothLeftStart, blend_type)
		end
	elseif request == ATTACK_REQUEST_ATTACK_WHILE_GUARD then
		guard_hand = HAND_LEFT
		local index = env(GetGuardMotionCategory, HAND_LEFT)

		if env(GetEquipWeaponCategory, HAND_LEFT) == WEAPON_CATEGORY_DUELING_SHIELD then
			index = 3
		end

		if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_TORCH) == TRUE then
			index = 2
			SetVariable("IsAttackWhileTorchGuard", TRUE)
		else
			SetVariable("IsAttackWhileTorchGuard", FALSE)
		end

		SetVariable("IndexAttackWhileGuard", index)
		ExecEventAllBody("W_AttackRightWhileGuard")
	else
		return FALSE
	end

	if is_find_atk == TRUE then
		SetInterruptType(INTERRUPT_FINDATTACK)
	end

	if style == HAND_RIGHT_BOTH then
		atk_hand = HAND_RIGHT
	elseif style == HAND_LEFT_BOTH then
		atk_hand = HAND_LEFT
	end

	SetAttackHand(atk_hand)
	SetGuardHand(guard_hand)

	if is_Dual == TRUE then
		act(SetThrowPossibilityState_Defender, 400000)
	end

	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()

	return TRUE
end

-- Checks the max combo length
function IsEnableNextAttack(cur_attack_num, hand)
	local style = c_Style

	if style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end

	local max_num = GetAttackMaxNumber(hand)
	DebugPrint(3, env(GetEquipWeaponCategory, hand))
	DebugPrint(4, max_num)
	DebugPrint(5, cur_attack_num)

	if cur_attack_num < max_num then
		return TRUE
	else
		return FALSE
	end
end

-- Get the maximum supported combo length for each type
function GetAttackMaxNumber(hand)
	local kind = env(GetEquipWeaponCategory, hand)
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, hand)
	local max_num = 1

	if sp_kind == 249 then
		if c_Style == HAND_LEFT_BOTH or c_Style == HAND_RIGHT_BOTH then
			max_num = 4
		elseif hand == HAND_LEFT then
			max_num = 5
		else
			max_num = 5
		end
		return max_num
	end

	if sp_kind == 255 then
		if c_Style == HAND_LEFT_BOTH or c_Style == HAND_RIGHT_BOTH then
			max_num = 4
		elseif hand == HAND_LEFT then
			max_num = 6
		else
			max_num = 6
		end
		return max_num
	end

	if sp_kind == 257 then
		if c_Style == HAND_LEFT_BOTH or c_Style == HAND_RIGHT_BOTH then
			max_num = 4
		elseif hand == HAND_LEFT then
			max_num = 6
		else
			max_num = 6
		end
		return max_num
	end

	if sp_kind == 258 then
		if c_Style == HAND_LEFT_BOTH or c_Style == HAND_RIGHT_BOTH then
			max_num = 4
		elseif hand == HAND_LEFT then
			max_num = 5
		else
			max_num = 5
		end
		return max_num
	end

	if kind == WEAPON_CATEGORY_ARROW or kind == WEAPON_CATEGORY_LARGE_ARROW or kind == WEAPON_CATEGORY_CROSSBOW or kind
		== WEAPON_CATEGORY_SMALL_ARROW then
		max_num = 1
	elseif kind == WEAPON_CATEGORY_EXTRALARGE_SWORD or kind == WEAPON_CATEGORY_EXTRALARGE_AXHAMMER or kind
		== WEAPON_CATEGORY_LARGE_SPEAR or kind == WEAPON_CATEGORY_LARGE_SHIELD or kind == WEAPON_CATEGORY_STAFF then
		max_num = 3
	elseif kind == WEAPON_CATEGORY_TORCH or kind == WEAPON_CATEGORY_LARGE_SWORD or kind == WEAPON_CATEGORY_FLAIL or kind
		== WEAPON_CATEGORY_LARGE_AX or kind == WEAPON_CATEGORY_LARGE_HAMMER or kind == WEAPON_CATEGORY_SPEAR or kind
		== WEAPON_CATEGORY_HALBERD or kind == WEAPON_CATEGORY_LARGE_CURVEDSWORD or kind == WEAPON_CATEGORY_SMALL_SHIELD
		or kind == WEAPON_CATEGORY_MIDDLE_SHIELD or kind == WEAPON_CATEGORY_LARGE_SCYTHE or kind == WEAPON_CATEGORY_WHIP
		or kind == WEAPON_CATEGORY_PERFUME_BOTTLE or kind == WEAPON_CATEGORY_DUELING_SHIELD or kind
		== WEAPON_CATEGORY_LARGE_KATANA or kind == WEAPON_CATEGORY_BEAST_CLAW then
		max_num = 4
	elseif kind == WEAPON_CATEGORY_STRAIGHT_SWORD or kind == WEAPON_CATEGORY_TWINBLADE or kind == WEAPON_CATEGORY_KATANA
		or kind == WEAPON_CATEGORY_AX or kind == WEAPON_CATEGORY_HAMMER or kind == WEAPON_CATEGORY_LARGE_RAPIER or kind
		== WEAPON_CATEGORY_LIGHT_LARGE_SWORD then
		max_num = 5
	elseif kind == WEAPON_CATEGORY_SHORT_SWORD or kind == WEAPON_CATEGORY_CLAW or kind == WEAPON_CATEGORY_RAPIER or kind
		== WEAPON_CATEGORY_CURVEDSWORD or kind == WEAPON_CATEGORY_FIST or kind == WEAPON_CATEGORY_MARTIAL_ARTS or kind
		== WEAPON_CATEGORY_THROW_DAGGER or kind == WEAPON_CATEGORY_BACKHAND_SWORD then
		max_num = 6
	end

	return max_num
end

-- Get the maximum supported combo length for each dual type
function GetDualAttackMaxNumber(hand)
	local kind = env(GetEquipWeaponCategory, hand)
	local max_num = 1

	if kind == WEAPON_CATEGORY_EXTRALARGE_SWORD or kind == WEAPON_CATEGORY_EXTRALARGE_AXHAMMER or kind
		== WEAPON_CATEGORY_LARGE_SPEAR or kind == WEAPON_CATEGORY_LARGE_SWORD or kind == WEAPON_CATEGORY_LARGE_AX or kind
		== WEAPON_CATEGORY_LARGE_HAMMER or kind == WEAPON_CATEGORY_SPEAR or kind == WEAPON_CATEGORY_HALBERD or kind
		== WEAPON_CATEGORY_LARGE_CURVEDSWORD or kind == WEAPON_CATEGORY_LARGE_SCYTHE or kind == WEAPON_CATEGORY_WHIP
		or kind == WEAPON_CATEGORY_LARGE_KATANA then
		max_num = 3
	elseif kind == WEAPON_CATEGORY_STRAIGHT_SWORD or kind == WEAPON_CATEGORY_TWINBLADE or kind == WEAPON_CATEGORY_KATANA
		or kind == WEAPON_CATEGORY_AX or kind == WEAPON_CATEGORY_HAMMER or kind == WEAPON_CATEGORY_FLAIL or kind
		== WEAPON_CATEGORY_LARGE_RAPIER or kind == WEAPON_CATEGORY_SHORT_SWORD or kind == WEAPON_CATEGORY_RAPIER or kind
		== WEAPON_CATEGORY_CURVEDSWORD or kind == WEAPON_CATEGORY_PERFUME_BOTTLE or kind
		== WEAPON_CATEGORY_DUELING_SHIELD or kind == WEAPON_CATEGORY_LIGHT_LARGE_SWORD or kind
		== WEAPON_CATEGORY_BEAST_CLAW then
		max_num = 4
	elseif kind == WEAPON_CATEGORY_CLAW or kind == WEAPON_CATEGORY_FIST or kind == WEAPON_CATEGORY_THROW_DAGGER or kind
		== WEAPON_CATEGORY_MARTIAL_ARTS or kind == WEAPON_CATEGORY_BACKHAND_SWORD then
		max_num = 6
	end

	return max_num
end

function IsEnableSpecialAttack(hand)
	local style = c_Style

	if style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end

	local kind = env(GetEquipWeaponCategory, hand)
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT)

	if sp_kind == 254 or sp_kind == 251 then
		return TRUE
	end

	if GetEquipType(hand, WEAPON_CATEGORY_RAPIER, WEAPON_CATEGORY_CURVEDSWORD, WEAPON_CATEGORY_LARGE_RAPIER,
		WEAPON_CATEGORY_BEAST_CLAW, WEAPON_CATEGORY_THROW_DAGGER, WEAPON_CATEGORY_LARGE_KATANA,
		WEAPON_CATEGORY_PERFUME_BOTTLE) == TRUE then
		return TRUE
	else
		return FALSE
	end
end

function IsEnableDualWielding()
	if c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH then
		return -1
	end

	local rightKind = env(GetEquipWeaponCategory, HAND_RIGHT)
	local leftKind = env(GetEquipWeaponCategory, HAND_LEFT)
	local rightSpecialKind = env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT)
	local leftSpecialKind = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)

	if rightKind == WEAPON_CATEGORY_SHORT_SWORD then
		if rightSpecialKind == 104 then
			if leftSpecialKind == 104 then
				return HAND_RIGHT
			end
		elseif rightSpecialKind == 262 then
			if leftSpecialKind == 262 then
				return HAND_RIGHT
			end
		elseif leftKind == WEAPON_CATEGORY_SHORT_SWORD and leftSpecialKind ~= 104 and leftSpecialKind ~= 262 then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_CLAW then
		if leftKind == WEAPON_CATEGORY_CLAW then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_STRAIGHT_SWORD then
		if leftKind == WEAPON_CATEGORY_STRAIGHT_SWORD then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_TWINBLADE then
		if leftKind == WEAPON_CATEGORY_TWINBLADE then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_LARGE_SWORD then
		if leftKind == WEAPON_CATEGORY_LARGE_SWORD then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_EXTRALARGE_SWORD then
		if leftKind == WEAPON_CATEGORY_EXTRALARGE_SWORD then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_RAPIER then
		if leftKind == WEAPON_CATEGORY_RAPIER or leftSpecialKind == 262 then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_CURVEDSWORD then
		if leftKind == WEAPON_CATEGORY_CURVEDSWORD then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_KATANA then
		if leftKind == WEAPON_CATEGORY_KATANA or leftSpecialKind == 104 then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_HAMMER then
		if leftKind == WEAPON_CATEGORY_HAMMER then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_AX then
		if leftKind == WEAPON_CATEGORY_AX then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_EXTRALARGE_AXHAMMER then
		if leftKind == WEAPON_CATEGORY_EXTRALARGE_AXHAMMER then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_LARGE_AX then
		if leftKind == WEAPON_CATEGORY_LARGE_AX then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_LARGE_HAMMER then
		if leftKind == WEAPON_CATEGORY_LARGE_HAMMER then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_FLAIL then
		if leftKind == WEAPON_CATEGORY_FLAIL then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_SPEAR then
		if leftKind == WEAPON_CATEGORY_SPEAR then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_LARGE_SPEAR then
		if leftKind == WEAPON_CATEGORY_LARGE_SPEAR then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_LARGE_RAPIER then
		if leftKind == WEAPON_CATEGORY_LARGE_RAPIER then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_HALBERD then
		if leftKind == WEAPON_CATEGORY_HALBERD then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_LARGE_CURVEDSWORD then
		if leftKind == WEAPON_CATEGORY_LARGE_CURVEDSWORD then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_FIST then
		if leftKind == WEAPON_CATEGORY_FIST then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_WHIP then
		if leftKind == WEAPON_CATEGORY_WHIP then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_LARGE_SCYTHE then
		if leftKind == WEAPON_CATEGORY_LARGE_SCYTHE then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_THROW_DAGGER then
		if leftKind == WEAPON_CATEGORY_THROW_DAGGER then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_MARTIAL_ARTS then
		if leftKind == WEAPON_CATEGORY_MARTIAL_ARTS then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_PERFUME_BOTTLE then
		if leftKind == WEAPON_CATEGORY_PERFUME_BOTTLE then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_DUELING_SHIELD then
		return -1
	elseif rightKind == WEAPON_CATEGORY_BACKHAND_SWORD then
		if leftKind == WEAPON_CATEGORY_BACKHAND_SWORD then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_LIGHT_LARGE_SWORD then
		if leftKind == WEAPON_CATEGORY_LIGHT_LARGE_SWORD then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_LARGE_KATANA then
		if leftKind == WEAPON_CATEGORY_LARGE_KATANA then
			return HAND_RIGHT
		end
	elseif rightKind == WEAPON_CATEGORY_BEAST_CLAW and leftKind == WEAPON_CATEGORY_BEAST_CLAW then
		return HAND_RIGHT
	end

	return -1
end

function IsUseStealthAttack(is_dual)
	-- 110 Broadsword
	-- 182 Morning Star
	-- 207 Serpent-Hunter
	-- 832 Starscourge Greatsword
	-- 852 Ornamental Straight Sword

	if is_dual == TRUE then
		if GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_STRAIGHT_SWORD, WEAPON_CATEGORY_TWINBLADE, WEAPON_CATEGORY_RAPIER,
			WEAPON_CATEGORY_CURVEDSWORD, WEAPON_CATEGORY_SPEAR, WEAPON_CATEGORY_LARGE_SPEAR, WEAPON_CATEGORY_BACKHAND_SWORD) == TRUE then
			return TRUE
		end
	elseif c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH then
		local hand = HAND_RIGHT

		if c_Style == HAND_LEFT_BOTH then
			hand = HAND_LEFT
		end

		local specialcategory = env(GetEquipWeaponSpecialCategoryNumber, hand)

		if specialcategory == 110 or specialcategory == 832 or specialcategory == 852 or specialcategory == 255
			or specialcategory == 257 then
			return FALSE
		end
		if specialcategory == 182 or specialcategory == 207 then
			return TRUE
		end
		if GetEquipType(hand, WEAPON_CATEGORY_TORCH, WEAPON_CATEGORY_STRAIGHT_SWORD, WEAPON_CATEGORY_TWINBLADE,
			WEAPON_CATEGORY_EXTRALARGE_SWORD, WEAPON_CATEGORY_RAPIER, WEAPON_CATEGORY_LARGE_RAPIER,
			WEAPON_CATEGORY_CURVEDSWORD, WEAPON_CATEGORY_BACKHAND_SWORD) == TRUE then
			return TRUE
		end
	else
		local hand = HAND_RIGHT
		local specialcategory = env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT)

		if specialcategory == 110 then
			return FALSE
		end
		if specialcategory == 182 or specialcategory == 207 then
			return TRUE
		end
		if GetEquipType(hand, WEAPON_CATEGORY_TORCH, WEAPON_CATEGORY_STRAIGHT_SWORD, WEAPON_CATEGORY_TWINBLADE,
			WEAPON_CATEGORY_EXTRALARGE_SWORD, WEAPON_CATEGORY_RAPIER, WEAPON_CATEGORY_LARGE_RAPIER,
			WEAPON_CATEGORY_CURVEDSWORD, WEAPON_CATEGORY_BACKHAND_SWORD) == TRUE then
			return TRUE
		end
	end
	return FALSE
end

function ExecArtsStance(blend_type)
	if c_IsEnableSwordArts == FALSE then
		return FALSE
	end
	local arts_id = c_SwordArtsID
	local is_arrow = GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_SMALL_ARROW,
		WEAPON_CATEGORY_LARGE_ARROW)
	local is_crossbow = GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW, WEAPON_CATEGORY_BALLISTA)

	if c_Style == HAND_RIGHT and (is_arrow == TRUE or is_crossbow == TRUE) then
		return FALSE
	end
	if IsAttackStanceArts(arts_id) == TRUE then
		if env(GetStamina) <= 0 then
			return FALSE
		end
		if env(ActionRequest, ACTION_ARM_L2) == FALSE then
			return FALSE
		end
	elseif GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_LARGE_ARROW) == TRUE then
		if env(ActionRequest, ACTION_ARM_L2) == FALSE or env(ActionDuration, ACTION_ARM_L2) <= 0 then
			return FALSE
		end
	elseif IsStanceArts(arts_id) == TRUE then
		if env(ActionDuration, ACTION_ARM_L2) <= 0 then
			return FALSE
		end
	else
		return FALSE
	end

	if c_IsStealth == TRUE then
		blend_type = ALLBODY
	end

	if blend_type == ALLBODY and MoveStart(LOWER, Event_Move, FALSE) == TRUE then
		blend_type = UPPER
	end

	SetVariable("SwordArtsOneShotComboCategory", 0)

	if c_SwordArtsID == 318 then
		SetSwordArtsPointInfo(ACTION_ARM_R1, TRUE)
	else
		SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)
	end

	if env(GetSpEffectID, 19921) == TRUE then
		ExecEventHalfBlendNoReset(Event_DrawStanceRightLoop, blend_type)
	else
		ExecEventHalfBlend(Event_DrawStanceRightStart, blend_type)
	end

	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()

	return TRUE
end

function ExecArtsStanceOnCancelTiming(blend_type)
	if env(IsWeaponCancelPossible) == TRUE and ExecArtsStance(blend_type) == TRUE then
		return TRUE
	end
	return FALSE
end

function ExecMagic(quick_type, blend_type, is_ride)
	if c_HasActionRequest == FALSE then
		return FALSE
	end
	if env(GetStamina) <= 0 then
		return FALSE
	end
	if env(ActionDuration, ACTION_ARM_ACTION) > 0 then
		return FALSE
	end
	if env(IsMagicUseMenuOpened) == TRUE then
		return FALSE
	end
	if c_IsStealth == TRUE then
		blend_type = ALLBODY
	end
	local style = c_Style
	local magic_hand = HAND_RIGHT
	local wep_hand = HAND_RIGHT
	local delayActRequestNo = -1
	local is_samagic = FALSE
	local sp_kind_R = env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT)
	local sp_kind_L = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)
	local buttonR = ACTION_ARM_MAGIC_R
	local buttonL = ACTION_ARM_MAGIC_L

	if IsWeaponCatalyst(sp_kind_R) == TRUE then
		buttonR = ACTION_ARM_MAGIC_R2
	end
	if IsWeaponCatalyst(sp_kind_L) == TRUE and is_ride == FALSE then
		buttonL = ACTION_ARM_MAGIC_L2
	end

	if env(ActionRequest, buttonL) == TRUE and env(ActionRequest, buttonR) == FALSE and is_ride == TRUE then
		ResetRequest()
		return FALSE
	end

	-- Normal Catalysts
	-- R1/L1 (while riding)
	if env(ActionRequest, ACTION_ARM_MAGIC_R) == TRUE or env(ActionRequest, ACTION_ARM_MAGIC_L) == TRUE and is_ride
		== TRUE then
		delayActRequestNo = ACTION_ARM_MAGIC_R
		if style == HAND_LEFT_BOTH then
			if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_STAFF) == FALSE then
				return FALSE
			end
			wep_hand = HAND_LEFT
		else
			if GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_STAFF) == FALSE then
				return FALSE
			end
			wep_hand = HAND_RIGHT
		end
		-- R2
	elseif env(ActionRequest, ACTION_ARM_MAGIC_R2) == TRUE then
		delayActRequestNo = ACTION_ARM_MAGIC_R2
		if style == HAND_LEFT_BOTH then
			local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)
			if IsWeaponCatalyst(sp_kind) == FALSE then
				return FALSE
			end
			wep_hand = HAND_LEFT
		else
			local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT)
			if IsWeaponCatalyst(sp_kind) == FALSE then
				return FALSE
			end
			wep_hand = HAND_RIGHT
		end
		-- L1
	elseif env(ActionRequest, ACTION_ARM_MAGIC_L) == TRUE then
		delayActRequestNo = ACTION_ARM_MAGIC_L
		if style == HAND_RIGHT_BOTH or style == HAND_LEFT_BOTH then
			return FALSE
		end
		if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_STAFF) == FALSE then
			return FALSE
		end
		wep_hand = HAND_LEFT
		magic_hand = HAND_LEFT
		act(DebugLogOutput, "MagicLeft")
		-- L2
	elseif env(ActionRequest, ACTION_ARM_MAGIC_L2) == TRUE and is_ride == FALSE then
		delayActRequestNo = ACTION_ARM_MAGIC_L2
		if style == HAND_RIGHT then
			local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)
			if IsWeaponCatalyst(sp_kind) == FALSE then
				return FALSE
			end
			wep_hand = HAND_LEFT
			magic_hand = HAND_LEFT
		else
			return FALSE
		end
	else
		return FALSE
	end
	if env(IsMagicUseMenuOpening, wep_hand) == TRUE then
		ResetRequest()
		act(OpenMenuWhenUsingMagic, delayActRequestNo)
		return TRUE
	end
	act(DecideMagicUse)
	act(NotifyAIMagicCast)
	local magic_index = env(GetMagicAnimType)
	g_MagicIndex = magic_index
	g_Magichand = wep_hand
	local lastMagicMem = lastUsedMagicAnim
	lastUsedMagicAnim = magic_index
	if blend_type == ALLBODY and is_ride == FALSE then
		local move_event = Event_Move
		if IsStealthMagic(magic_index) == TRUE and c_IsStealth == TRUE then
			move_event = Event_Stealth_Move
		end
		if MoveStart(LOWER, move_event, FALSE) == TRUE then
			blend_type = UPPER
		end
	end
	if env(IsMagicUseable, wep_hand, 0) == FALSE then
		act(DebugLogOutput, "Event_MagicInvalid_Cannot_Use_Magic")
		SetVariable("IndexMagicHand", magic_hand)
		if is_ride == TRUE then
			ExecEventAllBody("W_RideMagicInvalid")
		else
			ExecEventHalfBlend(Event_MagicInvalid, blend_type)
		end
		act(SetIsMagicInUse, TRUE)
		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()
		return TRUE
	end

	if magic_index == 254 or magic_index == 255 then
		SetVariable("IndexMagicHand", magic_hand)
		if is_ride == TRUE then
			ExecEventAllBody("W_RideMagicInvalid")
		else
			act(DebugLogOutput, "Event_MagicInvalid_InvalidMagic")
			ExecEventHalfBlend(Event_MagicInvalid, blend_type)
		end
		act(SetIsMagicInUse, TRUE)
		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()
		return TRUE
	end

	-- Check if Player is Enchanting a Weapon in the Left Hand
	if IsWeaponEnchantMagic() == TRUE and c_Style == HAND_LEFT_BOTH then
		SetVariable("IndexMagicHand", magic_hand)
		act(DebugLogOutput, "Event_MagicInvalid_Left")
		ExecEventHalfBlend(Event_MagicInvalid, blend_type)
		act(SetIsMagicInUse, TRUE)
		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()
		return TRUE
	end

	-- Check if the Animation Type of the Magic is something related to Magic for Shields
	if magic_index == MAGIC_REQUEST_ORDER_SHIELD then
		if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_LARGE_SHIELD) == TRUE then
			SetVariable("MagicRight_ShieldCategory", 1)
		end
	else
		SetVariable("MagicRight_ShieldCategory", 0)
	end

	if magic_index == MAGIC_REQUEST_GRAVITY or magic_index == MAGIC_REQUEST_METEOR or magic_index
		== MAGIC_REQUEST_BLASTING or magic_index == MAGIC_REQUEST_DRILL or magic_index == MAGIC_REQUEST_MAGIC_SPARK
		or magic_index == 115 or magic_index == 120 or magic_index == 121 or magic_index == 157 or magic_index == 82
		or magic_index == 150 or magic_index == 156 or magic_index == 161 then
		if IsWeaponCatalyst(env(GetEquipWeaponSpecialCategoryNumber, wep_hand)) == TRUE then
			SetVariable("Magic_SpecialStaffCategory", 2)
		else
			SetVariable("Magic_SpecialStaffCategory", 0)
		end
	elseif magic_index == 141 or magic_index == 128 or magic_index == 146 then
		if env(GetEquipWeaponSpecialCategoryNumber, wep_hand) == 290 then
			SetVariable("Magic_SpecialStaffCategory", 1)
		else
			SetVariable("Magic_SpecialStaffCategory", 0)
		end
	else
		SetVariable("Magic_SpecialStaffCategory", 0)
	end

	if magic_index == MAGIC_REQUEST_WEAPON_ENCHANT or magic_index == MAGIC_REQUEST_THUNDER_ENCHANT or magic_index
		== MAGIC_REQUEST_WEAPON_ENCHANT_B or magic_index == MAGIC_REQUEST_HOLY_ENCHANT then
		if GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_DUELING_SHIELD) == TRUE then
			SetVariable("Magic_DuelingShieldCategory", 1)
		else
			SetVariable("Magic_DuelingShieldCategory", 0)
		end
	else
		SetVariable("Magic_DuelingShieldCategory", 0)
	end

	local is_atk_auto_aim = FALSE
	if magic_index == MAGIC_REQUEST_WHIP or magic_index == MAGIC_REQUEST_SLASH or magic_index == MAGIC_REQUEST_QUICKSLASH
		or magic_index == MAGIC_REQUEST_FLAME_GRAB or magic_index == MAGIC_REQUEST_CRUSH or magic_index
		== MAGIC_REQUEST_CHOP or magic_index == MAGIC_REQUEST_SCYTHE then
		is_atk_auto_aim = TRUE
	end

	if magic_index == 127 and env(GetSpEffectID, 19975) == TRUE then
		return TRUE
	end

	if ExecComboMagic(magic_hand, blend_type, lastMagicMem, magic_index) == TRUE then
	elseif ExecQuickMagic(magic_hand, quick_type, blend_type) == TRUE then
	elseif ExecStealthMagic(magic_hand, magic_index, blend_type) == TRUE then
	elseif is_ride == TRUE then
		ExecEventAllBody("W_RideMagicLaunch")
	elseif magic_hand == HAND_RIGHT and (magic_index ~= MAGIC_REQUEST_MAD_THROW or c_Style ~= HAND_LEFT_BOTH) then
		ExecEventHalfBlend(Event_MagicLaunchRight, blend_type)
	else
		ExecEventHalfBlend(Event_MagicLaunchLeft, blend_type)
	end

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if Deflect_IsCounterExtends() == TRUE then
			Deflect_Activate(FALSE)
		end

		if AI_IsEnemyAlert() == TRUE then
			AI_TriggerEnemyAlert()
		end
	end
	-- CUSTOM: End.

	act(SetIsMagicInUse, TRUE)
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()

	return TRUE
end

function ExecQuickMagic(magic_hand, quick_type, blend_type)
	if env(IsOnMount) == TRUE or IsQuickMagic() == FALSE then
		return FALSE
	end
	if quick_type == QUICKTYPE_NORMAL or quick_type == QUICKTYPE_RUN then
		return FALSE
	elseif quick_type == QUICKTYPE_DASH then
		if magic_hand == HAND_RIGHT then
			ExecEventHalfBlend(Event_QuickMagicFireRightDash, blend_type)
			return TRUE
		else
			ExecEventHalfBlend(Event_QuickMagicFireLeftDash, blend_type)
			return TRUE
		end
	elseif quick_type == QUICKTYPE_ROLLING then
		if magic_hand == HAND_RIGHT then
			ExecEventHalfBlend(Event_QuickMagicFireRightStep, blend_type)
			return TRUE
		else
			ExecEventHalfBlend(Event_QuickMagicFireLeftStep, blend_type)
			return TRUE
		end
	elseif quick_type == QUICKTYPE_BACKSTEP then
		if magic_hand == HAND_RIGHT then
			ExecEventHalfBlend(Event_QuickMagicFireRightBackStep, blend_type)
			return TRUE
		else
			ExecEventHalfBlend(Event_QuickMagicFireLeftBackStep, blend_type)
			return TRUE
		end
	elseif quick_type == QUICKTYPE_ATTACK or quick_type == QUICKTYPE_COMBO then
		if ForwardLeg() == 1 then
			if magic_hand == HAND_RIGHT then
				ExecEventHalfBlend(Event_QuickMagicFireRightAttackRight, blend_type)
				return TRUE
			else
				ExecEventHalfBlend(Event_QuickMagicFireLeftAttackRight, blend_type)
				return TRUE
			end
		elseif magic_hand == HAND_RIGHT then
			ExecEventHalfBlend(Event_QuickMagicFireRightAttackLeft, blend_type)
			return TRUE
		else
			ExecEventHalfBlend(Event_QuickMagicFireLeftAttackLeft, blend_type)
			return TRUE
		end
	end
	return FALSE
end

function ExecComboMagic(magic_hand, blend_type, lastUsedMagicAnim, magicAnim)
	-- 100600 "[HKS] Right Combo Magic 1: Window"
	-- 100601 "[HKS] Right Combo Magic 2: Window"
	-- 100605 "[HKS] Left Combo Magic 1: Window"
	-- 100606 "[HKS] Left Combo Magic 2: Window"

	if lastUsedMagicAnim ~= magicAnim then
		return FALSE
	end
	if IsComboMagic() == FALSE then
		return FALSE
	end
	if env(IsOnMount) == TRUE then
		if env(GetSpEffectID, 100600) == TRUE then
			ExecEventAllBody("W_RideMagicFireCombo1")
			return TRUE
		elseif env(GetSpEffectID, 100601) == TRUE then
			ExecEventAllBody("W_RideMagicFireCombo2")
			return TRUE
		else
			return FALSE
		end
	elseif magic_hand == HAND_RIGHT then
		if env(GetSpEffectID, 100600) == TRUE then
			ExecEventHalfBlend(Event_MagicFireRight2, blend_type)
			return TRUE
		elseif env(GetSpEffectID, 100601) == TRUE then
			ExecEventHalfBlend(Event_MagicFireRight3, blend_type)
			return TRUE
		else
			return FALSE
		end
	elseif env(GetSpEffectID, 100605) == TRUE then
		ExecEventHalfBlend(Event_MagicFireLeft2, blend_type)
		return TRUE
	elseif env(GetSpEffectID, 100606) == TRUE then
		ExecEventHalfBlend(Event_MagicFireLeft3, blend_type)
		return TRUE
	else
		return FALSE
	end
end

function ExecStealthMagic(magic_hand, magic_type, blend_type)
	if c_IsStealth == FALSE then
		return FALSE
	end
	if IsStealthMagic(magic_type) == FALSE then
		return FALSE
	end
	if magic_hand == HAND_RIGHT then
		ExecEventHalfBlend(Event_StealthMagicRightLaunch, blend_type)
		return TRUE
	else
		ExecEventHalfBlend(Event_StealthMagicLeftLaunch, blend_type)
		return TRUE
	end
end

function ExecRollingMagic(magic_hand, magic_type, blend_type)
	if IsRollingMagic(magic_type) == FALSE then
		return FALSE
	end

	local rollingAngle = GetVariable("MoveAngle")
	local turn_target_angle = 0
	local rollingDirection = 0
	local turn_angle_real = 200

	if GetVariable("IsLockon") == false and env(IsPrecisionShoot) == FALSE and env(IsCOMPlayer) == FALSE
		or env(GetSpEffectID, 100002) == TRUE then
		rollingDirection = 0
	else
		if rollingAngle <= GetVariable("RollingAngleThresholdRightFrontTest") and rollingAngle
			>= GetVariable("RollingAngleThresholdLeftFrontTest") then
			rollingDirection = 0
			turn_target_angle = rollingAngle
		elseif rollingAngle > GetVariable("RollingAngleThresholdRightFrontTest") and rollingAngle
			< GetVariable("RollingAngleThresholdRightBackTest") then
			rollingDirection = 3
			turn_target_angle = rollingAngle - 90
		elseif rollingAngle < GetVariable("RollingAngleThresholdLeftFrontTest") and rollingAngle
			> GetVariable("RollingAngleThresholdLeftBackTest") then
			rollingDirection = 2
			turn_target_angle = rollingAngle + 90
		else
			rollingDirection = 1
			turn_target_angle = rollingAngle - 180
		end
		turn_angle_real = math.abs(GetVariable("TurnAngle") - rollingAngle)
		if turn_angle_real > 180 then
			turn_angle_real = 360 - turn_angle_real
		end
	end

	SetVariable("RollingMagicDirection", rollingDirection)
	SetVariable("RollingAngleReal", rollingAngle)
	SetVariable("TurnAngleReal", turn_angle_real)

	if GetVariable("MoveSpeedLevel") < 0.10000000149011612 then
		if magic_hand == HAND_RIGHT then
			ExecEventHalfBlend(Event_MagicFireRight, blend_type)
			return TRUE
		else
			ExecEventHalfBlend(Event_MagicFireLeft, blend_type)
			return TRUE
		end
	elseif magic_hand == HAND_RIGHT then
		ExecEventHalfBlend(Event_RollingMagicRight, blend_type)
		return TRUE
	else
		ExecEventHalfBlend(Event_RollingMagicLeft, blend_type)
		return TRUE
	end
end

function ExecGesture()
	if c_HasActionRequest == FALSE then
		return FALSE
	end
	if env(ActionRequest, ACTION_ARM_GESTURE) == FALSE then
		return FALSE
	end

	local request = env(GetGestureRequestNumber)

	if request == 109 then
		request = 108
	elseif request == 113 or request == 116 then
		request = 110
	end

	local animID = 80000 + request * 10

	SetVariable("GestureID", request)

	if request == INVALID then
		return FALSE
	end

	local isloop = FALSE

	if env(DoesAnimExist, animID + 1) == TRUE then
		isloop = TRUE
	end

	if isloop == TRUE then
		if GetLocomotionState() == PLAYER_STATE_MOVE then
			ExecEventHalfBlend(Event_GestureLoopStart, UPPER)
			return TRUE
		else
			ExecEventHalfBlend(Event_GestureLoopStart, ALLBODY)
			return TRUE
		end
	elseif GetLocomotionState() == PLAYER_STATE_MOVE then
		ExecEventHalfBlend(Event_GestureStart, UPPER)
		return TRUE
	else
		ExecEventHalfBlend(Event_GestureStart, ALLBODY)
		return TRUE
	end
end

function ExecStealthItem(blend_type, item_type)
	if item_type ~= ITEM_RECOVER and item_type ~= ITEM_SOUL and item_type ~= ITEM_DRINK and item_type ~= ITEM_DRINK_MP
		and item_type ~= ITEM_NO_DRINK and item_type ~= ITEM_EATJERKY and item_type ~= ITEM_ELIXIR and item_type
		~= ITEM_SUMMONBUDDY and item_type ~= ITEM_RETURNBUDDY and item_type ~= ITEM_ELIXIR2 and item_type ~= ITEM_INVALID then
		return FALSE
	end
	if blend_type == ALLBODY and MoveStart(LOWER, Event_Stealth_Move, FALSE) == TRUE then
		blend_type = UPPER
	end

	-- Flasks
	if item_type == ITEM_DRINK or item_type == ITEM_DRINK_MP then
		if env(GetStateChangeType, CONDITION_TYPE_NO_EST) == TRUE then
			ExecEventHalfBlend(Event_StealthItemDrinkNothing, blend_type)
		elseif IsNodeActive("StealthItemDrinking_Upper_CMSG") == TRUE then
			SetInterruptType(INTERRUPT_USEITEM)
			ExecEventHalfBlend(Event_StealthItemDrinking, blend_type)
		else
			SetInterruptType(INTERRUPT_USEITEM)
			ExecEventHalfBlend(Event_StealthItemDrinkStart, blend_type)
		end
	elseif item_type == ITEM_NO_DRINK then
		if IsNodeActive("StealthItemDrinkingMP_Upper_CMSG") == TRUE or IsNodeActive("StealthItemDrinking_Upper_CMSG")
			== TRUE then
			ExecEventHalfBlend(Event_StealthItemDrinkEmpty, blend_type)
		else
			ExecEventHalfBlend(Event_StealthItemDrinkStart, blend_type)
		end
	elseif IsNodeActive("StealthItemOneShot_Blend") == TRUE then
		SetVariable("IndexItemUseAnim_SelfTrans", item_type)
		ExecEventHalfBlend(Event_StealthItemOneShot_SelfTrans, blend_type)
	else
		SetVariable("IndexItemUseAnim", item_type)
		ExecEventHalfBlend(Event_StealthItemOneShot, blend_type)
	end

	act(SetIsItemAnimationPlaying)
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()

	return TRUE
end

function IsUseStaminaItem(item_type)
	if item_type == ITEM_THROW_KNIFE or item_type == ITEM_THROW_BOTTLE or item_type == ITEM_QUICK_THROW_KNIFE
		or item_type == ITEM_THROW_SPEAR then
		return TRUE
	end
	return FALSE
end

function ExecItem(quick_type, blend_type)
	if c_HasActionRequest == FALSE then
		return FALSE
	end
	if env(ActionRequest, ACTION_ARM_USE_ITEM) == FALSE then
		return FALSE
	end
	if env(IsItemUseMenuOpened) == TRUE then
		return FALSE
	end
	if env(IsItemUseMenuOpening) == TRUE then
		ResetRequest()
		act(OpenMenuWhenUsingItem)
		return TRUE
	end

	act(UseItemDecision)

	local item_type = env(GetItemAnimType)
	local hand = HAND_RIGHT
	local kind = env(GetEquipWeaponCategory, hand)

	if IsUseStaminaItem(item_type) == TRUE and env(GetStamina) <= 0 then
		return FALSE
	end
	if blend_type == ALLBODY then
		if c_IsStealth == TRUE then
			if MoveStart(LOWER, Event_Stealth_Move, FALSE) == TRUE then
				blend_type = UPPER
			end
		elseif MoveStart(LOWER, Event_Move, FALSE) == TRUE then
			blend_type = UPPER
		end
	end

	if c_IsStealth == TRUE then
		if ExecStealthItem(blend_type, item_type) == TRUE then
			return TRUE
		end
		blend_type = ALLBODY
	end

	if item_type == ITEM_RECOVER then
		ExecEventHalfBlend(Event_ItemRecover, blend_type)
	elseif item_type == ITEM_WEAPON_ENCHANT then
		if kind == WEAPON_CATEGORY_BACKHAND_SWORD then
			SetVariable("ItemWeaponType", 1)
		elseif kind == WEAPON_CATEGORY_DUELING_SHIELD then
			SetVariable("ItemWeaponType", 2)
		else
			SetVariable("ItemWeaponType", 0)
		end
		ExecEventHalfBlend(Event_ItemWeaponEnchant, blend_type)
	elseif item_type == ITEM_THROW_KNIFE then
		ExecEventHalfBlend(Event_ItemThrowKnife, blend_type)
	elseif item_type == ITEM_THROW_BOTTLE then
		ExecEventHalfBlend(Event_ItemThrowBottle, blend_type)
	elseif item_type == ITEM_MEGANE then
		if env(GetStateChangeType, 15) == TRUE then
			ExecEventHalfBlend(Event_ItemMeganeEnd, ALLBODY)
		else
			ExecEventHalfBlend(Event_ItemMeganeStart, ALLBODY)
		end
	elseif item_type == ITEM_REPAIR then
		ExecEventHalfBlend(Event_ItemWeaponRepair, ALLBODY)
	elseif item_type == ITEM_PRAY then
		ExecEventHalfBlend(Event_ItemPrayMulti, blend_type)
	elseif item_type == ITEM_TRAP then
		ExecEventHalfBlend(Event_ItemTrap, blend_type)
	elseif item_type == ITEM_MESSAGE then
		ExecEventHalfBlend(Event_ItemMessage, ALLBODY)
	elseif item_type == ITEM_SOUL then
		ExecEventHalfBlend(Event_ItemSoul, blend_type)
	elseif item_type == ITEM_DRINK then
		if env(GetStateChangeType, CONDITION_TYPE_NO_EST) == TRUE then
			ExecEventHalfBlend(Event_ItemDrinkNothing, blend_type)
		elseif IsNodeActive("ItemDrinking_Upper_CMSG") == TRUE then
			SetInterruptType(INTERRUPT_USEITEM)
			ExecEventHalfBlend(Event_ItemDrinking, blend_type)
		else
			SetInterruptType(INTERRUPT_USEITEM)
			ExecEventHalfBlend(Event_ItemDrinkStart, blend_type)
		end
	elseif item_type == ITEM_TRANSFORM_DRAGONPRIEST then
		if env(GetSpEffectID, 19980) == TRUE or env(GetSpEffectID, 19981) == TRUE then
			SetVariable("ItemTransformType", 1)
		else
			SetVariable("ItemTransformType", 0)
		end
		ExecEventHalfBlend(Event_ItemTransformDragonPriest, blend_type)
	elseif item_type == ITEM_DRAGONTHROWSPEAR then
		ExecEventHalfBlend(Event_ItemDragonThrowSpearMax, blend_type)
	elseif item_type == ITEM_SHOCK_WAVE then
		ExecEventHalfBlend(Event_ItemShockWeaveStart, blend_type)
	elseif item_type == ITEM_THORN then
		ExecEventHalfBlend(Event_ItemThorn, blend_type)
	elseif item_type == ITEM_QUICK_WEAPON_ENCHANT then
		if kind == WEAPON_CATEGORY_DUELING_SHIELD then
			SetVariable("ItemWeaponType", 1)
		else
			SetVariable("ItemWeaponType", 0)
		end
		if quick_type == QUICKTYPE_NORMAL or quick_type == QUICKTYPE_RUN then
			ExecEventHalfBlend(Event_QuickItemEnchantNormal, blend_type)
		elseif quick_type == QUICKTYPE_DASH then
			ExecEventHalfBlend(Event_QuickItemEnchantDash, blend_type)
		elseif quick_type == QUICKTYPE_ROLLING or quick_type == QUICKTYPE_BACKSTEP then
			ExecEventHalfBlend(Event_QuickItemEnchantStep, blend_type)
		elseif quick_type == QUICKTYPE_ATTACK then
			if ForwardLeg() == 1 then
				ExecEventHalfBlend(Event_QuickItemEnchantAttackRight, blend_type)
			else
				ExecEventHalfBlend(Event_QuickItemEnchantAttackLeft, blend_type)
			end
		else
			return FALSE
		end
	elseif item_type == ITEM_QUICK_THROW_KNIFE then
		if quick_type == QUICKTYPE_NORMAL or quick_type == QUICKTYPE_RUN then
			ExecEventHalfBlend(Event_QuickItemThrowKnifeNormal, ALLBODY)
		elseif quick_type == QUICKTYPE_DASH then
			ExecEventHalfBlend(Event_QuickItemThrowKnifeDash, ALLBODY)
		elseif quick_type == QUICKTYPE_ROLLING or quick_type == QUICKTYPE_BACKSTEP then
			ExecEventHalfBlend(Event_QuickItemThrowKnifeStep, ALLBODY)
		elseif quick_type == QUICKTYPE_ATTACK then
			if ForwardLeg() == 1 then
				ExecEventHalfBlend(Event_QuickItemThrowKnifeAttackRight, ALLBODY)
			else
				ExecEventHalfBlend(Event_QuickItemThrowKnifeAttackLeft, ALLBODY)
			end
		elseif quick_type == QUICKTYPE_COMBO then
			if ForwardLeg() == 1 then
				ExecEventHalfBlend(Event_QuickItemThrowKnifeAttackRight2, ALLBODY)
			else
				ExecEventHalfBlend(Event_QuickItemThrowKnifeAttackLeft2, ALLBODY)
			end
		else
			return FALSE
		end
	elseif item_type == ITEM_QUICK_THROW_BOTTLE then
		return FALSE
	elseif item_type == ITEM_SWITCH_EXPLOSIVE then
		ExecEventHalfBlend(Event_ItemSwitchExplosive, blend_type)
	elseif item_type == ITEM_DRINK_MP then
		if env(GetStateChangeType, CONDITION_TYPE_NO_EST) == TRUE then
			ExecEventHalfBlend(Event_ItemDrinkNothing, blend_type)
		elseif IsNodeActive("ItemDrinkingMP_Upper_CMSG") == TRUE then
			SetInterruptType(INTERRUPT_USEITEM)
			ExecEventHalfBlend(Event_ItemDrinkingMP, blend_type)
		else
			SetInterruptType(INTERRUPT_USEITEM)
			ExecEventHalfBlend(Event_ItemDrinkStartMP, blend_type)
		end
	elseif item_type == ITEM_STRING_BOTTLE then
		ExecEventHalfBlend(Event_ItemThrowBackBottle, blend_type)
	elseif item_type == ITEM_CRY_SICKNESS then
		ExecEventHalfBlend(Event_ItemCrySickness, blend_type)
	elseif item_type == ITEM_CRY_SICKNESS_PHANTOM then
		ExecEventHalfBlend(Event_ItemCrySicknessPhantom, blend_type)
	elseif item_type == ITEM_TRANSFORM_GODMAN then
		if env(GetSpEffectID, 19982) == TRUE or env(GetSpEffectID, 19983) == TRUE then
			SetVariable("ItemTransformType", 1)
		else
			SetVariable("ItemTransformType", 0)
		end
		ExecEventHalfBlend(Event_ItemTransformGodman, blend_type)
	elseif item_type == 25 then
		ExecEventHalfBlend(Event_ItemDragonFullStartAfter, blend_type)
	elseif item_type == 26 then
		ExecEventHalfBlend(Event_ItemEatJerky, blend_type)
	elseif item_type == 27 then
		if env(GetSpEffectID, 3245) == TRUE then
			ExecEventHalfBlend(Event_ItemLanternOff, blend_type)
		else
			ExecEventHalfBlend(Event_ItemLanternOn, blend_type)
		end
	elseif item_type == ITEM_ELIXIR then
		SetInterruptType(INTERRUPT_USEITEM)
		ExecEventHalfBlend(Event_ItemElixir, blend_type)
	elseif item_type == ITEM_HORN then
		ExecEventHalfBlend(Event_ItemHorn, blend_type)
	elseif item_type == ITEM_COPY_SLEEP then
		ExecEventHalfBlend(Event_ItemCopySleep, blend_type)
	elseif item_type == ITEM_VOICE then -- Duplicate Condition #1
		ExecEventHalfBlend(Event_ItemVoice, blend_type)
	elseif item_type == ITEM_SUMMONHORSE then
		SetVariable("RideOnSummonTest", 0)
		SetVariable("IndexItemUseAnim", item_type)
		SetVariable("ItemDashSpeedIndex", 0)

		if GetVariable("MoveSpeedIndex") >= 1 then
			SetVariable("ItemDashSpeedIndex", 1)
		end
		if GetVariable("MoveSpeedLevel") >= 0.8999999761581421 then
			IsSummonDash = TRUE
		else
			IsSummonDash = FALSE
		end

		ExecEventHalfBlend(Event_ItemDash, blend_type)
	elseif item_type == ITEM_VOICE then -- Duplicate Condition #2
		ExecEventHalfBlend(Event_ItemReturnBuddy, blend_type)
	elseif item_type == ITEM_SUMMONBUDDY then
		ExecEventHalfBlend(Event_ItemSummonBuddy, blend_type)
	elseif item_type == ITEM_HOST then
		ExecEventHalfBlend(Event_ItemHost, blend_type)
	elseif item_type == ITEM_MULTIKICK then
		ExecEventHalfBlend(Event_ItemMultKick, blend_type)
	elseif item_type == ITEM_TONGUE then
		ExecEventHalfBlend(Event_ItemTongue, blend_type)
	elseif item_type == ITEM_HOLYSYMBOL then
		ExecEventHalfBlend(Event_ItemHolySymbol, blend_type)
	elseif item_type == ITEM_ELIXIR2 then
		SetInterruptType(INTERRUPT_USEITEM)
		ExecEventHalfBlend(Event_ItemElixir2, blend_type)
	elseif item_type == ITEM_DANCING_SWORDSMAN_FIRE then
		ExecEventHalfBlend(Event_ItemDancingSwordsmanFire, blend_type)
	elseif item_type == ITEM_SWITCH then
		ExecEventHalfBlend(Event_ItemSwitch, blend_type)
	elseif item_type == ITEM_ERDTREE then
		ExecEventHalfBlend(Event_ItemErdtree, blend_type)
	elseif item_type == ITEM_NIGHT_BELL then
		-- 100800 "[HKS] Item Combo Window"
		local is_combo = env(GetSpEffectID, 100800)

		if is_combo == TRUE then
			ExecEventHalfBlend(Event_ItemCombo, blend_type)
		elseif IsNodeActive("ItemOneshot_Upper") == TRUE then
			SetVariable("IndexItemUseAnim_SelfTrans", item_type)
			ExecEventHalfBlend(Event_ItemOneShot_SelfTrans, blend_type)
		else
			SetVariable("IndexItemUseAnim", item_type)
			ExecEventHalfBlend(Event_ItemOneShot, blend_type)
		end
	elseif item_type == 52 then
		ResetMimicry()
		if IsNodeActive("ItemOneshot_Upper") == TRUE then
			SetVariable("IndexItemUseAnim_SelfTrans", item_type)
			ExecEventHalfBlend(Event_ItemOneShot_SelfTrans, blend_type)
		else
			SetVariable("IndexItemUseAnim", item_type)
			ExecEventHalfBlend(Event_ItemOneShot, blend_type)
		end
	elseif item_type == ITEM_THROW_BIGBOTTLE then
		ExecEventHalfBlend(Event_ItemThrowBigBottle, blend_type)
	elseif item_type == ITEM_TRANSFORM_GODMAN_NPC then
		ExecEventHalfBlend(Event_ItemTransformGodmanNPC, blend_type)
	elseif item_type == ITEM_TRANSFORM_GODMANBREATH_NPC then
		ExecEventHalfBlend(Event_ItemTransformGodmanBreathNPC, blend_type)
	elseif item_type == ITEM_AROMAWIDE then
		ExecEventHalfBlend(Event_ItemAromaWide, blend_type)
	elseif item_type == ITEM_AROMAUP then
		ExecEventHalfBlend(Event_ItemAromaUp, blend_type)
	elseif item_type == ITEM_AROMAFRONT then
		ExecEventHalfBlend(Event_ItemAromaFront, blend_type)
	elseif item_type == ITEM_AROMADRINK then
		ExecEventHalfBlend(Event_ItemAromaDrink, blend_type)
	elseif item_type == ITEM_AROMABREATH then
		ExecEventHalfBlend(Event_ItemAromaBreath, blend_type)
	elseif item_type == ITEM_NO_DRINK then
		if IsNodeActive("ItemDrinkingMP_Upper_CMSG") == TRUE or IsNodeActive("ItemDrinking_Upper_CMSG") == TRUE then
			if blend_type == ALLBODY and MoveStart(LOWER, Event_MoveLong, FALSE) == TRUE then
				blend_type = UPPER
			end
			ExecEventHalfBlend(Event_ItemDrinkEmpty, blend_type)
		else
			ExecEventHalfBlend(Event_ItemDrinkStart, blend_type)
		end
	elseif item_type == ITEM_INVALID then
		ExecEventHalfBlend(Event_ItemInvalid, blend_type)
	elseif IsNodeActive("ItemOneshot_Upper") == TRUE then
		SetVariable("IndexItemUseAnim_SelfTrans", item_type)
		ExecEventHalfBlend(Event_ItemOneShot_SelfTrans, blend_type)
	else
		SetVariable("IndexItemUseAnim", item_type)
		ExecEventHalfBlend(Event_ItemOneShot, blend_type)
	end

	act(SetIsItemAnimationPlaying)
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()

	return TRUE
end

function ExecLadderItem(hand)
	if c_HasActionRequest == FALSE then
		return FALSE
	end
	if env(ActionRequest, ACTION_ARM_USE_ITEM) == FALSE then
		return FALSE
	end
	if env(IsItemUseMenuOpened) == TRUE then
		return FALSE
	end
	if env(IsItemUseMenuOpening) == TRUE then
		ResetRequest()
		act(OpenMenuWhenUsingItem)
		return TRUE
	end

	act(UseItemDecision)

	local item_type = env(GetItemAnimType)
	local event = "W_ItemLadderInvalid"
	local event_hand = "Left"

	if hand == HAND_STATE_RIGHT then
		event_hand = "Right"
	end

	if item_type == ITEM_RECOVER then
		event = "W_ItemLadderRecover"
	elseif item_type == ITEM_SOUL then
		event = "W_ItemLadderSoul"
	elseif item_type == ITEM_EATJERKY then
		event = "W_ItemLadderEatJerky"
	elseif item_type == ITEM_ELIXIR then
		event = "W_ItemLadderElixir"
	elseif item_type == ITEM_ELIXIR2 then
		event = "W_ItemLadderElixir2"
	elseif item_type == ITEM_DRINK then
		if env(GetStateChangeType, CONDITION_TYPE_NO_EST) == TRUE then
			event = "W_ItemLadderDrinkNothing"
		elseif IsNodeActive("ItemLadderDrinkingRight_CMSG") == TRUE then
			event = "W_ItemLadderDrinking"
			event_hand = "Right"
		elseif IsNodeActive("ItemLadderDrinkingLeft_CMSG") == TRUE then
			event = "W_ItemLadderDrinking"
			event_hand = "Left"
		else
			event = "W_ItemLadderDrinkStart"
		end
	elseif item_type == ITEM_DRINK_MP then
		if env(GetStateChangeType, CONDITION_TYPE_NO_EST) == TRUE then
			event = "W_ItemLadderDrinkNothing"
		elseif IsNodeActive("ItemLadderDrinkingRight_CMSG00") == TRUE then
			event = "W_ItemLadderDrinkingMP"
			event_hand = "Right"
		elseif IsNodeActive("ItemLadderDrinkingLeft_CMSG00") == TRUE then
			event = "W_ItemLadderDrinkingMP"
			event_hand = "Left"
		else
			event = "W_ItemLadderDrinkMPStart"
		end
	elseif item_type == ITEM_NO_DRINK then
		if IsNodeActive("ItemLadderDrinkingMPRight_CMSG") == TRUE or IsNodeActive("ItemLadderDrinkingRight_CMSG") == TRUE then
			event = "W_ItemLadderDrinkEmpty"
			event_hand = "Right"
		elseif IsNodeActive("ItemLadderDrinkingLeft_CMSG") == TRUE or IsNodeActive("ItemLadderDrinkingMPLeft_CMSG")
			== TRUE then
			event = "W_ItemLadderDrinkEmpty"
			event_hand = "Left"
		else
			event = "W_ItemLadderDrinkStart"
		end
	end

	act(SetIsItemAnimationPlaying)
	ExecEvent(event .. event_hand)

	return TRUE
end

function GetWeaponChangeType(hand)
	local left_offset = 0
	local pos = env(GetWeaponStorageSpotType, hand)

	if hand == HAND_LEFT then
		left_offset = 4
	end

	if pos == 0 then
		return WEAPON_CHANGE_REQUEST_RIGHT_WAIST + left_offset
	elseif pos == 1 then
		return WEAPON_CHANGE_REQUEST_RIGHT_BACK + left_offset
	elseif pos == 2 then
		return WEAPON_CHANGE_REQUEST_RIGHT_SHOULDER + left_offset
	elseif pos == 3 then
		return WEAPON_CHANGE_REQUEST_RIGHT_SPEAR + left_offset
	end
	return WEAPON_CHANGE_REQUEST_INVALID
end

function ExecWeaponChange(blend_type)
	local kind = WEAPON_CHANGE_REQUEST_INVALID

	if c_HasActionRequest == FALSE then
		return FALSE
	end
	if env(IsGeneralAnimCancelPossible) == FALSE and env(IsStayState) == FALSE then
		return FALSE
	end
	if env(GetSpEffectID, 100730) == TRUE then
		return FALSE
	end
	if env(ActionRequest, ACTION_ARM_R1) == TRUE or env(ActionRequest, ACTION_ARM_R2) == TRUE then
		if env(ActionDuration, ACTION_ARM_ACTION) > 0 then
			HandChangeTest_ToR1 = FALSE
			HandChangeTest_ToR2 = FALSE
			HandChangeTest_ToL1 = FALSE
			HandChangeTest_ToL2 = FALSE

			if env(ActionRequest, ACTION_ARM_R1) == TRUE then
				HandChangeTest_ToR1 = TRUE
			else
				HandChangeTest_ToR2 = TRUE
			end

			return ExecHandChange(HAND_RIGHT, TRUE, blend_type)
		end
	elseif (env(ActionRequest, ACTION_ARM_L1) == TRUE or env(ActionRequest, ACTION_ARM_L2) == TRUE)
		and env(ActionDuration, ACTION_ARM_ACTION) > 0 then
		HandChangeTest_ToR1 = FALSE
		HandChangeTest_ToR2 = FALSE
		HandChangeTest_ToL1 = FALSE
		HandChangeTest_ToL2 = FALSE

		if env(ActionRequest, ACTION_ARM_L1) == TRUE then
			HandChangeTest_ToL1 = TRUE
		else
			HandChangeTest_ToL2 = TRUE
		end

		return ExecHandChange(HAND_LEFT, TRUE, blend_type)
	end
	if env(ActionRequest, ACTION_ARM_CHANGE_WEAPON_R) == TRUE then
		kind = GetWeaponChangeType(HAND_RIGHT)
	elseif env(ActionRequest, ACTION_ARM_CHANGE_WEAPON_L) == TRUE then
		kind = GetWeaponChangeType(HAND_LEFT)
	else
		return FALSE
	end

	if kind == WEAPON_CHANGE_REQUEST_INVALID then
		return FALSE
	end

	SetVariable("WeaponChangeType", kind)

	if blend_type == ALLBODY and MoveStart(LOWER, Event_Move, FALSE) == TRUE then
		blend_type = UPPER
	end

	local event = Event_WeaponChangeStart

	if c_IsStealth == TRUE then
		event = Event_StealthWeaponChangeStart
	end

	ExecEventHalfBlend(event, blend_type)
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()

	return TRUE
end

function SetHandChangeStyle(s, e)
	SetVariable("HandChangeStartIndex", s)
	SetVariable("HandChangeEndIndex", e)
end

function GetHandChangeType(hand)
	local left_offset = 0
	local pos = env(GetWeaponStorageSpotType, hand)

	if hand == HAND_LEFT then
		left_offset = 4
	end

	if pos == 0 then
		return WEAPON_CHANGE_REQUEST_RIGHT_WAIST + left_offset
	elseif pos == 1 then
		return WEAPON_CHANGE_REQUEST_RIGHT_BACK + left_offset
	elseif pos == 2 then
		return WEAPON_CHANGE_REQUEST_RIGHT_SHOULDER + left_offset
	elseif pos == 3 then
		return WEAPON_CHANGE_REQUEST_RIGHT_SPEAR + left_offset
	end
	return WEAPON_CHANGE_REQUEST_INVALID
end

function ExecJump()
	-- Note: Restored original value during full remake. Repo values was ACTION_ARM_JUMP instead of ACTION_ARM_CHANGE_STYLE
	-- note: Original decompile of 1.10 has ACTION_ARM_CHANGE_STYLE instead of jump
	if env(ActionRequest, ACTION_ARM_CHANGE_STYLE) == FALSE and env(IsAIJumpRequested) == FALSE then
		return FALSE
	end
	if env(GetStamina) <= 0 and env(IsAIJumpRequested) == FALSE then
		ResetRequest()
		return FALSE
	end

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if Cancel_IsOverrideJump() == TRUE then
			if Cancel_IsCooldown() == FALSE then
				Cancel_Execute(GC_ACTIONS.JUMP_CANCEL, TRUE)
			end

			return TRUE
		end
	end
	-- CUSTOM: End.

	if env(GetSpEffectID, 102360) == FALSE then
		AddStamina(STAMINA_REDUCE_JUMP)
	end
	SetWeightIndex()

	-- Jump: Overweight
	if GetVariable("EvasionWeightIndex") == EVASION_WEIGHT_INDEX_OVERWEIGHT and env(IsAIJumpRequested) == FALSE then
		local jumpangle = env(GetJumpAngle) * 0.009999999776482582

		if jumpangle > -45 and jumpangle < 45 then
			SetVariable("JumpOverweightIndex", 0)
		elseif jumpangle >= 0 and jumpangle <= 100 then
			SetVariable("JumpOverweightIndex", 3)
		elseif jumpangle >= -100 and jumpangle <= 0 then
			SetVariable("JumpOverweightIndex", 2)
		else
			SetVariable("JumpOverweightIndex", 1)
		end

		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()
		ExecEventAllBody("W_Jump_Overweight")

		return TRUE
	end

	local style = c_Style

	if style == HAND_RIGHT then
		SetVariable("JumpAttack_HandCondition", 0)
	elseif style == HAND_RIGHT_BOTH then
		SetVariable("JumpAttack_HandCondition", 1)
	elseif style == HAND_LEFT_BOTH then
		if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW) == TRUE then
			SetVariable("JumpAttack_HandCondition", 4)
		else
			SetVariable("JumpAttack_HandCondition", 1)
		end
	end

	SetVariable("JumpAttackForm", 0)
	SetVariable("JumpUseMotion_Bool", false)
	SetVariable("JumpMotion_Override", 0.009999999776482582)
	SetVariable("JumpAttack_Land", 0)
	SetVariable("SwingPose", 0)
	IS_ATTACKED_JUMPMAGIC = FALSE

	if GetVariable("IsEnableToggleDashTest") == 2 then
		SetVariable("ToggleDash", 0)
	end

	local JumpMoveLevel = 0

	if GetVariable("LocomotionState") == 1 and GetVariable("MoveSpeedIndex") == 2 then
		JumpMoveLevel = 2
	elseif GetVariable("MoveSpeedLevel") >= 0.6000000238418579 then
		JumpMoveLevel = 1
	end

	-- Ironjar Aromatic
	if env(GetSpEffectID, 503520) == TRUE then
		JumpMoveLevel = 0
		-- Unknown
	elseif env(GetSpEffectID, 5520) == TRUE then
		JumpMoveLevel = 0
		-- Slug: Slow
	elseif env(GetSpEffectID, 425) == TRUE then
		JumpMoveLevel = 0
		-- Sanguine Noble: Slow
	elseif env(GetSpEffectID, 4101) == TRUE then
		JumpMoveLevel = 0
		-- Sanguine Noble: Slow
	elseif env(GetSpEffectID, 4100) == TRUE then
		JumpMoveLevel = 0
		-- Unknown (DLC)
	elseif env(GetSpEffectID, 19670) == TRUE then
		JumpMoveLevel = 0
	end

	if JumpMoveLevel == 2 then
		if env(IsAIJumpRequested) == TRUE then
			act(NotifyAIOfJumpState)
		end

		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()
		ExecEvent("W_Jump_D")

		return TRUE
	elseif JumpMoveLevel == 1 then
		if GetVariable("IsLockon") == FALSE and env(IsPrecisionShoot) == FALSE and env(IsCOMPlayer) == FALSE then
			SetVariable("JumpDirection", 0)
			SetVariable("JumpAngle", 0)
		else
			local turn_target_angle = 0
			local jumpangle = env(GetJumpAngle) * 0.009999999776482582

			if jumpangle > -45 and jumpangle < 45 then
				turn_target_angle = jumpangle
				SetVariable("JumpDirection", 0)
				SetVariable("JumpAngle", 0)
			elseif jumpangle >= 0 and jumpangle <= 100 then
				turn_target_angle = jumpangle - 90
				SetVariable("JumpDirection", 3)
				SetVariable("JumpAngle", 90)
			elseif jumpangle >= -100 and jumpangle <= 0 then
				turn_target_angle = jumpangle + 90
				SetVariable("JumpDirection", 2)
				SetVariable("JumpAngle", -90)
			else
				turn_target_angle = jumpangle - 180
				SetVariable("JumpDirection", 1)
				SetVariable("JumpAngle", 180)
			end

			if GetVariable("IsLockon") == true then
				act(TurnToLockonTargetImmediately, turn_target_angle)
			else
				act(FaceDirection, turn_target_angle)
			end
		end

		SetVariable("IsEnableDirectionJumpTAE", true)

		if env(IsAIJumpRequested) == TRUE then
			act(NotifyAIOfJumpState)
		end

		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()
		ExecEvent("W_Jump_F")

		return TRUE
	else
		SetVariable("JumpReachSelector", 0)

		if env(IsAIJumpRequested) == TRUE then
			act(NotifyAIOfJumpState)
		end

		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()
		ExecEvent("W_Jump_N")

		return TRUE
	end
end

function ExecJumpLoopDirect(jump_type)
	local style = c_Style

	if style == HAND_RIGHT then
		SetVariable("JumpAttack_HandCondition", 0)
	elseif style == HAND_RIGHT_BOTH then
		SetVariable("JumpAttack_HandCondition", 1)
	elseif style == HAND_LEFT_BOTH then
		if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW) == TRUE then
			SetVariable("JumpAttack_HandCondition", 4)
		else
			SetVariable("JumpAttack_HandCondition", 1)
		end
	end

	SetVariable("JumpAttackForm", 0)
	SetVariable("JumpUseMotion_Bool", false)
	SetVariable("JumpMotion_Override", 0.009999999776482582)
	SetVariable("JumpAttack_Land", 0)
	SetVariable("SwingPose", 0)

	if GetVariable("IsEnableToggleDashTest") == 2 then
		SetVariable("ToggleDash", 0)
	end

	if jump_type == 2 then
		ExecEvent("W_Jump_Loop")
		return TRUE
	elseif GetVariable("MoveSpeedLevel") >= 0.6000000238418579 then
		SetVariable("IsEnableDirectionJumpTAE", true)
		ExecEvent("W_Jump_Loop")
		return TRUE
	else
		SetVariable("JumpReachSelector", 0)
		ExecEvent("W_Jump_Loop")
		return TRUE
	end
end

function ExecHandChange(hand, is_force, blend_type, no_reset)
	if is_force == FALSE then
		if env(IsCOMPlayer) ~= TRUE then
			return FALSE
		end
		if c_HasActionRequest == FALSE or env(IsPrecisionShoot) == TRUE then
			return FALSE
		end
		if env(ActionRequest, ACTION_ARM_CHANGE_STYLE_R) == TRUE and env(ActionDuration, ACTION_ARM_R1) < 100 then
		elseif env(ActionRequest, ACTION_ARM_CHANGE_STYLE_L) == TRUE and env(ActionDuration, ACTION_ARM_L1) < 100 then
			hand = HAND_LEFT
		else
			return FALSE
		end
	end

	local style = c_Style
	local kind = nil

	if style == HAND_RIGHT then
		if hand == HAND_RIGHT then
			if env(IsTwoHandPossible, HAND_RIGHT) == FALSE then
				return FALSE
			end
			kind = GetHandChangeType(HAND_LEFT)
			if kind == WEAPON_CHANGE_REQUEST_LEFT_WAIST then
				if IsDualBladeSpecific(HAND_RIGHT) == TRUE then
					SetHandChangeStyle(LEFT_TO_WAIST, LEFT_FROM_WAIST)
				else
					SetHandChangeStyle(LEFT_TO_WAIST, BOTH_FROM_ALL)
				end
			elseif kind == WEAPON_CHANGE_REQUEST_LEFT_BACK then
				if IsDualBladeSpecific(HAND_RIGHT) == TRUE then
					SetHandChangeStyle(LEFT_TO_BACK, LEFT_FROM_BACK)
				else
					SetHandChangeStyle(LEFT_TO_BACK, BOTH_FROM_ALL)
				end
			elseif kind == WEAPON_CHANGE_REQUEST_LEFT_SHOULDER then
				if IsDualBladeSpecific(HAND_RIGHT) == TRUE then
					SetHandChangeStyle(LEFT_TO_SHOULDER, LEFT_FROM_SHOULDER)
				else
					SetHandChangeStyle(LEFT_TO_SHOULDER, BOTH_FROM_ALL)
				end
			elseif kind == WEAPON_CHANGE_REQUEST_LEFT_SPEAR then
				if IsDualBladeSpecific(HAND_RIGHT) == TRUE then
					SetHandChangeStyle(LEFT_TO_SPEAR, LEFT_FROM_SPEAR)
				else
					SetHandChangeStyle(LEFT_TO_SPEAR, BOTH_FROM_ALL)
				end
			elseif IsDualBladeSpecific(HAND_RIGHT) == TRUE then
				SetHandChangeStyle(LEFT_TO_SPEAR, LEFT_FROM_SPEAR)
			else
				SetHandChangeStyle(LEFT_TO_SPEAR, BOTH_FROM_ALL)
			end
			act(Unknown9999, 1)
		else
			if env(IsTwoHandPossible, HAND_LEFT) == FALSE then
				return FALSE
			end
			kind = GetHandChangeType(HAND_RIGHT)
			if kind == WEAPON_CHANGE_REQUEST_RIGHT_WAIST then
				if IsDualBladeSpecific(HAND_LEFT) == TRUE then
					SetHandChangeStyle(RIGHT_TO_WAIST, RIGHT_FROM_WAIST)
				else
					SetHandChangeStyle(RIGHT_TO_WAIST, BOTHLEFT_FROM_ALL)
				end
			elseif kind == WEAPON_CHANGE_REQUEST_RIGHT_BACK then
				if IsDualBladeSpecific(HAND_LEFT) == TRUE then
					SetHandChangeStyle(RIGHT_TO_BACK, RIGHT_FROM_BACK)
				else
					SetHandChangeStyle(RIGHT_TO_BACK, BOTHLEFT_FROM_ALL)
				end
			elseif kind == WEAPON_CHANGE_REQUEST_RIGHT_SHOULDER then
				if IsDualBladeSpecific(HAND_LEFT) == TRUE then
					SetHandChangeStyle(RIGHT_TO_SHOULDER, RIGHT_FROM_SHOULDER)
				else
					SetHandChangeStyle(RIGHT_TO_SHOULDER, BOTHLEFT_FROM_ALL)
				end
			elseif kind == WEAPON_CHANGE_REQUEST_RIGHT_SPEAR then
				if IsDualBladeSpecific(HAND_LEFT) == TRUE then
					SetHandChangeStyle(RIGHT_TO_SPEAR, RIGHT_FROM_SPEAR)
				else
					SetHandChangeStyle(RIGHT_TO_SPEAR, BOTHLEFT_FROM_ALL)
				end
			elseif IsDualBladeSpecific(HAND_RIGHT) == TRUE then
				SetHandChangeStyle(RIGHT_TO_BACK, RIGHT_FROM_BACK)
			else
				SetHandChangeStyle(RIGHT_TO_BACK, BOTHLEFT_FROM_ALL)
			end
			act(Unknown9999, 2)
		end
	elseif style == HAND_RIGHT_BOTH then
		kind = GetHandChangeType(HAND_LEFT)
		if kind == WEAPON_CHANGE_REQUEST_LEFT_WAIST then
			SetHandChangeStyle(BOTH_TO_WAIST, LEFT_FROM_WAIST)
		elseif kind == WEAPON_CHANGE_REQUEST_LEFT_BACK then
			SetHandChangeStyle(BOTH_TO_BACK, LEFT_FROM_BACK)
		elseif kind == WEAPON_CHANGE_REQUEST_LEFT_SHOULDER then
			SetHandChangeStyle(BOTH_TO_SHOULDER, LEFT_FROM_SHOULDER)
		else
			SetHandChangeStyle(BOTH_TO_BACK, LEFT_FROM_BACK)
		end
		act(Unknown9999, 3)
	elseif style == HAND_LEFT_BOTH then
		kind = GetHandChangeType(HAND_RIGHT)
		if kind == WEAPON_CHANGE_REQUEST_RIGHT_WAIST then
			SetHandChangeStyle(BOTHRIGHT_TO_WAIST, RIGHT_FROM_WAIST)
		elseif kind == WEAPON_CHANGE_REQUEST_RIGHT_BACK then
			SetHandChangeStyle(BOTHRIGHT_TO_BACK, RIGHT_FROM_BACK)
		elseif kind == WEAPON_CHANGE_REQUEST_RIGHT_SHOULDER then
			SetHandChangeStyle(BOTHRIGHT_TO_SHOULDER, RIGHT_FROM_SHOULDER)
		else
			SetHandChangeStyle(BOTHRIGHT_TO_BACK, RIGHT_FROM_SPEAR)
		end
		act(Unknown9999, 1)
	end
	if blend_type == ALLBODY then
		local move_event = Event_Move
		if c_IsStealth == TRUE then
			move_event = Event_Stealth_Move
		end
		if MoveStart(LOWER, move_event, FALSE) == TRUE then
			blend_type = UPPER
		end
	end
	local event = Event_HandChangeStart
	if c_IsStealth == TRUE then
		event = Event_StealthHandChangeStart
	end
	if no_reset == TRUE then
		ExecEventHalfBlendNoReset(event, blend_type)
	else
		ExecEventHalfBlend(event, blend_type)
	end
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()
	return TRUE
end

function GetEvasionRequest()
	if env(GetStamina) < STAMINA_MINIMUM then
		return ATTACK_REQUEST_INVALID
	end
	if env(ActionRequest, ACTION_ARM_ROLLING) == TRUE then
		return ATTACK_REQUEST_ROLLING
	elseif env(ActionDuration, ACTION_ARM_L1) > 0 then
		if env(ActionRequest, ACTION_ARM_EMERGENCYSTEP) == TRUE then
			if env(IsEmergencyEvasionPossible, 0) == TRUE or env(IsEmergencyEvasionPossible, 1) == TRUE then
				return ATTACK_REQUEST_EMERGENCYSTEP
			end
		elseif env(ActionRequest, ACTION_ARM_BACKSTEP) == TRUE then
			return ATTACK_REQUEST_BACKSTEP
		else
			return ATTACK_REQUEST_INVALID
		end
	elseif env(ActionRequest, ACTION_ARM_BACKSTEP) == TRUE then
		return ATTACK_REQUEST_BACKSTEP
	end
	return ATTACK_REQUEST_INVALID
end

HandChangeControlTest8_RelaeseA = TRUE
c_RollingAngle = 0
c_ArtsRollingAngle = 0

function ExecEvasion(backstep_limit, estep, is_usechainrecover)
	if c_HasActionRequest == FALSE then
		return FALSE
	end

	local request = GetEvasionRequest()

	if env(ActionRequest, ACTION_ARM_L3) == TRUE and c_IsStealth == FALSE then
		StealthTransitionIndexUpdate()
		ExecEvent("W_Stealth_to_Stealth_Idle")
		return TRUE
	elseif env(ActionRequest, ACTION_ARM_L3) == TRUE and c_IsStealth == TRUE then
		StealthTransitionIndexUpdate()
		ExecEvent("W_Stealth_to_Idle")
		return TRUE
	end
	if request == ATTACK_REQUEST_INVALID then
		return FALSE
	end
	if backstep_limit == TRUE and request == ATTACK_REQUEST_BACKSTEP and env(GetEventEzStateFlag, 0) == TRUE then
		return FALSE
	end

	SetWeightIndex()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if Cancel_IsOverrideEvasion() == TRUE then
			if request == ATTACK_REQUEST_ROLLING or request == ATTACK_REQUEST_BACKSTEP or request == ATTACK_REQUEST_EMERGENCYSTEP then
				ResetRequest()
				if DMN_ActionCancel_Mode == GC_MODES.ACTION_CANCEL_DEFAULT and Action_IsEvadingPossible() == TRUE then
					Cancel_Execute(GC_ACTIONS.EVASION_CANCEL, TRUE)
				end

				return TRUE
			end

			return FALSE
		end
	end
	-- CUSTOM: End.

	-----------------------
	-- Roll
	-----------------------
	if request == ATTACK_REQUEST_ROLLING then
		if is_usechainrecover == TRUE then
			local damagecount = GetVariable("DamageCount")
			if damagecount >= 4 then
				if env(GetEventEzStateFlag, 5) == FALSE then
					return FALSE
				end
			elseif damagecount == 3 then
				if env(GetEventEzStateFlag, 4) == FALSE then
					return FALSE
				end
			elseif damagecount == 2 then
				if env(GetEventEzStateFlag, 3) == FALSE then
					return FALSE
				end
			elseif damagecount <= 1 and env(GetEventEzStateFlag, 2) == FALSE then
				if env(GetSpEffectID, 100720) == TRUE then
					ResetRequest()
				end
				return FALSE
			end
		end

		if env(GetStamina) <= 0 then
			ResetRequest()
			return FALSE
		end
		if env(GetFallHeight) > 150 then
			return FALSE
		end

		local rollingEvent = "W_Rolling"
		local is_selfTrans = FALSE

		if IsNodeActive("Rolling_CMSG") == TRUE then
			is_selfTrans = TRUE
		end

		if estep == ESTEP_DOWN then
			rollingEvent = "W_EStepDown"
		elseif c_IsStealth == TRUE and GetVariable("EvasionWeightIndex") ~= EVASION_WEIGHT_INDEX_OVERWEIGHT then
			rollingEvent = "W_Stealth_Rolling"
		elseif is_selfTrans == TRUE then
			rollingEvent = rollingEvent .. "_Selftrans"
		end

		if env(GetSpEffectID, 102360) == FALSE then
			AddStamina(STAMINA_REDUCE_ROLLING)
		end

		if GetVariable("IsEnableToggleDashTest") == 2 then
			SetVariable("ToggleDash", 0)
		end

		local turn_angle_real = 200

		if GetVariable("IsLockon") == false and env(IsPrecisionShoot) == FALSE and env(IsCOMPlayer) == FALSE
			or env(GetSpEffectID, 100002) == TRUE then
			SetVariable("RollingOverweightIndex", 0)

			if is_selfTrans == TRUE then
				SetVariable("RollingDirectionIndex_SelfTrans", 0)
			else
				SetVariable("RollingDirectionIndex", 0)
			end
		elseif GetVariable("EvasionWeightIndex") == EVASION_WEIGHT_INDEX_OVERWEIGHT then
			if c_RollingAngle <= 45 and c_RollingAngle >= -45 then
				SetVariable("RollingOverweightIndex", 0)
			elseif c_RollingAngle > 45 and c_RollingAngle < 135 then
				SetVariable("RollingOverweightIndex", 3)
			elseif c_RollingAngle >= 135 then
				SetVariable("RollingOverweightIndex", 1)
			elseif c_RollingAngle < -45 and c_RollingAngle > -135 then
				SetVariable("RollingOverweightIndex", 2)
			else
				SetVariable("RollingOverweightIndex", 1)
			end

			act(TurnToLockonTargetImmediately)

			turn_angle_real = math.abs(GetVariable("TurnAngle") - c_RollingAngle)

			if turn_angle_real > 180 then
				turn_angle_real = 360 - turn_angle_real
			end
		else
			local turn_target_angle = 0
			local rollingDirection = 0

			if c_RollingAngle <= GetVariable("RollingAngleThresholdRightFrontTest") and c_RollingAngle
				>= GetVariable("RollingAngleThresholdLeftFrontTest") then
				rollingDirection = 0
				turn_target_angle = c_RollingAngle
			elseif c_RollingAngle > GetVariable("RollingAngleThresholdRightFrontTest") and c_RollingAngle
				< GetVariable("RollingAngleThresholdRightBackTest") then
				rollingDirection = 3
				turn_target_angle = c_RollingAngle - 90
			elseif c_RollingAngle < GetVariable("RollingAngleThresholdLeftFrontTest") and c_RollingAngle
				> GetVariable("RollingAngleThresholdLeftBackTest") then
				rollingDirection = 2
				turn_target_angle = c_RollingAngle + 90
			else
				rollingDirection = 1
				turn_target_angle = c_RollingAngle - 180
			end

			if is_selfTrans == TRUE then
				SetVariable("RollingDirectionIndex_SelfTrans", rollingDirection)
			else
				SetVariable("RollingDirectionIndex", rollingDirection)
			end

			if GetVariable("IsLockon") == true then
				act(TurnToLockonTargetImmediately, turn_target_angle)
			else
				act(FaceDirection, turn_target_angle)
			end

			turn_angle_real = math.abs(GetVariable("TurnAngle") - c_RollingAngle)

			if turn_angle_real > 180 then
				turn_angle_real = 360 - turn_angle_real
			end
		end

		SetVariable("TurnAngleReal", turn_angle_real)

		if is_selfTrans == TRUE then
			SetVariable("RollingAngleRealSelftrans", c_RollingAngle)
		else
			SetVariable("RollingAngleReal", c_RollingAngle)
		end

		-- CUSTOM: Begin.
		if Game_IsPlayer() == TRUE then
			if Cancel_IsCooldown() == FALSE then
				Cancel_AddCooldown(GV_Cancel.RollCooldown)
			end

			if DMN_EvasionAction_Mode ~= GC_MODES.EVASION_ACTIONS_DEFAULT then
				local rollingDirection = 0
				if c_RollingAngle <= GetVariable("RollingAngleThresholdRightFrontTest") and c_RollingAngle
					>= GetVariable("RollingAngleThresholdLeftFrontTest") then
					rollingDirection = 0
				elseif c_RollingAngle > GetVariable("RollingAngleThresholdRightFrontTest") and c_RollingAngle
					< GetVariable("RollingAngleThresholdRightBackTest") then
					rollingDirection = 3
				elseif c_RollingAngle < GetVariable("RollingAngleThresholdLeftFrontTest") and c_RollingAngle
					> GetVariable("RollingAngleThresholdLeftBackTest") then
					rollingDirection = 2
				else
					rollingDirection = 1
				end

				Action_Dash(rollingDirection)
				rollingEvent = ""
			end
		end
		-- CUSTOM: End.

		ExecEventAllBody(rollingEvent)
	elseif request == ATTACK_REQUEST_EMERGENCYSTEP then
		if MoveStart(ALLBODY, Event_ChainRecover, FALSE) then
		else
			return FALSE
		end
	elseif request == ATTACK_REQUEST_BACKSTEP then
		ResetDamageCount()

		if env(GetStamina) <= 0 then
			ResetRequest()
			return FALSE
		end
		if env(GetSpEffectID, 102360) == FALSE then
			AddStamina(STAMINA_REDUCE_BACKSTEP)
		end

		-- CUSTOM: Begin.
		if Game_IsPlayer() == TRUE then
			if Cancel_IsCooldown() == FALSE then
				Cancel_AddCooldown(GV_Cancel.StepCooldown)
			end

			if DMN_EvasionAction_Mode ~= GC_MODES.EVASION_ACTIONS_DEFAULT then
				Action_Dash(1)

				if GetVariable("IsEnableToggleDashTest") == 2 then
					SetVariable("ToggleDash", 0)
				end

				act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
				SetAIActionState()

				return TRUE
			end
		end
		-- CUSTOM: End.

		if IsEnableGuard() == TRUE and IsGuard() == TRUE and GetVariable("EvasionWeightIndex")
			~= EVASION_WEIGHT_INDEX_OVERWEIGHT then
			SetVariable("BackStepGuardLayer", 1)
			SetVariable("EnableTAE_BackStep", false)
			ExecEvent("W_DefaultBackStep")
			ExecEvent("W_BackStepGuardOn_UpperLayer")
		else
			SetVariable("BackStepGuardLayer", 0)
			SetVariable("EnableTAE_BackStep", true)
			ExecEventAllBody("W_DefaultBackStep")
		end
	else
		return FALSE
	end

	if GetVariable("IsEnableToggleDashTest") == 2 then
		SetVariable("ToggleDash", 0)
	end

	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()

	return TRUE
end

function IsGuard()
	if env(ActionRequest, ACTION_ARM_L1) == TRUE or env(ActionDuration, ACTION_ARM_L1) > 0 then
		return TRUE
	end
	return FALSE
end

function ExecQuickTurn(blend_type, turn_type)

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if Effect_IsActive(GC_SPEIDS.STRING_MASTER_STATUS_AIR) == TRUE then
			return FALSE
		end
	end
	-- CUSTOM: End.

	if blend_type == LOWER and IsLowerQuickTurn() == TRUE then
		return FALSE
	end
	if GetVariable("IsLockon") == false then
		return FALSE
	end

	if env(GetSpEffectID, 19946) == TRUE then
		return FALSE
	end

	local turn_angle = GetVariable("TurnAngle")
	if math.abs(turn_angle) < 45 then
		return FALSE
	end

	SetVariable("TurnType", turn_type)
	if turn_angle >= 45 then
		ExecEventHalfBlend(Event_QuickTurnRight180, blend_type)
	else
		ExecEventHalfBlend(Event_QuickTurnLeft180, blend_type)
	end
	return TRUE
end

function ExecDashTurn()
	if GetVariable("MoveSpeedLevel") <= 0 then
		return FALSE
	end

	local angle = math.abs(hkbGetVariable("TurnAngle"))
	if angle > 90 then
		ExecEventAllBody("W_Dash180")
		return TRUE
	end

	return FALSE
end

function ExitQuickTurnLower()
	if env(IsAnimEnd, 2) == TRUE or env(GetEventEzStateFlag, 1) == TRUE then
		return TRUE
	end
	if GetVariable("IsLockon") == false then
		return TRUE
	end
	return FALSE
end

function ExecQuickTurnOnCancelTiming()
	if env(IsMoveCancelPossible) == FALSE then
		return FALSE
	end
	if ExecQuickTurn(ALLBODY, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	return FALSE
end

function ExecFallStart(fall_type)
	if env(IsFalling) == FALSE then
		return FALSE
	end
	if fall_type == FALL_TYPE_DEFAULT then
		ExecEventAllBody("W_FallStart")
	elseif fall_type == FALL_TYPE_JUMP then
		if env(GetGeneralTAEFlag, 0) == TRUE then
			ExecEventAllBody("W_FallJumpStart")
		else
			ExecEventNoReset("W_FallStart")
		end
	elseif fall_type == FALL_TYPE_FACEDOWN_LOOP then
		ExecEventAllBody("W_FallLoopFaceDown")
	elseif fall_type == FALL_TYPE_FACEDOWN then
		ExecEventAllBody("W_FallStartFaceDown")
	elseif fall_type == FALL_TYPE_FACEUP_LOOP then
		ExecEventAllBody("W_FallLoopFaceUp")
	elseif fall_type == FALL_TYPE_FACEUP then
		ExecEventAllBody("W_FallStartFaceUp")
	else
		local damage_angle = env(GetReceivedDamageDirection)
		if damage_angle == DAMAGE_DIR_BACK then
			if fall_type == FALL_TYPE_FORCE_LOOP then
				ExecEventAllBody("W_FallLoopFaceDown")
			else
				ExecEventAllBody("W_FallStartFaceDown")
			end
		elseif fall_type == FALL_TYPE_FORCE_LOOP then
			ExecEventAllBody("W_FallLoopFaceUp")
		else
			ExecEventAllBody("W_FallStartFaceUp")
		end
	end
	return TRUE
end

function ExecAddDamage(damage_dir, attack_dir, damage_level, is_guard, is_damaged, is_justGuard)
	if is_damaged == FALSE then
		return
	end
	if env(GetBehaviorID, 2) == TRUE then
		return
	end
	if is_guard == TRUE and is_justGuard == TRUE and env(GetSpEffectID, 102022) == TRUE then
		return
	end

	if is_guard == TRUE then
		SetVariable("AddDamageGuardBlend", 1)
	else
		SetVariable("AddDamageLv0_Blend", 1)
		local pre_index = GetVariable("IndexDamageLv0_Random")
		local index = (pre_index + math.random(1, 2)) % 3
		SetVariable("IndexDamageLv0_Random", index)
	end

	if is_guard == TRUE and is_justGuard == TRUE then
		act(AddSpEffect, 102020)
		act(AddSpEffect, 102022)
		ExecEventNoReset("W_AddDamageJustGuardStartFront")
		return
	end

	if damage_dir == DAMAGE_DIR_LEFT then
		if attack_dir == ATTACK_DIR_FRONT then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartLeft")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_UP then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartLeft")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_DOWN then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartLeft")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_LEFT then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartFront")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_RIGHT then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartBack")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		end
	elseif damage_dir == DAMAGE_DIR_RIGHT then
		if attack_dir == ATTACK_DIR_FRONT then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartRight")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_UP then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartRight")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_DOWN then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartRight")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_LEFT then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartBack")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_RIGHT then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartFront")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		end
	elseif damage_dir == DAMAGE_DIR_FRONT then
		if attack_dir == ATTACK_DIR_FRONT then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartFront")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_UP then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartFront")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_DOWN then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartFront")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_LEFT then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartRight")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		elseif attack_dir == ATTACK_DIR_RIGHT then
			if is_guard == TRUE then
				ExecEventNoReset("W_AddDamageGuardStartLeft")
				return
			else
				ExecEventNoReset("W_AddDamageLv0")
				return
			end
		end
	elseif damage_dir == DAMAGE_DIR_BACK then
		ExecEventNoReset("W_AddDamageLv0")
	end
end

function ExecPassiveAction(is_parry, fall_type, is_attackwhileguard)
	if env(HasThrowRequest) == TRUE then
		ResetDamageCount()
		return TRUE
	end
	if ExecDeath() == TRUE then
		return TRUE
	end
	if env(ActionRequest, ACTION_ARM_BUDDY_DISAPPEAR) == TRUE then
		ExecEventAllBody("W_Event60505")
		return TRUE
	end
	if ExecTalk() == TRUE then
		ResetDamageCount()
		return TRUE
	end
	if ExecMovableEventAnim() == TRUE then
		ResetDamageCount()
		return TRUE
	end
	if env(CheckForEventAnimPlaybackRequest) == TRUE then
		ResetDamageCount()
		return TRUE
	end
	if ExecDamage(is_parry, is_attackwhileguard) == TRUE then
		return TRUE
	end
	if ExecFallStart(fall_type) == TRUE then
		ResetDamageCount()
		return TRUE
	end
	return FALSE
end

function ExecMovableEventAnim()
	local eventID = env(GetEventID)
	local commandID = env(GetCommandIDFromEvent, 0)
	if eventID <= -1 and not (commandID >= 60070 and commandID <= 60071) then
		return FALSE
	end
	local event = Event_EventHalfBlend60071
	if eventID == 60071 or commandID == 60071 then
		event = Event_EventHalfBlend60071
	elseif eventID == 60070 or commandID == 60070 then
		if c_IsStealth == TRUE then
			event = Event_EventHalfBlend360070
		else
			event = Event_EventHalfBlend60071
		end
	else
		ExecEventAllBody("W_Event" .. eventID)
		return TRUE
	end
	local lower_state = ALLBODY
	local locomotion = GetVariable("LocomotionState")
	if locomotion == PLAYER_STATE_MOVE then
		lower_state = UPPER
	end
	ExecEventHalfBlend(event, lower_state)
	return TRUE
end

function ExecRideEventAnim()
	local eventID = env(GetEventID)
	if eventID <= -1 then
		return FALSE
	end
	if eventID == 60070 then
		ExecEventAllBody("W_Event160070")
	elseif eventID == 50250 then
		ExecEventAllBody("W_Event150250")
	else
		return FALSE
	end
	return TRUE
end

function IsLandDead(height)
	if env(GetHP) <= 0 then
		return TRUE
	elseif height > 20 and env(IsInvincibleDebugMode) == FALSE and env(GetStateChangeType, 266) == FALSE then
		return TRUE
	end
	return FALSE
end

function ExecDeath()
	if env(GetReceivedDamageType) == DAMAGE_TYPE_DEATH or env(GetHP) <= 0 then
		if env(GetSpEffectID, 560) == TRUE then
			return FALSE
		end

		local damage_angle = env(GetReceivedDamageDirection)
		SetVariable("DamageDirection", damage_angle)

		if env(GetKnockbackDistance) < 0 then
			if damage_angle == DAMAGE_DIR_LEFT then
				damage_angle = DAMAGE_DIR_RIGHT
			elseif damage_angle == DAMAGE_DIR_RIGHT then
				damage_angle = DAMAGE_DIR_LEFT
			elseif damage_angle == DAMAGE_DIR_FRONT then
				damage_angle = DAMAGE_DIR_BACK
			elseif damage_angle == DAMAGE_DIR_BACK then
				damage_angle = DAMAGE_DIR_FRONT
			end
		end

		local damage_level = env(GetDamageLevel)

		if env(GetDamageSpecialAttribute, 3) == TRUE then
			SetVariable("IndexDeath", DEATH_TYPE_STONE)
		elseif env(GetSpEffectID, 19700) == TRUE then
			SetVariable("IndexDeath", DEATH_TYPE_CRY)
		elseif env(GetSpEffectID, 102351) == TRUE then
			SetVariable("IndexDeath", DEATH_TYPE_SLEEP)
		elseif env(GetSpEffectID, 9913) == TRUE then
			SetVariable("IndexDeath", DEATH_TYPE_TRINA_EVENT)
		elseif env(GetSpecialAttribute) == 25 then
			act(DebugLogOutput, "DEATY_TYPE_MAD")
			SetVariable("IndexDeath", DEATH_TYPE_MAD)
		elseif env(IsOnLadder) == TRUE then
			SetVariable("IndexDeath", DEATH_TYPE_LADDER)
		elseif env(GetIsWeakPoint) == TRUE then
			SetVariable("IndexDeath", DEATH_TYPE_WEAK)
		elseif damage_level == DAMAGE_LEVEL_EXLARGE or damage_level == DAMAGE_LEVEL_SMALL_BLOW then
			SetVariable("IndexDeath", DEATH_TYPE_BLAST)
		elseif damage_level == DAMAGE_LEVEL_UPPER then
			SetVariable("IndexDeath", DEATH_TYPE_UPPER)
		elseif damage_level == DAMAGE_LEVEL_FLING then
			SetVariable("IndexDeath", DEATH_TYPE_FLING)
		elseif env(GetSpecialAttribute) == DAMAGE_ELEMENT_POISON or env(GetSpecialAttribute) == DAMAGE_ELEMENT_BLIGHT then
			SetVariable("IndexDeath", DEATH_TYPE_POISON)
		else
			local damageState = 0
			local physicalType = env(GetPhysicalAttribute)
			local elementType = env(GetSpecialAttribute)
			local deathRandom = math.random(0, 100)

			if elementType == DAMAGE_ELEMENT_FIRE then
				damageState = 4
			elseif physicalType == DAMAGE_PHYSICAL_SLASH and deathRandom < 70 then
				damageState = 1
			elseif physicalType == DAMAGE_PHYSICAL_THRUST and deathRandom < 70 then
				damageState = 2
			elseif physicalType == DAMAGE_PHYSICAL_BLUNT and deathRandom < 70 then
				damageState = 3
			end

			SetVariable("DamageState", damageState)

			act(DebugLogOutput, "DeathStart DamageState=" .. damageState .. " rand=" .. deathRandom)
			local isMad = env(GetDamageSpecialAttribute, 6)
			act(DebugLogOutput, "elementType=" .. elementType .. " IsMad=" .. isMad)

			if damage_angle == DAMAGE_DIR_BACK then
				SetVariable("IndexDeath", DEATH_TYPE_COMMON_BACK)
			else
				SetVariable("IndexDeath", DEATH_TYPE_COMMON)
			end
		end

		-- CUSTOM: Begin.
		if Game_IsPlayer() == TRUE then
			if Player_IsRevivePossible() == TRUE then
				Player_AutoRevive()

				SetVariable("DamageState", 0)
				SetVariable("IndexDeath", DEATH_TYPE_COMMON)
			end
		end
		-- CUSTOM: End.

		ExecEventAllBody("W_DeathStart")
		return TRUE
	elseif env(IsInvincibleDebugMode) == FALSE then
		if env(GetStateChangeType, CONDITION_TYPE_STONE) == TRUE or env(GetStateChangeType, CONDITION_TYPE_CRYSTAL)
			== TRUE or env(GetDamageSpecialAttribute, 3) == TRUE then
			SetVariable("IndexDeath", DEATH_TYPE_STONE)
			ExecEventAllBody("W_DeathStart")
			return TRUE
		elseif env(GetSpEffectID, 19700) == TRUE then
			SetVariable("IndexDeath", DEATH_TYPE_CRY)
			ExecEventAllBody("W_DeathStart")
			return TRUE
		elseif env(GetSpEffectID, 102351) == TRUE then
			SetVariable("IndexDeath", DEATH_TYPE_SLEEP)
			ExecEventAllBody("W_DeathStart")
			return TRUE
		end
	end
end

function CalcDamageCount()
	act(DebugLogOutput, "Calc DamageCount")

	if env(GetBehaviorID, 9) == TRUE then
		SetVariable("UseChainRecover", 1)
		return
	else
		local damagecount = GetVariable("DamageCount")

		SetVariable("DamageCount", damagecount + 1)
		SetVariable("UseChainRecover", 1)
	end
end

function ResetDamageCount()
	SetVariable("DamageCount", 0)
	SetVariable("UseChainRecover", 0)
end

function ExecDamage(is_parry, is_attackwhileguard)
	local damage_level = env(GetDamageLevel)
	local damage_type = env(GetReceivedDamageType)
	local is_damaged = env(HasReceivedAnyDamage)
	if env(GetSpEffectType, 32) == TRUE and env(GetSpEffectID, 19925) == FALSE then
		act(SetDamageAnimType, DAMAGE_FLAG_SMALL)
		ResetRequest()
		ExecEventAllBody("W_DamageBind")
		Replanning()

		return TRUE
	end
	if env(GetDamageSpecialAttribute, 5) == TRUE then
		ExecEventAllBody("W_DamageSleepResist")
		return TRUE
	end
	if env(GetDamageSpecialAttribute, 6) == TRUE then
		ExecEventAllBody("W_DamageMad")
		return TRUE
	end
	if env(GetDamageSpecialAttribute, 2) == TRUE or env(GetDamageSpecialAttribute, 4) == TRUE then
		if damage_level == DAMAGE_LEVEL_NONE then
			if IsNodeActive("SwordArtsOneShot Selector") == TRUE and c_SwordArtsID == 136 then
			elseif env(GetSpEffectID, 6340) == TRUE or env(GetSpEffectID, 1650) == TRUE or env(GetSpEffectID, 1851)
				== TRUE then
			else
				damage_level = DAMAGE_LEVEL_SMALL
			end
		elseif damage_level ~= DAMAGE_LEVEL_SMALL and damage_level ~= DAMAGE_LEVEL_MIDDLE and damage_level
			== DAMAGE_LEVEL_MINIMUM then
		end
	end

	if damage_level <= DAMAGE_LEVEL_NONE and (is_damaged == FALSE or env(IsPartDamageAdditiveBlendInvalid) == TRUE)
		and (damage_type == DAMAGE_TYPE_INVALID or damage_type == DAMAGE_TYPE_WEAK_POINT or damage_type
			== DAMAGE_LEVEL_MINIMUM) then
		return FALSE
	end
	if env(GetBehaviorID, 1) == TRUE then
		return FALSE
	end
	-- Raptors of the Mist Dodge
	if env(GetSpEffectID, 100500) == TRUE then
		ExecEventAllBody("W_SwordArtsStandDodge")
		act(AddSpEffect, 5635)
		ResetDamageCount()

		return TRUE
	end

	local attack_dir = env(GetAtkDirection)
	local damage_angle = env(GetReceivedDamageDirection)
	local style = c_Style

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if env(HasReceivedAnyDamage) == TRUE then
			if Combo_IsGuardStance() == TRUE and 0 < Stat_GetSP() and Effect_IsActive(GC_SPEIDS.DEFLECT_COUNTER) == FALSE then
				Deflect_Protect(Deflect_IsActive())
				Timer_AddAction(System_MillisecondsToFrames(50), System_MillisecondsToFrames(50), nil, nil, Combo_ExecuteGuardStanceAttack, nil)
				return TRUE
			end

			if Deflect_IsActive() == TRUE and Effect_IsActive(GC_SPEIDS.DEFLECT_COUNTER) == FALSE then
				if Deflect_Protect(TRUE) == TRUE then
					return TRUE
				end
			end

			if Status_IsInvisible() == TRUE then
				return TRUE
			end
		end
	end
	-- CUSTOM: End.

	if damage_type == DAMAGE_TYPE_PARRY then
		ExecEventAllBody("W_DamageParry")
		return TRUE
	end

	if damage_type >= DAMAGE_TYPE_GUARDED and damage_type <= DAMAGE_TYPE_WALL_LEFT then
		DebugPrint(1, damage_type)
		Replanning()

		if damage_type == DAMAGE_TYPE_GUARDED or damage_type == DAMAGE_TYPE_GUARDED_LEFT then
			if damage_type == DAMAGE_TYPE_GUARDED_LEFT then
				SetVariable("GuardDamageIndex", 2)
			elseif style == HAND_RIGHT then
				SetVariable("GuardDamageIndex", 0)
			elseif style == HAND_LEFT or style == HAND_RIGHT_BOTH then
				SetVariable("GuardDamageIndex", 1)
			else
				SetVariable("GuardDamageIndex", 0)
			end

			if damage_level == DAMAGE_LEVEL_NONE or damage_level == DAMAGE_LEVEL_MINIMUM then
				act(SetDamageAnimType, DAMAGE_FLAG_SMALL)
				ExecEventAllBody("W_Repelled_Small")
			elseif damage_level == DAMAGE_LEVEL_SMALL then
				act(SetDamageAnimType, DAMAGE_FLAG_SMALL)
				ExecEventAllBody("W_Repelled_Small")
			elseif damage_level == DAMAGE_LEVEL_MIDDLE or damage_level == DAMAGE_LEVEL_LARGE or damage_level
				== DAMAGE_LEVEL_EXLARGE or damage_level == DAMAGE_LEVEL_PUSH or damage_level == DAMAGE_LEVEL_FLING
				or damage_level == DAMAGE_LEVEL_SMALL_BLOW or damage_level == DAMAGE_LEVEL_UPPER or damage_level
				== DAMAGE_LEVEL_EX_BLAST or damage_level == DAMAGE_LEVEL_BREATH then
				act(SetDamageAnimType, DAMAGE_FLAG_LARGE)
				ExecEventAllBody("W_Repelled_Large")
			else
				act(SetDamageAnimType, DAMAGE_FLAG_SMALL)
				ExecEventAllBody("W_Repelled_Small")
			end

			return TRUE
		elseif damage_type == DAMAGE_TYPE_GUARDBREAK then
			if is_parry == TRUE then
				return FALSE
			end
			if env(GetSpEffectID, 175) == TRUE then
				return FALSE
			end

			local guardindex = GUARD_STYLE_DEFAULT

			if style == HAND_RIGHT then
				guardindex = env(GetGuardMotionCategory, HAND_LEFT)

				if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_TORCH) == TRUE then
					SetVariable("IsTorchGuard", TRUE)
				else
					SetVariable("IsTorchGuard", FALSE)
				end

				if env(GetEquipWeaponCategory, HAND_LEFT) == WEAPON_CATEGORY_DUELING_SHIELD then
					guardindex = 3
				end

				if env(GetEquipWeaponCategory, HAND_RIGHT) == WEAPON_CATEGORY_DUELING_SHIELD then
					guardindex = 3
					if env(GetSpEffectID, 176) == TRUE then
						SetVariable("GuardBreakDuelingShieldState", 1)
					end
				end
			elseif style == HAND_LEFT_BOTH then
				SetVariable("IsTorchGuard", FALSE)

				if env(GetStayAnimCategory) == 15 then
					guardindex = env(GetGuardMotionCategory, HAND_LEFT)
				end

				if env(GetEquipWeaponCategory, HAND_LEFT) == WEAPON_CATEGORY_DUELING_SHIELD then
					guardindex = 3
				end
			elseif style == HAND_RIGHT_BOTH then
				SetVariable("IsTorchGuard", FALSE)

				if env(GetStayAnimCategory) == 15 then
					guardindex = env(GetGuardMotionCategory, HAND_RIGHT)
				end

				if env(GetEquipWeaponCategory, HAND_RIGHT) == WEAPON_CATEGORY_DUELING_SHIELD then
					guardindex = 3
				end
			end

			SetVariable("IndexGuard", guardindex)
			act(SetDamageAnimType, DAMAGE_FLAG_GUARD_BREAK)

			if c_SwordArtsID == 202 and style == HAND_RIGHT and c_SwordArtsHand == HAND_RIGHT then
				ExecEventAllBody("W_GuardBreakRight")
			else
				ExecEventAllBody("W_GuardBreak")
			end

			return TRUE
		elseif damage_type == DAMAGE_TYPE_WALL_RIGHT then
			if style == HAND_RIGHT_BOTH or style == HAND_LEFT_BOTH then
				SetVariable("GuardDamageIndex", 1)
			else
				SetVariable("GuardDamageIndex", 0)
			end

			act(SetDamageAnimType, DAMAGE_FLAG_GUARD_BREAK)
			ExecEventAllBody("W_Repelled_Wall")

			return TRUE
		elseif damage_type == DAMAGE_TYPE_WALL_LEFT then
			if style == HAND_LEFT_BOTH then
				SetVariable("GuardDamageIndex", 1)
			else
				SetVariable("GuardDamageIndex", 2)
			end

			act(SetDamageAnimType, DAMAGE_FLAG_GUARD_BREAK)
			ExecEventAllBody("W_Repelled_Wall")

			return TRUE
		elseif damage_type == DAMAGE_TYPE_GUARDBREAK_BLAST then
			act(SetDamageAnimType, DAMAGE_FLAG_SMALL_BLOW)
			ExecEventAllBody("W_DamageLv7_SmallBlow")

			return TRUE
		elseif damage_type == DAMAGE_TYPE_GUARDBREAK_FLING then
			act(SetDamageAnimType, DAMAGE_FLAG_FLING)
			ExecEventAllBody("W_DamageLv6_Fling")

			return TRUE
		end
	elseif damage_type == DAMAGE_TYPE_GUARD then
		if is_parry == TRUE or is_attackwhileguard == TRUE then
			return FALSE
		end
		if env(GetSpEffectID, 175) == TRUE then
			return FALSE
		end
		if env(GetSpEffectID, 176) == TRUE then
			return FALSE
		end

		local guardindex = GUARD_STYLE_DEFAULT

		if style == HAND_RIGHT then
			guardindex = env(GetGuardMotionCategory, HAND_LEFT)

			if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_TORCH) == TRUE then
				SetVariable("IsTorchGuard", TRUE)
			else
				SetVariable("IsTorchGuard", FALSE)
			end

			if env(GetEquipWeaponCategory, HAND_LEFT) == WEAPON_CATEGORY_DUELING_SHIELD then
				guardindex = 3
			end
		elseif style == HAND_LEFT_BOTH then
			SetVariable("IsTorchGuard", FALSE)

			if env(GetStayAnimCategory) == 15 then
				guardindex = env(GetGuardMotionCategory, HAND_LEFT)
			end

			if env(GetEquipWeaponCategory, HAND_LEFT) == WEAPON_CATEGORY_DUELING_SHIELD then
				guardindex = 3
			end
		elseif style == HAND_RIGHT_BOTH then
			SetVariable("IsTorchGuard", FALSE)

			if env(GetStayAnimCategory) == 15 then
				guardindex = env(GetGuardMotionCategory, HAND_RIGHT)
			end

			if env(GetEquipWeaponCategory, HAND_RIGHT) == WEAPON_CATEGORY_DUELING_SHIELD then
				guardindex = 3
			end
		end

		SetVariable("IndexGuard", guardindex)

		-- CUSTOM: Begin.
		if Game_IsPlayer() == TRUE then
			Game_SetGuardStyle(TRUE)
			Action_AddGuardCounterStatus()
		end
		-- CUSTOM: End.

		local guard_damage_level = env(GetGuardLevelAction)

		if env(GetSpEffectID, 171) == TRUE and guard_damage_level < 3 then
			guard_damage_level = 3
		end

		if guard_damage_level > 0 then
			if guard_damage_level == 1 then
				act(SetDamageAnimType, DAMAGE_FLAG_GUARD_SMALL)
				if env(GetSpEffectID, 102001) == TRUE or env(GetSpEffectID, 102011) == TRUE or env(GetSpEffectID, 102013)
					== TRUE or env(GetSpEffectID, 102015) == TRUE then
					SetJustGuardSucceedEffect(1)
					ExecEventAllBody("W_GuardDamageSmall_JustGuard")
				else
					ExecEventAllBody("W_GuardDamageSmall")
				end
			elseif guard_damage_level == 3 then
				act(SetDamageAnimType, DAMAGE_FLAG_GUARD_LARGE)
				if env(GetSpEffectID, 102001) == TRUE or env(GetSpEffectID, 102011) == TRUE or env(GetSpEffectID, 102013)
					== TRUE or env(GetSpEffectID, 102015) == TRUE then
					SetJustGuardSucceedEffect(2)
					ExecEventAllBody("W_GuardDamageMiddle_JustGuard")
				else
					ExecEventAllBody("W_GuardDamageMiddle")
				end
			elseif guard_damage_level == 4 then
				act(SetDamageAnimType, DAMAGE_FLAG_GUARD_EXLARGE)
				if env(GetSpEffectID, 102001) == TRUE or env(GetSpEffectID, 102011) == TRUE or env(GetSpEffectID, 102013)
					== TRUE or env(GetSpEffectID, 102015) == TRUE then
					SetJustGuardSucceedEffect(2)
					ExecEventAllBody("W_GuardDamageLarge_JustGuard")
				else
					ExecEventAllBody("W_GuardDamageLarge")
				end
			else
				act(SetDamageAnimType, DAMAGE_FLAG_GUARD_LARGE)
				if env(GetSpEffectID, 102001) == TRUE or env(GetSpEffectID, 102011) == TRUE or env(GetSpEffectID, 102013)
					== TRUE or env(GetSpEffectID, 102015) == TRUE then
					SetJustGuardSucceedEffect(2)
					ExecEventAllBody("W_GuardDamageMiddle_JustGuard")
				else
					ExecEventAllBody("W_GuardDamageMiddle")
				end
			end

			return TRUE
		else
			if env(GetSpEffectID, 102001) == TRUE or env(GetSpEffectID, 102011) == TRUE or env(GetSpEffectID, 102013)
				== TRUE or env(GetSpEffectID, 102015) == TRUE then
				SetJustGuardSucceedEffect(1)
				ExecAddDamage(damage_angle, attack_dir, damage_level, TRUE, is_damaged, TRUE)
			else
				ExecAddDamage(damage_angle, attack_dir, damage_level, TRUE, is_damaged, FALSE)
			end
			return FALSE
		end
	end

	if env(GetKnockbackDistance) < 0 then
		if damage_angle == DAMAGE_DIR_LEFT then
			damage_angle = DAMAGE_DIR_RIGHT
		elseif damage_angle == DAMAGE_DIR_RIGHT then
			damage_angle = DAMAGE_DIR_LEFT
		elseif damage_angle == DAMAGE_DIR_FRONT then
			damage_angle = DAMAGE_DIR_BACK
		elseif damage_angle == DAMAGE_DIR_BACK then
			damage_angle = DAMAGE_DIR_FRONT
		end
	end

	if env(GetSpEffectID, 89) == TRUE or env(GetSpEffectID, 100640) == TRUE then
		if damage_level == DAMAGE_LEVEL_EXLARGE then
			act(RequestAIJumpInterupt)
		elseif damage_level == DAMAGE_LEVEL_LARGE or damage_level == DAMAGE_LEVEL_PUSH or damage_level
			== DAMAGE_LEVEL_FLING or damage_level == DAMAGE_LEVEL_SMALL_BLOW or damage_level == DAMAGE_LEVEL_UPPER
			or damage_level == DAMAGE_LEVEL_EX_BLAST or damage_level == DAMAGE_LEVEL_BREATH or env(GetIsWeakPoint)
			== TRUE then
			act(RequestAIJumpInterupt)
			damage_level = DAMAGE_LEVEL_SMALL_BLOW
		elseif damage_level == DAMAGE_LEVEL_MIDDLE or damage_level == DAMAGE_LEVEL_SMALL then
			CalcDamageCount()
			act(RequestAIJumpInterupt)
			hkbFireEvent("W_JumpDamage_Start")
			SetVariable("Int16Variable04", 0)
			act(SetDamageAnimType, 3)
			ResetRequest()
			return TRUE
		else
			damage_level = DAMAGE_LEVEL_NONE
		end
	end
	local height = env(GetFallHeight) / 100
	if env(IsFalling) == TRUE and env(GetBehaviorID, 10) == TRUE and height >= 10 then
		damage_level = DAMAGE_LEVEL_NONE
	end
	if env(GetIsWeakPoint) == TRUE and env(GetBehaviorID, 15) == FALSE then
		CalcDamageCount()
		SetVariable("DamageDirection", damage_angle)
		act(SetDamageAnimType, DAMAGE_FLAG_WEAK)
		ExecEventAllBody("W_DamageWeak")
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_NONE then
		ExecAddDamage(damage_angle, attack_dir, damage_level, FALSE, is_damaged, FALSE)

		return FALSE
	elseif damage_level == DAMAGE_LEVEL_SMALL then
		CalcDamageCount()
		SetVariable("DamageDirection", damage_angle)
		SetVariable("IndexDamageLv1_Small_AttackDirection", attack_dir)
		act(SetDamageAnimType, DAMAGE_FLAG_SMALL)
		ExecEventAllBody("W_DamageLv1_Small")
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_MIDDLE then
		CalcDamageCount()
		SetVariable("DamageDirection", damage_angle)
		SetVariable("IndexDamageLv2_Middle_AttackDirection", attack_dir)
		act(SetDamageAnimType, DAMAGE_FLAG_MEDIUM)
		ExecEventAllBody("W_DamageLv2_Middle")
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_LARGE then
		CalcDamageCount()
		SetVariable("DamageDirection", damage_angle)
		SetVariable("IndexDamageLv3_Large_AttackDirection", attack_dir)
		act(SetDamageAnimType, DAMAGE_FLAG_LARGE)
		Replanning()

		if env(GetBehaviorID, 3) == TRUE then
			ExecEventAllBody("W_DamageLarge2")
			return TRUE
		else
			ExecEventAllBody("W_DamageLv3_Large")
			return TRUE
		end
	elseif damage_level == DAMAGE_LEVEL_EXLARGE then
		ResetDamageCount()
		SetVariable("DamageDirection", damage_angle)
		act(SetDamageAnimType, DAMAGE_FLAG_LARGE_BLOW)
		ExecEventAllBody("W_DamageLv4_ExLarge")
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_EX_BLAST then
		ResetDamageCount()
		SetVariable("DamageDirection", damage_angle)
		act(SetDamageAnimType, DAMAGE_FLAG_LARGE_BLOW)
		ExecEventAllBody("W_DamageLV10_ExBlast")
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_PUSH then
		if env(GetBehaviorID, 14) == TRUE then
			act(AddSpEffect, 19865)
		end
		CalcDamageCount()
		SetVariable("DamageDirection", damage_angle)
		act(SetDamageAnimType, DAMAGE_FLAG_PUSH)
		ExecEventAllBody("W_DamageLv5_Push")
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_SMALL_BLOW then
		ResetDamageCount()
		SetVariable("DamageDirection", damage_angle)
		act(SetDamageAnimType, DAMAGE_FLAG_SMALL_BLOW)
		ExecEventAllBody("W_DamageLv7_SmallBlow")
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_UPPER then
		ResetDamageCount()
		SetVariable("DamageDirection", damage_angle)
		act(SetDamageAnimType, DAMAGE_FLAG_LARGE_BLOW)
		if env(GetBehaviorID, 10) == TRUE then
			SetVariable("DamageLv9_Behavior", 1)
		elseif env(GetBehaviorID, 13) == TRUE then
			SetVariable("DamageLv9_Behavior", 2)
		else
			SetVariable("DamageLv9_Behavior", 0)
		end
		ExecEventAllBody("W_DamageLv9_Upper")
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_MINIMUM then
		CalcDamageCount()

		local pre_index = GetVariable("IndexDamageLv8_Minimum_Random")
		local index = (pre_index + math.random(1, 2)) % 3

		SetVariable("IndexDamageLv8_Minimum_Random", index)
		act(SetDamageAnimType, DAMAGE_FLAG_MINIMUM)
		ExecEventAllBody("W_DamageLv8_Minimum")
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_FLING then
		ResetDamageCount()
		SetVariable("DamageDirection", damage_angle)
		act(SetDamageAnimType, DAMAGE_FLAG_FLING)
		ExecEventAllBody("W_DamageLv6_Fling")
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_BREATH then
		ResetDamageCount()
		SetVariable("DamageDirection", damage_angle)
		act(SetDamageAnimType, DAMAGE_FLAG_BREATH)
		ExecEventAllBody("W_DamageLv11_Breath")
		Replanning()

		return TRUE
	end
	return FALSE
end

function GetLandIndex(height, is_jump)
	if 8 < height then
		return LAND_HEAVY
	elseif height > 4 then
		return LAND_MIDDLE
	elseif is_jump == TRUE and height > 0 then
		return LAND_JUMP
	else
		return LAND_DEFAULT
	end
end

function FallCommonFunction(is_enable_falling_death, is_jump, fall_style)
	local height = env(GetFallHeight) / 100
	local damage_type = env(GetReceivedDamageType)
	local style = c_Style
	if damage_type == DAMAGE_TYPE_DEATH_FALLING then
		if fall_style == FALL_FACEUP then
			ExecEventAllBody("W_FallDeathFaceUp")
		elseif fall_style == FALL_FACEDOWN then
			ExecEventAllBody("W_FallDeathFaceDown")
		else
			ExecEventAllBody("W_FallDeath")
		end
		return TRUE
	end
	if is_enable_falling_death ~= TRUE or not (height >= 60) or env(GetStateChangeType, 266) == TRUE then
	else
		if fall_style == FALL_FACEUP then
			ExecEventAllBody("W_FallDeathFaceUp")
		elseif fall_style == FALL_FACEDOWN then
			ExecEventAllBody("W_FallDeathFaceDown")
		else
			ExecEventAllBody("W_FallDeath")
		end
		return TRUE
	end

	act(SetCanChangeEquipmentOn)

	if env(IsLanding) == TRUE then
		IS_ATTACKED_JUMPMAGIC = FALSE

		if env(GetStateChangeType, 266) == TRUE then
			Replanning()
			SetVariable("LandIndex", LAND_MIDDLE)
			ExecEventAllBody("W_Land")
			return TRUE
		end
		if fall_style == FALL_DEFAULT then
			if IsLandDead(height) == TRUE then
				if height > 8 then
					SetVariable("IndexDeath", DEATH_TYPE_LAND)
				else
					SetVariable("IndexDeath", DEATH_TYPE_LAND_LOW)
				end

				ExecEventAllBody("W_DeathStart")

				return TRUE
			else
				if height > 1.2999999523162842 then
					local landIndex = GetLandIndex(height, is_jump)

					SetVariable("LandIndex", landIndex)
					Replanning()
					local JumpMoveLevel = 0

					if landIndex ~= LAND_HEAVY then
						if GetVariable("MoveSpeedLevel") > 1.100000023841858 then
							JumpMoveLevel = 2
						elseif GetVariable("MoveSpeedLevel") > 0.6000000238418579 then
							JumpMoveLevel = 1
						end
					end

					if env(GetSpEffectID, 503520) == TRUE then
						JumpMoveLevel = 0
					elseif env(GetSpEffectID, 5520) == TRUE then
						JumpMoveLevel = 0
					elseif env(GetSpEffectID, 425) == TRUE then
						JumpMoveLevel = 0
					elseif env(GetSpEffectID, 4101) == TRUE then
						JumpMoveLevel = 0
					elseif env(GetSpEffectID, 4100) == TRUE then
						JumpMoveLevel = 0
					elseif env(GetSpEffectID, 19670) == TRUE then
						JumpMoveLevel = 0
					end
					if JumpMoveLevel == 2 then
						ExecEventNoReset("W_Jump_Land_To_Dash")
						return TRUE
					elseif JumpMoveLevel == 1 then
						SetVariable("JumpLandMoveDirection", GetVariable("MoveDirection"))
						ExecEventNoReset("W_Jump_Land_To_Run")
						return TRUE
					else
						ExecEventAllBody("W_Land")
					end
				else
					act(Unknown9999)

					if height > 0.30000001192092896 then
						ExecEventAllBody("W_LandLow")
					else
						ExecEventAllBody("W_Idle")
					end
				end
				return TRUE
			end
		elseif fall_style == FALL_FACEUP then
			if IsLandDead(height) == TRUE then
				SetVariable("IndexDeath", DEATH_TYPE_LAND_FACEUP)
				ExecEventAllBody("W_DeathStart")
			else
				Replanning()
				ExecEventAllBody("W_LandFaceUp")
			end

			return TRUE
		elseif fall_style == FALL_FACEDOWN then
			if IsLandDead(height) == TRUE then
				SetVariable("IndexDeath", DEATH_TYPE_LAND_FACEDOWN)
				ExecEventAllBody("W_DeathStart")
			else
				Replanning()
				ExecEventAllBody("W_LandFaceDown")
			end

			return TRUE
		elseif fall_style == FALL_LADDER then
			if IsLandDead(height) == TRUE then
				SetVariable("IndexDeath", DEATH_TYPE_LAND)
				ExecEventAllBody("W_DeathStart")
			else
				Replanning()
				ExecEventAllBody("W_LadderFallLanding")
			end

			return TRUE
		end
	end

	local arrowHand = HAND_RIGHT

	if style == HAND_LEFT_BOTH then
		arrowHand = HAND_LEFT
	end

	local is_arrow = GetEquipType(arrowHand, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW,
		WEAPON_CATEGORY_LARGE_ARROW, WEAPON_CATEGORY_CROSSBOW, WEAPON_CATEGORY_BALLISTA)

	if is_arrow == TRUE then
		if env(ActionRequest, 0) == TRUE then
			act(ChooseBowAndArrowSlot, 0)
			g_ArrowSlot = 0
		elseif env(ActionRequest, 1) == TRUE then
			act(ChooseBowAndArrowSlot, 1)
			g_ArrowSlot = 1
		end
	end

	if fall_style == FALL_DEFAULT and height >= 0.20000000298023224 then
		if ExecFallMagic() == TRUE then
			return TRUE
		elseif ExecFallAttack() == TRUE then
			return TRUE
		end
	end

	return FALSE
end

function ExecFallAttack()
	if env(ActionRequest, ACTION_ARM_R1) == TRUE or env(ActionRequest, ACTION_ARM_R2) == TRUE
		or env(ActionRequest, ACTION_ARM_L1) == TRUE and IsEnableDualWielding() == HAND_RIGHT then
		local style = c_Style
		local hand = HAND_RIGHT

		if style == HAND_LEFT_BOTH then
			hand = HAND_LEFT
		end

		local is_arrow = GetEquipType(hand, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW,
			WEAPON_CATEGORY_LARGE_ARROW, WEAPON_CATEGORY_CROSSBOW, WEAPON_CATEGORY_BALLISTA)
		local is_staff = GetEquipType(hand, WEAPON_CATEGORY_STAFF)

		if env(ActionRequest, ACTION_ARM_R1) == TRUE or is_arrow == TRUE then
			if is_staff == TRUE then
				return FALSE
			end

			SetVariable("JumpAttackForm", 1)
			SetVariable("JumpAttackFormRequest", 0)
		elseif env(ActionRequest, ACTION_ARM_R2) == TRUE then
			SetVariable("JumpAttackForm", 2)
			SetVariable("JumpAttackFormRequest", 1)
		elseif env(ActionRequest, ACTION_ARM_L1) == TRUE then
			if IsEnableDualWielding() ~= HAND_RIGHT then
				return FALSE
			end

			SetVariable("JumpAttackForm", 3)
			SetVariable("JumpAttackFormRequest", 2)
		end

		if is_arrow == TRUE and (style == HAND_LEFT_BOTH or style == HAND_RIGHT_BOTH) and env(IsOutOfAmmo, hand) == TRUE then
			return FALSE
		end
		if GetEquipType(hand, WEAPON_CATEGORY_CROSSBOW) == TRUE and env(GetBoltLoadingState, hand) == FALSE then
			return FALSE
		end
		if style == HAND_RIGHT then
			SetVariable("JumpAttack_HandCondition", 0)
		elseif style == HAND_RIGHT_BOTH then
			SetVariable("JumpAttack_HandCondition", 1)
		elseif style == HAND_LEFT_BOTH then
			if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW) == TRUE then
				SetVariable("JumpAttack_HandCondition", 4)
			else
				SetVariable("JumpAttack_HandCondition", 1)
			end
		end

		SetVariable("JumpAttack_Land", 0)
		ExecEventAllBody("W_JumpAttack_Start_Falling")
		return TRUE
	end
	return FALSE
end

function ExecGuardOnCancelTiming(guardcondition, blend_type)
	if env(IsGuardFromAtkCancel) == FALSE then
		return FALSE
	end

	act(DebugLogOutput, "ExecGuardOnCancelTiming " .. guardcondition)

	if guardcondition == TO_GUARDON and env(GetSpEffectID, 102000) == TRUE and env(ActionRequest, ACTION_ARM_L1) == TRUE then
		guardcondition = FALSE
	end

	if guardcondition == TO_GUARDON then
		if ExecGuard(Event_GuardOn, blend_type) == TRUE then
			return TRUE
		end
	elseif ExecGuard(Event_GuardStart, blend_type) == TRUE then
		return TRUE
	end

	return FALSE
end

function LadderIdleCommonFunction(hand)
	act(SetCanChangeEquipmentOn)

	if ExecLadderDeath() == TRUE then
		return TRUE
	end
	if ExecLadderDamageIdle(hand) == TRUE then
		return TRUE
	end
	if ExecLadderAttack(hand) == TRUE then
		return TRUE
	end
	if ExecLadderItem(hand) == TRUE then
		return TRUE
	end
	if ExecLadderMove(hand) == TRUE then
		return TRUE
	end
	return FALSE
end

function LadderMoveCommonFunction(hand, is_no_damage)
	act(SetCanChangeEquipmentOn)

	if ExecLadderDeath() == TRUE then
		return TRUE
	end

	if is_no_damage == FALSE and ExecLadderDamageMove() == TRUE then
	end

	if env(IsAnimEnd, 1) == TRUE then
		if CheckLadderDamage(hand) == TRUE then
			return TRUE
		end
		if ExecLadderAttack(hand) == TRUE then
			return TRUE
		end
		if ExecLadderItem(hand) == TRUE then
			return TRUE
		end
		if ExecLadderMove(hand) == TRUE then
			return TRUE
		end
		if hand == HAND_STATE_LEFT then
			ExecEvent("W_LadderIdleLeft")
		else
			ExecEvent("W_LadderIdleRight")
		end

		return TRUE
	end
	return FALSE
end

function LadderAttackCommonFunction(hand)
	act(SetCanChangeEquipmentOn)

	if ExecLadderDeath() == TRUE then
		return TRUE
	end
	if ExecLadderDamageIdle(hand) == TRUE then
		return TRUE
	end

	if env(IsAnimEnd, 1) == TRUE then
		if ExecLadderAttack(hand) == TRUE then
			return TRUE
		end
		if ExecLadderItem(hand) == TRUE then
			return TRUE
		end
		if ExecLadderMove(hand) == TRUE then
			return TRUE
		end
		if hand == HAND_STATE_LEFT then
			ExecEvent("W_LadderIdleLeft")
		else
			ExecEvent("W_LadderIdleRight")
		end

		return TRUE
	end
	return FALSE
end

function LadderDamageCommonFunction(hand)
	act(SetCanChangeEquipmentOn)

	if ExecLadderDeath() == TRUE then
		return TRUE
	end
	if ExecLadderDamageIdle(hand) == TRUE then
		return TRUE
	end
	if env(IsAnimEnd, 1) == TRUE then
		if ExecLadderAttack(hand) == TRUE then
			return TRUE
		end
		if ExecLadderItem(hand) == TRUE then
			return TRUE
		end
		if ExecLadderMove(hand) == TRUE then
			return TRUE
		end
		if hand == HAND_STATE_RIGHT then
			ExecEvent("W_LadderIdleRight")
		else
			ExecEvent("W_LadderIdleLeft")
		end

		return TRUE
	end
	return FALSE
end

function LadderEndCommonFunction()
	act(SetCanChangeEquipmentOn)

	if ExecLadderDeath() == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
		return TRUE
	end
	if ExecFallStart(FALL_TYPE_DEFAULT) == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
		return TRUE
	end
	if ExecJump() == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, ALLBODY) == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, ALLBODY) == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, ALLBODY, FALSE) == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		LadderSetActionState(LADDER_ACTION_INVALID)
		return TRUE
	end
	return FALSE
end

function LadderItemCommonFunction(hand, tonext)
	act(SetIsItemAnimationPlaying)
	act(SetCanChangeEquipmentOn)
	if ExecLadderDeath() == TRUE then
		return TRUE
	end
	if ExecLadderDamageIdle(hand) == TRUE then
		return TRUE
	end
	if env(IsAnimEnd, 1) == TRUE then
		if ExecLadderItem(hand) == TRUE then
			return TRUE
		end
		if tonext == FALSE then
			if ExecLadderAttack(hand) == TRUE then
				return TRUE
			end
			if ExecLadderMove(hand) == TRUE then
				return TRUE
			end
			if hand == HAND_STATE_RIGHT then
				ExecEvent("W_LadderIdleRight")
			else
				ExecEvent("W_LadderIdleLeft")
			end
			return TRUE
		end
		return FALSE
	end
	return FALSE
end

function CheckLadderDamage(hand)
	local damage_flag = Flag_LadderDamage

	if damage_flag == LADDER_DAMAGE_SMALL then
		act(ChangeStamina, -30)

		if ExecLadderFall() == TRUE then
			return TRUE
		end
		if hand == HAND_STATE_LEFT then
			ExecEvent("W_LadderDamageSmallLeft")
		else
			ExecEvent("W_LadderDamageSmallRight")
		end
	elseif damage_flag == LADDER_DAMAGE_LARGE then
		act(ChangeStamina, -40)

		if ExecLadderFall() == TRUE then
			return TRUE
		end
		if hand == HAND_STATE_LEFT then
			ExecEvent("W_LadderDamageLargeLeft")
		else
			ExecEvent("W_LadderDamageLargeRight")
		end
	else
		Flag_LadderDamage = LADDER_DAMAGE_NONE
		return FALSE
	end

	Flag_LadderDamage = LADDER_DAMAGE_NONE

	return TRUE
end

function ExecLadderDeath()
	local hp = env(GetHP)

	if hp <= 0 or env(GetStateChangeType, CONDITION_TYPE_STONE) == TRUE
		or env(GetStateChangeType, CONDITION_TYPE_CRYSTAL) == TRUE or env(GetDamageSpecialAttribute, 3) == TRUE then
		ExecEvent("W_LadderDeathStart")
		return TRUE
	end
	return FALSE
end

function ExecLadderDamageIdle(hand)
	if env(HasReceivedAnyDamage) == FALSE then
		return FALSE
	end
	if env(GetStamina) <= 80 then
		act(ChangeStamina, -40)

		if ExecLadderFall() == TRUE then
			return TRUE
		end
		if hand == HAND_STATE_LEFT then
			ExecEvent("W_LadderDamageLargeLeft")
		else
			ExecEvent("W_LadderDamageLargeRight")
		end
	else
		act(ChangeStamina, -30)
		if ExecLadderFall() == TRUE then
			return TRUE
		end
		if hand == HAND_STATE_LEFT then
			ExecEvent("W_LadderDamageSmallLeft")
		else
			ExecEvent("W_LadderDamageSmallRight")
		end
	end
	return TRUE
end

function ExecLadderDamageMove()
	if env(HasReceivedAnyDamage) == FALSE then
		return FALSE
	end
	if env(GetStamina) <= 80 then
		Flag_LadderDamage = LADDER_DAMAGE_LARGE
	else
		Flag_LadderDamage = LADDER_DAMAGE_SMALL
	end
	return TRUE
end

function ExecLadderFall()
	if env(GetStamina) > 0 and env(GetDamageSpecialAttribute, 5) == FALSE then
		return FALSE
	end
	ExecEvent("W_LadderFallStart")
	return TRUE
end

function GetLadderEventCommand(is_start)
	if env(IsCOMPlayer) == FALSE then
		return env(GetCommandIDFromEvent, 0)
	else
		local req_up = env(ActionRequest, ACTION_ARM_LADDERUP)
		local req_down = env(ActionRequest, ACTION_ARM_LADDERDOWN)

		if is_start == TRUE then
			if req_up == TRUE then
				return LADDER_ACTION_START_BOTTOM
			elseif req_down == TRUE then
				return LADDER_ACTION_START_TOP
			end
		elseif req_up == TRUE then
			if env(IsReachTopOfLadder) == TRUE then
				return LADDER_EVENT_COMMAND_END_TOP
			else
				return LADDER_EVENT_COMMAND_UP
			end
		elseif req_down == TRUE then
			if env(IsReachBottomOfLadder) == TRUE then
				return LADDER_EVENT_COMMAND_END_BOTTOM
			else
				return LADDER_EVENT_COMMAND_DOWN
			end
		end

		return INVALID
	end
end

function ExecLadderMove(hand)
	local sp_action = env(ActionDuration, ACTION_ARM_SP_MOVE)

	if sp_action == 0 then
		if Flag_LadderJump == LADDER_JUMP_WHEN_RELEASE and env(ActionRequest, ACTION_ARM_BACKSTEP) == TRUE
			and env(IsOnLastRungOfLadder) == FALSE then
			LadderSendCommand(LADDER_EVENT_COMMAND_EXIT)
			LadderSetActionState(LADDER_ACTION_INVALID)
			ExecEvent("W_LadderDrop")
			return TRUE
		end

		Flag_LadderJump = LADDER_JUMP_SP_RELEASED
	elseif sp_action < 150 then
		if Flag_LadderJump == LADDER_JUMP_SP_RELEASED then
			Flag_LadderJump = LADDER_JUMP_WHEN_RELEASE
		end
	else
		Flag_LadderJump = LADDER_JUMP_INVALID
	end

	local event_command = GetLadderEventCommand(FALSE)

	if event_command <= 0 then
		return FALSE
	end
	if event_command == LADDER_EVENT_COMMAND_UP then
		if env(IsCOMPlayer) == TRUE and env(DoesLadderHaveCharacters, LADDER_UP_CHECK_DIST, 1, 1) == TRUE then
			if hand == HAND_STATE_RIGHT then
				ExecEvent("W_LadderAttackUpRight")
			else
				ExecEvent("W_LadderAttackUpLeft")
			end
			return TRUE
		end

		if env(IsSomeoneOnLadder, LADDER_UP_CHECK_DIST, 0) == TRUE then
			return FALSE
		end
		if env(ActionDuration, ACTION_ARM_SP_MOVE) > 0 then
			SetVariable("IsFastUp", TRUE)
		else
			SetVariable("IsFastUp", FALSE)
		end

		if hand == HAND_STATE_LEFT then
			ExecEvent("W_LadderUpLeft")
		else
			ExecEvent("W_LadderUpRight")
		end

		return TRUE
	elseif event_command == LADDER_EVENT_COMMAND_DOWN then
		if env(IsCOMPlayer) == TRUE and env(DoesLadderHaveCharacters, LADDER_DOWN_CHECK_DIST, 0, 1) == TRUE then
			if hand == HAND_STATE_RIGHT then
				ExecEvent("W_LadderAttackDownRight")
			else
				ExecEvent("W_LadderAttackDownLeft")
			end
			return TRUE
		end
		if env(IsSomeoneUnderLadder, LADDER_DOWN_CHECK_DIST, 0) == TRUE then
			return FALSE
		end
		if env(ActionDuration, ACTION_ARM_SP_MOVE) > 0 then
			ExecEvent("W_LadderCoastStart")
			return TRUE
		end
		if hand == HAND_STATE_LEFT then
			ExecEvent("W_LadderDownLeft")
		else
			ExecEvent("W_LadderDownRight")
		end

		return TRUE
	elseif event_command == LADDER_EVENT_COMMAND_END_TOP then
		if hand == HAND_STATE_LEFT then
			ExecEvent("W_LadderEndTopLeft")
		else
			ExecEvent("W_LadderEndTopRight")
		end

		return TRUE
	elseif event_command == LADDER_EVENT_COMMAND_END_BOTTOM then
		if hand == HAND_STATE_LEFT then
			ExecEvent("W_LadderEndBottomLeft")
		else
			ExecEvent("W_LadderEndBottomRight")
		end

		return TRUE
	end
	return FALSE
end

function LadderStart()
	local event_command = GetLadderEventCommand(TRUE)

	if event_command == LADDER_ACTION_START_BOTTOM then
		ExecEvent("W_LadderAttachBottom")
		return TRUE
	elseif event_command == LADDER_ACTION_START_TOP then
		ExecEvent("W_LadderAttachTop")
		return TRUE
	end
	return FALSE
end

function LadderSetActionState(state)
	act(SetLadderActionState, state)
end

function LadderSendCommand(event_call)
	act(SendMessageIDToEvents, event_call)
end

function ExecLadderAttack(hand)
	if env(GetStamina) <= 0 then
		return FALSE
	end
	if env(ActionRequest, ACTION_ARM_R1) == TRUE then
		if hand == HAND_STATE_RIGHT then
			ExecEvent("W_LadderAttackUpRight")
		else
			ExecEvent("W_LadderAttackUpLeft")
		end

		return TRUE
	elseif env(ActionRequest, ACTION_ARM_R2) == TRUE then
		if hand == HAND_STATE_RIGHT then
			ExecEvent("W_LadderAttackDownRight")
		else
			ExecEvent("W_LadderAttackDownLeft")
		end
		return TRUE
	end
	return FALSE
end

function LadderCoastCommonFunction(hand, is_start)
	act(SetCanChangeEquipmentOn)

	if ExecLadderDeath() == TRUE then
		return TRUE
	end
	if ExecLadderDamageMove() == TRUE then
	end

	if is_start == FALSE then
		if env(IsOnLastRungOfLadder) == TRUE then
			ExecEvent("W_LadderCoastLanding")
			return TRUE
		end

		local event_command = GetLadderEventCommand(FALSE)

		if env(ActionDuration, ACTION_ARM_SP_MOVE) <= 0 or env(MovementRequestDuration) <= 0 or event_command > 0
			and event_command ~= LADDER_EVENT_COMMAND_DOWN or env(IsSomeoneUnderLadder, LADDER_DOWN_CHECK_DIST, 0)
			== TRUE then
			act(LadderSlideDownCancel)
			if env(GetNumberOfRungsBelowOnLadder) % 2 == 0 then
				ExecEvent("W_LadderCoastStopRight")
			else
				ExecEvent("W_LadderCoastStopLeft")
			end
			return TRUE
		end
	elseif env(IsAnimEnd, 1) == TRUE then
		if CheckLadderDamage(hand) == TRUE then
			return TRUE
		end
		ExecEvent("W_LadderCoastLeft")
		return TRUE
	end
	return FALSE
end

function IdleCommonFunction()
	if env(IsCOMPlayer) == TRUE then
		act(LockonSystemUnableToTurnAngle, 15, 15)
	else
		act(LockonSystemUnableToTurnAngle, 45, 45)
	end

	act(Wait)
	act(AllowBuddyWarp)
	SetEnableAimMode()

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if LadderStart() == TRUE then
		return TRUE
	end
	if c_IsStealth == FALSE and ExecQuickTurn(ALLBODY, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecGuard(Event_GuardStart, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStance(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecRide() == TRUE then
		return TRUE
	end

	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"

	if c_IsStealth == TRUE then
		r1 = "W_AttackRightLightStealth"
		b1 = "W_AttackBothLightStealth"
	end

	if ExecAttack(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1,
		"W_AttackBothHeavy1Start", FALSE, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if c_IsStealth == TRUE then
		if MoveStart(ALLBODY, Event_Stealth_Move, FALSE) == TRUE then
			return TRUE
		end
	elseif MoveStart(ALLBODY, Event_Move, FALSE) == TRUE then
		return TRUE
	end

	if ExecGesture() == TRUE then
		return TRUE
	end
	return FALSE
end

function SetAttackQueue(r1, r2, l1, l2, b1, b2)
	g_r1 = r1
	g_r2 = r2
	g_l1 = l1
	g_l2 = l2
	g_b1 = b1
	g_b2 = b2
end

function ClearAttackQueue()
	g_r1 = "W_AttackRightLight1"
	g_r2 = "W_AttackRightHeavy1Start"
	g_l1 = "W_AttackLeftLight1"
	g_l2 = "W_AttackLeftHeavy1"
	g_b1 = "W_AttackBothLight1"
	g_b2 = "W_AttackBothHeavy1Start"
end

function AttackCommonFunction(r1, r2, l1, l2, b1, b2, guardcondition, use_atk_queue, comboCount, gen_hand)
	if gen_hand == nil then
		gen_hand = FALSE
	end

	SetVariable("ToggleDash", 0)

	act(FallPreventionAssist)
	SetThrowAtkInvalid()
	SetAIActionState()

	if env(GetSpEffectID, 102050) == TRUE then
		act(LockonFixedAngleCancel)
	end

	local bool = FALSE

	if guardcondition == TO_GUARDON then
		bool = TRUE
	end

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, bool) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_ATTACK, ALLBODY) == TRUE then
		if use_atk_queue == TRUE then
			SetAttackQueue(r1, r2, l1, l2, b1, b2)
		end
		return TRUE
	end
	if ExecMagic(QUICKTYPE_ATTACK, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if ExecAttack(r1, r2, l1, l2, b1, b2, guardcondition, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		if use_atk_queue == TRUE then
			SetAttackQueue(r1, r2, l1, l2, b1, b2)
		end
		return TRUE
	end
	if ExecQuickTurnOnCancelTiming() == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(guardcondition, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		return TRUE
	end
	local move_event = Event_Move
	if env(GetSpEffectID, 102051) == TRUE then
		move_event = Event_MoveLong
	end
	if MoveStartonCancelTiming(move_event, gen_hand) == TRUE then
		return TRUE
	end
	if ExecGesture() == TRUE then
		return TRUE
	end
	return FALSE
end

function BackStabCommonFunction()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		Action_SetSpecial(TRUE)
		Action_SetCritical(TRUE)
	end
	-- CUSTOM: End.

	SetAIActionState()

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_ATTACK, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_ATTACK, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight2", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight2", "W_AttackBothHeavy1Start", FALSE, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if ExecQuickTurnOnCancelTiming() == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return TRUE
	end
	if ExecGesture() == TRUE then
		return TRUE
	end
	return FALSE
end

function ThrowCommonFunction(estep)
	if env(IsThrowing) == FALSE then
		if ExecDeath() == TRUE then
			return TRUE
		end
		if env(CheckForEventAnimPlaybackRequest) == TRUE then
			return TRUE
		end
		if ExecDamage(FALSE) == TRUE then
			return TRUE
		end
	end

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		Action_SetSpecial(TRUE)
		Action_SetCritical(TRUE)
	end
	-- CUSTOM: End.

	if ExecFallStart(FALL_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if ExecQuickTurnOnCancelTiming() == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, estep, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if MoveStartonCancelTiming(Event_MoveQuick, FALSE) == TRUE then
		return TRUE
	end
	return FALSE
end

function GestureCommonFunction(blend_type)
	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if ExecGesture() == TRUE then
		return TRUE
	end
	return FALSE
end

function GestureLoopCommonFunction(blend_type, lower_state, is_start)
	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end

	local canmove = FALSE

	if env(GetEventEzStateFlag, 0) == TRUE then
		if env(HasActionRequest) == TRUE then
			ExecEventHalfBlend(Event_GestureEnd, lower_state)
			return TRUE
		end

		if canmove == FALSE and 0 < GetVariable("MoveSpeedLevel") then
			ExecEventHalfBlend(Event_GestureEnd, lower_state)
			return TRUE
		end
	end
	return FALSE
end

function MagicCommonFunction(blend_type, quick_type, is_throw)
	if GetVariable("IsEnableToggleDashTest") == 2 then
		SetVariable("ToggleDash", 0)
	end

	if GetVariable("MoveSpeedLevel") <= 0 then
		act(FallPreventionAssist)
	end

	if is_throw ~= TRUE then
		SetThrowAtkInvalid()
	end

	SetAIActionState()
	act(SetIsMagicInUse, TRUE)

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		Action_SetCasting(FALSE)
	end
	-- CUSTOM: End.

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, blend_type, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, blend_type, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if Cancel_IsCooldown() == FALSE then
			Action_SetCasting(TRUE)
		end
	end
	-- CUSTOM: End.

	return FALSE
end

function ArrowCommonFunction(blend_type, is_allbody_turn, turn_type, is_stance_end)
	SetAIActionState()

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if c_IsStealth == FALSE then
		if is_allbody_turn == TRUE then
			if ExecQuickTurnOnCancelTiming() == TRUE then
				return TRUE
			end
		elseif blend_type ~= UPPER and ExecQuickTurn(LOWER, turn_type) == TRUE then
			return FALSE
		end
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end
	if is_stance_end == TRUE and ExecArtsStanceOnCancelTiming(blend_type) == TRUE then
		return TRUE
	end
	return FALSE
end

function CrossbowCommonFunction(blend_type, is_nonturn)
	SetAIActionState()
	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if is_nonturn == FALSE and blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return FALSE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, blend_type, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(blend_type) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, blend_type, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	return FALSE
end

function Evasion_Activate()
	ActivateRightArmAdd(START_FRAME_A02)
end

function Evasion_Update()
	UpdateRightArmAdd()
end

function Evasion_Deactivate()
end

function EvasionCommonFunction(fall_type, r1, r2, l1, l2, b1, b2, quick_type)
	SetAIActionState()
	SetEnableAimMode()

	if ExecPassiveAction(FALSE, fall_type, FALSE) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if IsNodeActive("BackStepGuardOn_UpperLayer Selector") == TRUE then
		act(DebugLogOutput, "BackStepGuardOn")
		if ExecGuardOnCancelTiming(TO_GUARDON, ALLBODY) == TRUE then
			return TRUE
		end
		if env(ActionRequest, ACTION_ARM_L1) == TRUE or env(ActionDuration, ACTION_ARM_L1) > 0 then
			act(DebugLogOutput, "BackStepGuard_ToGuardOn")
		end
	elseif ExecGuardOnCancelTiming(FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(quick_type, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecMagic(quick_type, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecAttack(r1, r2, l1, l2, b1, b2, FALSE, ALLBODY, FALSE, FALSE, TRUE) == TRUE then
		return TRUE
	end
	if MoveStartonCancelTiming(Event_MoveLong, FALSE) == TRUE then
		return TRUE
	end
	return FALSE
end

function DamageCommonFunction(guardcondition, estep, fall_type)

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if (DMN_ActionCancel_Mode == GC_MODES.ACTION_CANCEL_DEFAULT or DMN_ActionCancel_Mode == GC_MODES.ACTION_CANCEL_STRICT) and Action_IsGuardCounterPossible() == FALSE then
			Action_SetSpecial(TRUE)
		end
	end
	-- CUSTOM: End.

	if ExecPassiveAction(FALSE, fall_type, FALSE) == TRUE then
		return TRUE
	end

	SetVariable("ToggleDash", 0)
	SetEnableAimMode()

	if c_SwordArtsID == 352 and (c_SwordArtsHand == HAND_LEFT or c_Style == HAND_RIGHT_BOTH)
		and env(GetSpEffectID, 102340) == TRUE and 0 < env(ActionDuration, ACTION_ARM_L2) then
		if c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH then
			SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)
			ExecEventAllBody("W_SwordArtsBothGuardCounter")
			return TRUE
		else
			SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)
			ExecEventAllBody("W_SwordArtsLeftGuardCounter")
			return TRUE
		end
	end

	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		ResetDamageCount()
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		ResetDamageCount()
		return TRUE
	end

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		Action_SetEvadingPossible(TRUE)
	end
	-- CUSTOM: End.

	local is_usechainrecover = GetVariable("UseChainRecover")

	if ExecEvasion(TRUE, estep, is_usechainrecover) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, ALLBODY) == TRUE then
		ResetDamageCount()
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, ALLBODY, FALSE) == TRUE then
		ResetDamageCount()
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		ResetDamageCount()
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", guardcondition, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		ResetDamageCount()
		return TRUE
	end
	if env(IsMoveCancelPossible) == TRUE then
		ResetDamageCount()
	end
	if ExecQuickTurnOnCancelTiming() == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(guardcondition, ALLBODY) == TRUE then
		ResetDamageCount()
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		ResetDamageCount()
		return TRUE
	end
	return FALSE
end

function QuickTurnCommonFunction()
	act(SetCanChangeEquipmentOff)
	act(AllowBuddyWarp)

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, UPPER) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, UPPER) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(UPPER) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, UPPER) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, UPPER, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(UPPER) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, UPPER, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return TRUE
	end
	return FALSE
end

function LandCommonFunction()
	act(SetCanChangeEquipmentOn)

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if ExecQuickTurnOnCancelTiming() == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return TRUE
	end
	return FALSE
end

function ItemCommonFunction(blend_type)
	act(SetCanChangeEquipmentOff)
	if env(GetStateChangeType, 15) == FALSE then
		act(SetIsItemAnimationPlaying)
	end

	if GetVariable("IsEnableToggleDashTest") == 2 then
		SetVariable("ToggleDash", 0)
	end

	if GetVariable("MoveSpeedLevel") <= 0 then
		act(FallPreventionAssist)
	end

	SetAIActionState()

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(blend_type) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, blend_type, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, blend_type, FALSE) == TRUE then
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return TRUE
	end
	return FALSE
end

function StealthItemCommonFunction(blend_type)
	act(SetIsItemAnimationPlaying)

	if GetVariable("IsEnableToggleDashTest") == 2 then
		SetVariable("ToggleDash", 0)
	end

	if GetVariable("MoveSpeedLevel") <= 0 then
		act(FallPreventionAssist)
	end

	SetAIActionState()

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(blend_type) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, blend_type, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, blend_type, FALSE) == TRUE then
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Stealth_Move, FALSE) == TRUE then
		act(DebugLogOutput, "StealthItemCommonFunction MoveStartonCancelTiming")
		return TRUE
	end
	return FALSE
end

function QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, blend_type, quick_type)
	act(SetIsItemAnimationPlaying)

	if GetVariable("MoveSpeedLevel") <= 0 then
		act(FallPreventionAssist)
	end

	SetAIActionState()

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, blend_type) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(blend_type) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecAttack(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, FALSE, blend_type, FALSE, FALSE, FALSE) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecItem(quick_type, blend_type) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecMagic(QUICKTYPE_ATTACK, ALLBODY, FALSE) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	return FALSE
end

function StopCommonFunction(is_dash_stop)
	act(Wait)

	if is_dash_stop == TRUE then
		if c_IsStealth == TRUE then
			act(LockonSystemUnableToTurnAngle, 0, 0)
		else
			act(LockonSystemUnableToTurnAngle, 180, 180)
		end
	elseif env(IsCOMPlayer) == TRUE then
		act(LockonSystemUnableToTurnAngle, 15, 15)
	else
		act(LockonSystemUnableToTurnAngle, 45, 45)
	end

	SetEnableAimMode()

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if LadderStart() == TRUE then
		return TRUE
	end
	if is_dash_stop == FALSE and c_IsStealth == FALSE and ExecQuickTurn(ALLBODY, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecGuard(Event_GuardStart, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStance(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecRide() == TRUE then
		return TRUE
	end

	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"

	if c_IsStealth == TRUE then
		r1 = "W_AttackRightLightStealth"
		b1 = "W_AttackBothLightStealth"
	end

	if ExecAttack(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1,
		"W_AttackBothHeavy1Start", FALSE, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if env(GetSpEffectID, 100170) == TRUE then
		act(LockonFixedAngleCancel)
		if ExecDashTurn() == TRUE then
			return TRUE
		end
	end

	if c_IsStealth == TRUE then
		if MoveStart(ALLBODY, Event_Stealth_Move, FALSE) == TRUE then
			return TRUE
		end
	elseif MoveStart(ALLBODY, Event_Move, FALSE) == TRUE then
		return TRUE
	end

	if ExecGesture() == TRUE then
		return TRUE
	end
	return FALSE
end

function MoveCommonFunction(blend_type)

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if Cancel_IsCooldown() == TRUE then
			return TRUE
		end
	end
	-- CUSTOM: End.

	act(Wait)
	act(AllowBuddyWarp)
	SetEnableAimMode()

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if LadderStart() == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecGuard(Event_GuardStart, blend_type) == TRUE then
		return TRUE
	end

	local speed = GetVariable("MoveSpeedIndex")

	if speed == 2 then
		if ExecItem(QUICKTYPE_DASH, blend_type) == TRUE then
			return TRUE
		end
	elseif speed == 1 then
		if ExecItem(QUICKTYPE_RUN, blend_type) == TRUE then
			return TRUE
		end
	elseif ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end

	if speed == 2 then
		if ExecMagic(QUICKTYPE_DASH, blend_type, FALSE) == TRUE then
			return TRUE
		end
	elseif ExecMagic(QUICKTYPE_NORMAL, blend_type, FALSE) == TRUE then
		return TRUE
	end

	if ExecArtsStance(blend_type) == TRUE then
		return TRUE
	end
	if ExecRide() == TRUE then
		return TRUE
	end

	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"

	if speed == 2 then
		r1 = "W_AttackRightLightDash"
		r2 = "W_AttackRightHeavyDash"
		b1 = "W_AttackBothDash"
		b2 = "W_AttackBothHeavyDash"
	elseif c_IsStealth == TRUE then
		r1 = "W_AttackRightLightStealth"
		b1 = "W_AttackBothLightStealth"
	end
	if ExecAttack(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, UPPER, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if ExecGesture() == TRUE then
		return TRUE
	end
	if ExecStop() == TRUE then
		return TRUE
	end
	return FALSE
end

function GuardCommonFunction(is_guard_end, blend_type, is_just_guard)
	act(Wait)

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if env(GetSpEffectID, 170) == TRUE then
		return FALSE
	end
	if LadderStart() == TRUE then
		return TRUE
	end
	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if is_guard_end == TRUE then
		if ExecArtsStanceOnCancelTiming(blend_type) == TRUE then
			return TRUE
		end
	elseif env(ActionRequest, ACTION_ARM_L2) == TRUE and ExecArtsStance(blend_type) == TRUE then
		return TRUE
	end

	if GetVariable("MoveSpeedIndex") == 2 then
		if ExecItem(QUICKTYPE_DASH, blend_type) == TRUE then
			return TRUE
		end
	elseif GetVariable("MoveSpeedIndex") == 1 then
		if ExecItem(QUICKTYPE_RUN, blend_type) == TRUE then
			return TRUE
		end
	elseif ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end
	if GetVariable("MoveSpeedIndex") == 2 then
		if ExecMagic(QUICKTYPE_DASH, blend_type, FALSE) == TRUE then
			return TRUE
		end
	elseif GetVariable("MoveSpeedIndex") == 1 then
		if ExecMagic(QUICKTYPE_RUN, blend_type, FALSE) == TRUE then
			return TRUE
		end
	elseif ExecMagic(QUICKTYPE_NORMAL, blend_type, FALSE) == TRUE then
		return TRUE
	end

	if GetVariable("MoveSpeedLevelReal") > 1.100000023841858 then
		if ExecAttack("W_AttackRightLightDash", "W_AttackRightHeavyDash", nil, "W_AttackLeftHeavy1", "W_AttackBothDash",
			"W_AttackBothHeavyDash", FALSE, UPPER, FALSE, FALSE, FALSE) == TRUE then
			return TRUE
		end
	else
		local guard_attack = TRUE

		if is_guard_end == TRUE then
			guard_attack = FALSE
		end

		if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", nil, "W_AttackLeftHeavy1",
			"W_AttackBothLight1", "W_AttackBothHeavy1Start", guard_attack, blend_type, FALSE, FALSE, FALSE) == TRUE then
			return TRUE
		end
	end

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if Combo_IsGuardStance() == TRUE and Request_IsReleased(GC_BUTTONS.L1) == TRUE or Stat_GetSP() <= 0 then
			ExecEvent("W_DMN_GuardStance1_End")
			return TRUE
		end
	end
	-- CUSTOM: End.

	if is_just_guard == TRUE then
		if env(GetSpEffectID, 20100006) == TRUE and JUSTGUARD_IS_FIRSTFRAME == FALSE
			and (env(ActionCancelRequest, ACTION_ARM_L1) == TRUE or env(ActionDuration, ACTION_ARM_L1) <= 0) then
			ExecEventHalfBlendNoReset(Event_GuardEnd, blend_type)
			return TRUE
		end
		JUSTGUARD_IS_FIRSTFRAME = FALSE
		if env(ActionRequest, ACTION_ARM_L1) == TRUE and ExecGuard(Event_GuardStart, blend_type) == TRUE then
			return TRUE
		end
	elseif is_guard_end == FALSE then
		if env(ActionCancelRequest, ACTION_ARM_L1) == TRUE or env(ActionDuration, ACTION_ARM_L1) <= 0 then
			ExecEventHalfBlendNoReset(Event_GuardEnd, blend_type)
			return TRUE
		end
	elseif (env(ActionRequest, ACTION_ARM_L1) == TRUE or env(ActionDuration, ACTION_ARM_L1) > 0)
		and ExecGuard(Event_GuardStart, blend_type) == TRUE then
		return TRUE
	end
	return FALSE
end

function ArtsCommonFunction(r1, r2, l1, l2, b1, b2, guardcondition, artsr1, artsr2, gen_trans, can_throw, blend_type)
	if can_throw == FALSE then
		SetThrowAtkInvalid()
	end

	SetAIActionState()
	act(SetCanChangeEquipmentOff)

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecItem(QUICKTYPE_ATTACK, blend_type) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecMagic(QUICKTYPE_ATTACK, blend_type, FALSE) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecAttack(r1, r2, l1, l2, b1, b2, guardcondition, blend_type, artsr1, artsr2, FALSE) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecQuickTurnOnCancelTiming() == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecJump() == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		ClearAttackQueue()
		return TRUE
	end

	local guardcondition = FALSE

	if env(GetSpEffectID, 100410) == TRUE then
		guardcondition = TO_GUARDON
	end

	if c_SwordArtsID ~= 335 and ExecGuardOnCancelTiming(guardcondition, blend_type) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Move, gen_trans) == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	if ExecGesture() == TRUE then
		ClearAttackQueue()
		return TRUE
	end
	return FALSE
end

function ArtsParryCommonFunction()
	SetAIActionState()

	if ExecPassiveAction(TRUE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_ATTACK, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_ATTACK, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if ExecQuickTurnOnCancelTiming() == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return TRUE
	end
	if ExecGesture() == TRUE then
		return TRUE
	end
	return FALSE
end

function ArtsStanceCommonFunction(r1, r2, l1, l2, b1, b2, blend_type, turn_type, artsr1, artsr2, is_stance_end, enable_turn)
	if is_stance_end == FALSE then
		SetThrowAtkInvalid()
	end

	SetAIActionState()
	act(SetCanChangeEquipmentOff)

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if c_SwordArtsID ~= 335 and env(ActionDuration, ACTION_ARM_L1) < 440 and ExecGuardOnCancelTiming(FALSE, blend_type)
		== TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if is_stance_end == TRUE and ExecArtsStanceOnCancelTiming(blend_type) == TRUE then
		return TRUE
	end
	if ExecAttack(r1, r2, l1, l2, b1, b2, FALSE, blend_type, artsr1, artsr2, FALSE) == TRUE then
		return TRUE
	end
	if blend_type ~= UPPER and enable_turn and ExecQuickTurn(LOWER, turn_type) == TRUE then
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		if is_stance_end == TRUE then
			SetArtsGeneratorTransitionIndex()
		end

		ClearAttackQueue()
		return TRUE
	end
	return FALSE
end

function ArtsChargeShotCommonFunction()
	SetAIActionState()

	if env(GetEventEzStateFlag, 1) == FALSE then
		act(SetTurnSpeed, 0)
	end

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return TRUE
	end
	return FALSE
end

function WeaponChangeCommonFunction(blend_type)
	SetAIActionState()
	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, blend_type, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(blend_type) == TRUE then
		return TRUE
	end
	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"
	if env(GetSpEffectID, 100002) == TRUE and env(ActionDuration, ACTION_ARM_SP_MOVE) > 0 then
		r1 = "W_AttackRightLightDash"
		r2 = "W_AttackRightHeavyDash"
		b1 = "W_AttackBothDash"
		b2 = "W_AttackBothHeavyDash"
	end
	if ExecAttack(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, blend_type, FALSE, FALSE, FALSE)
		== TRUE then
		return TRUE
	end
	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	return FALSE
end

function HandChangeCommonFunction(blend_type)
	SetAIActionState()

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, blend_type, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(blend_type) == TRUE then
		return TRUE
	end
	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"
	if env(GetSpEffectID, 100002) == TRUE and env(ActionDuration, ACTION_ARM_SP_MOVE) > 0 then
		r1 = "W_AttackRightLightDash"
		r2 = "W_AttackRightHeavyDash"
		b1 = "W_AttackBothDash"
		b2 = "W_AttackBothHeavyDash"
	end
	if ExecAttack(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, blend_type, FALSE, FALSE, FALSE)
		== TRUE then
		return TRUE
	end
	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	return FALSE
end

function ChainRecoverCommonFunction()
	SetAIActionState()

	if ExecPassiveAction(FALSE, FALL_TYPE_DEFAULT, FALSE) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(blend_type) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, blend_type) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, blend_type) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(blend_type) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, blend_type, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	return FALSE
end

function Event_Activate()
	ActivateRightArmAdd(START_FRAME_NONE)
	SetVariable("IsEventActivate", true)
end

function Event_Update()
	if GetVariable("IsEventActivate") == false then
		UpdateRightArmAdd()
	end

	SetVariable("IsEventActivate", false)
end

function EventCommonFunction()
	if env(GetEventEzStateFlag, 0) == FALSE then
		act(SetIsEventAnim)
	end

	act(SetCanChangeEquipmentOn)

	if env(HasThrowRequest) == TRUE then
		return TRUE
	end
	if ExecTalkDeath() == TRUE then
		return TRUE
	end
	if ExecDeath() == TRUE then
		return TRUE
	end
	if ExecTalkDamage() == TRUE then
		return TRUE
	end
	if env(GetSpEffectID, 9913) == FALSE and ExecDamage(FALSE) == TRUE then
		return TRUE
	end
	if ExecFallStart(FALL_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if ExecTalk() == TRUE then
		return TRUE
	end
	if ExecQuickTurnOnCancelTiming() == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(QUICKTYPE_NORMAL, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecMagic(QUICKTYPE_NORMAL, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecAttack("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end

	local moveEvent = Event_MoveQuick

	if c_IsStealth == TRUE then
		moveEvent = Event_Stealth_Move
	end

	if MoveStartonCancelTiming(moveEvent, FALSE) == TRUE then
		return TRUE
	end
	return FALSE
end

function HalfBlendLowerCommonFunction(event, lower_state, to_idle_on_cancel, disable_stealth_move)
	if disable_stealth_move == nil then
		disable_stealth_move = FALSE
	end

	if lower_state == LOWER_MOVE then
		if ExecStopHalfBlend(event, to_idle_on_cancel) == TRUE then
			return TRUE
		end
	else
		local blend_type = LOWER

		if env(IsMoveCancelPossible) == TRUE then
			blend_type = ALLBODY
		end

		local move_event = Event_Move

		if c_IsStealth == TRUE and disable_stealth_move == FALSE then
			move_event = Event_Stealth_Move
		end

		if MoveStart(blend_type, move_event, FALSE) == TRUE then
			return TRUE
		end
		if lower_state == LOWER_END_TURN then
			ExecEventHalfBlendNoReset(event, LOWER)
			return TRUE
		end
	end
	return FALSE
end

function HalfBlendLowerCommonFunctionNoSync(event, lower_state, to_idle_on_cancel, is_fire_upper_on_move)
	if lower_state == LOWER_MOVE then
		if ExecStopHalfBlend(event, to_idle_on_cancel) == TRUE then
			return TRUE
		end
	else
		local blend_type = LOWER

		if env(IsMoveCancelPossible) == TRUE then
			blend_type = ALLBODY
		end

		if MoveStart(blend_type, Event_MoveNoSync, FALSE) == TRUE then
			if is_fire_upper_on_move == TRUE and blend_type == LOWER then
				ExecEventHalfBlend(event, UPPER)
			end
			return TRUE
		end
		if lower_state == LOWER_END_TURN then
			ExecEventHalfBlendNoReset(event, LOWER)
			return TRUE
		end
	end
	return FALSE
end

function HalfBlendUpperCommonFunction(lower_state)
	local exit_flag = FALSE

	if env(IsAnimEnd, 1) == TRUE then
		exit_flag = TRUE
	end

	if lower_state ~= LOWER_IDLE and env(GetEventEzStateFlag, 0) == TRUE then
		exit_flag = TRUE
	end

	if exit_flag == FALSE then
		return FALSE
	end
	if lower_state == LOWER_TURN then
		local turn_state = GetVariable("UpperDefaultState01")
		local event = Event_QuickTurnRight180Mirror

		if turn_state == QUICKTURN_LEFT180_DEF1 then
			event = Event_QuickTurnLeft180Mirror
		end

		ExecEventHalfBlendNoReset(event)
	elseif lower_state == LOWER_MOVE then
		if c_IsStealth == TRUE then
			ExecEventHalfBlendNoReset(Event_Stealth_Move, UPPER)
		else
			ExecEventHalfBlendNoReset(Event_Move, UPPER)
		end
	elseif c_IsStealth == TRUE then
		ExecEventNoReset("W_Stealth_Idle")
	else
		ExecEventNoReset("W_Idle")
	end
	return TRUE
end

function ArrowLowerCommonFunction(event, lower_state, to_idle_on_cancel)
	if lower_state == LOWER_MOVE then
		if ExecStopHalfBlend(event, to_idle_on_cancel) == TRUE then
			return
		end
	else
		if lower_state ~= LOWER_TURN then
			local style = c_Style
			local hand = HAND_RIGHT

			if style == HAND_LEFT_BOTH then
				hand = HAND_LEFT
			end

			if env(GetEquipWeaponCategory, hand) ~= WEAPON_CATEGORY_LARGE_ARROW then
				local move_event = Event_Move

				if c_IsStealth == TRUE then
					move_event = Event_Stealth_Move
				end

				if MoveStart(LOWER, move_event, FALSE) == TRUE then
					return
				end
			elseif env(IsPrecisionShoot) == FALSE and MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
				return
			end
		end

		if lower_state == LOWER_END_TURN then
			ExecEventHalfBlendNoReset(event, LOWER)
		end
	end
end

function Idle_onActivate()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		Action_SetSpecial(FALSE)
		Action_SetCritical(FALSE)
		Combo_SetGuardStance(FALSE)
		Combo_ResetComboActions()
	end
	-- CUSTOM: End.

	SetVariable("MoveSpeedLevelReal", 0)
	ClearAttackQueue()
	act(Wait)
	act(RequestThrowAnimInterrupt)
	act(DisallowAdditiveTurning, TRUE)
end

function Idle_onUpdate()
	SetEnableMimicry()

	if IdleCommonFunction() == TRUE then
		SetVariable("ArtsTransition", 0)
	end
end

function Idle_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function DashStop_onActivate()
	act(Wait)
end

function DashStop_onUpdate()
	if StopCommonFunction(TRUE) == TRUE then
		return
	end
end

function RunStopFront_onActivate()
	act(Wait)
end

function RunStopFront_onUpdate()
	SetEnableMimicry()

	if StopCommonFunction(FALSE) == TRUE then
		return
	end
end

function RunStopBack_onActivate()
	act(Wait)
end

function RunStopBack_onUpdate()
	SetEnableMimicry()
	if StopCommonFunction(FALSE) == TRUE then
		return
	end
end

function RunStopLeft_onActivate()
	act(Wait)
end

function RunStopLeft_onUpdate()
	SetEnableMimicry()
	if StopCommonFunction(FALSE) == TRUE then
		return
	end
end

function RunStopRight_onActivate()
	act(Wait)
end

function RunStopRight_onUpdate()
	SetEnableMimicry()

	if StopCommonFunction(FALSE) == TRUE then
		return
	end
end

function WalkStopFront_onActivate()
	act(Wait)
end

function WalkStopFront_onUpdate()
	SetEnableMimicry()

	if StopCommonFunction(FALSE) == TRUE then
		return
	end
end

function WalkStopBack_onActivate()
	act(Wait)
end

function WalkStopBack_onUpdate()
	SetEnableMimicry()

	if StopCommonFunction(FALSE) == TRUE then
		return
	end
end

function WalkStopLeft_onActivate()
	act(Wait)
end

function WalkStopLeft_onUpdate()
	SetEnableMimicry()

	if StopCommonFunction(FALSE) == TRUE then
		return
	end
end

function WalkStopRight_onActivate()
	act(Wait)
end

function WalkStopRight_onUpdate()
	SetEnableMimicry()

	if StopCommonFunction(FALSE) == TRUE then
		return
	end
end

function Dash180_onActivate()
	act(SetIsTurnAnimInProgress)
end

function Dash180_onUpdate()
	act(SetIsTurnAnimInProgress)

	if QuickTurnCommonFunction() == TRUE then
		return
	end
end

function Rolling_onUpdate()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		Movement_AdjustMultiplier(DMN_RollingDistance_Level)
	end
	-- CUSTOM: End.

	act(DisallowAdditiveTurning, TRUE)
	SetThrowAtkInvalid()

	if env(GetSpEffectID, 100390) == TRUE then
		ResetDamageCount()
	end

	SetEnableAimMode()

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLightStep", "W_AttackRightHeavy1Start",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothLightStep", "W_AttackBothHeavy1Start",
		QUICKTYPE_ROLLING) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventAllBody("W_Idle")
		return
	end
	SetRollingTurnCondition(FALSE)
end

function Rolling_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function Rolling_Selftrans_onUpdate()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		Movement_AdjustMultiplier(DMN_RollingDistance_Level)
	end
	-- CUSTOM: End.

	act(DisallowAdditiveTurning, TRUE)
	SetThrowAtkInvalid()

	if env(GetSpEffectID, 100390) == TRUE then
		ResetDamageCount()
	end

	SetEnableAimMode()

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLightStep", "W_AttackRightHeavy1Start",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothLightStep", "W_AttackBothHeavy1Start",
		QUICKTYPE_ROLLING) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventAllBody("W_Idle")
		return
	end
	SetRollingTurnCondition(TRUE)
end

function Rolling_Selftrans_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function DefaultBackStep_onActivate()
	ResetDamageCount()
end

function DefaultBackStep_onUpdate()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		Movement_AdjustMultiplier(DMN_BackstepDistance_Level)
	end
	-- CUSTOM: End.

	act(SetCanChangeEquipmentOff)
	act(DisallowAdditiveTurning, TRUE)

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightBackstep", "W_AttackRightHeavy1Start",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothBackstep", "W_AttackBothHeavy1Start",
		QUICKTYPE_BACKSTEP) == TRUE then
		return
	end
end

function DefaultBackStep_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function BackStepGuardOn_UpperLayer_onUpdate()
	act(SetCanChangeEquipmentOff)
	if ExecGuardOnCancelTiming(TO_GUARDON, ALLBODY) == TRUE then
		return
	end
	if IsGuard() == FALSE then
		SetVariable("EnableTAE_BackStep", true)
		ExecEventNoReset("W_BackStepGuardEnd_UpperLayer")
		return
	end
end

function BackStepGuardEnd_UpperLayer_onUpdate()
	act(SetCanChangeEquipmentOff)
	if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		ExecEventSyncNoReset("Event_BackStepGuardOut")
	end
end

function EStepDown_onUpdate()
	SetThrowAtkInvalid()
	SetEnableAimMode()

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLightStep", "W_AttackRightHeavy1Start",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothLightStep", "W_AttackBothHeavy1Start",
		QUICKTYPE_ROLLING) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventAllBody("W_Idle")
		return
	end
	SetRollingTurnCondition(FALSE)
end

function ChainRecover_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if ChainRecoverCommonFunction() == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendLowerCommonFunction(Event_ChainRecoverMirror, lower_state, FALSE) == TRUE then
		return
	end
end

function Move_Activate()
	SetWeightIndex()
end

function Move_Update()
	SetWeightIndex()
end

function Move_onActivate()
	act(SwitchMotion, TRUE)
end

function Move_onUpdate()
	act(SwitchMotion, TRUE)

	local move_speed = GetVariable("MoveSpeedIndex")

	if move_speed == 2 then
		SetThrowAtkInvalid()
	end

	if g_TimeActEditor_08 >= 1 then
		act(Set4DirectionMovementThreshold, GetVariable("MagicRightWalkAngle_FrontLeft"),
			GetVariable("MagicRightWalkAngle_FrontRight"), GetVariable("MagicRightWalkAngle_BackLeft"),
			GetVariable("MagicRightWalkAngle_BackRight"))
	elseif 1 <= g_TimeActEditor_09 then
		act(Set4DirectionMovementThreshold, GetVariable("MagicLeftWalkAngle_FrontLeft"),
			GetVariable("MagicLeftWalkAngle_FrontRight"), GetVariable("MagicLeftWalkAngle_BackLeft"),
			GetVariable("MagicLeftWalkAngle_BackRight"))
	elseif hkbGetVariable("MoveType") < 0.5 then
		act(Set4DirectionMovementThreshold, 60, 45, 60, 60)
	elseif hkbGetVariable("StanceMoveType") == 0 then
		act(Set4DirectionMovementThreshold, 70, 40, 60, 20)
	else
		act(Set4DirectionMovementThreshold, 40, 70, 60, 20)
	end

	SpeedUpdate()

	if env(IsCOMPlayer) == TRUE then
		local npc_turn_speed = 240

		if move_speed == 2 then
			npc_turn_speed = 180
		else
			local dir = GetVariable("MoveDirection")
			if dir == 0 then
				npc_turn_speed = 90
			end
		end

		SetTurnSpeed(npc_turn_speed)
	end

	if hkbGetVariable("MoveDirection") == 3 or hkbGetVariable("MoveDirection") == 2 then
		act(SetMovementScaleMult, 0.9599999785423279)
	elseif hkbGetVariable("MoveDirection") == 1 then
		act(SetMovementScaleMult, 0.9599999785423279)
	elseif hkbGetVariable("MoveDirection") == 0 then
		act(SetMovementScaleMult, 0.9800000190734863)
	end

	-- CUSTOM: Begin.
	local base_speed = 1
	local base_speed_percent = base_speed / 100

	if Game_IsPlayer() == TRUE then
		base_speed_percent = base_speed_percent * (1.0 + DMN_RunningSpeed_Level * Movement_GetMultiplier())
	end

	if hkbGetVariable("MoveDirection") == 3 or hkbGetVariable("MoveDirection") == 2 then
		act(2001, base_speed_percent * 95)
	elseif hkbGetVariable("MoveDirection") == 1 then
		act(2001, base_speed_percent * 95)
	elseif hkbGetVariable("MoveDirection") == 0 then
		act(2001, base_speed_percent * 98)
	end
	-- CUSTOM: End.

end

function MoveNoSync_onActivate()
	act(SwitchMotion, TRUE)
end

function MoveNoSync_onUpdate()
	Move_onUpdate()
end

function Move_Upper_onActivate()
	act(Wait)
end

function Move_Upper_onUpdate()
	SetEnableMimicry()

	if MoveCommonFunction(UPPER) == TRUE then
		SetVariable("ArtsTransition", 0)
	end
end

function Guard_Activate()
	local hand = HAND_LEFT

	if c_Style == HAND_RIGHT_BOTH then
		hand = HAND_RIGHT
	end

	act(DebugLogOutput, "Guard_Activate ( ) ")
	SetGuardHand(hand)
	ActivateRightArmAdd(START_FRAME_NONE)
end

function Guard_Update()
	UpdateRightArmAdd()
	local hand = HAND_LEFT
	if c_Style == HAND_RIGHT_BOTH then
		hand = HAND_RIGHT
	end
	if env(GetEquipWeaponSpecialCategoryNumber, hand) == 289 then
		act(AddSpEffect, 19860)
	end
end

function GuardDamage_Active()
	ActivateRightArmAdd(START_FRAME_A02)
end

function GuardDamage_Update()
	UpdateRightArmAdd()
end

function BackStepGuardOn_Upper_Active()
	ActivateRightArmAdd(START_FRAME_A02)
end

function BackStepGuardOn_Upper_Update()
	UpdateRightArmAdd()
end

function BackStepGuardEnd_Upper_Active()
	ActivateRightArmAdd(START_FRAME_A02)
end

function BackStepGuardEnd_Upper_Update()
	UpdateRightArmAdd()
end

function GuardStart_Upper_onActivate()
	act(Wait)
end

function GuardStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
		act(DisallowAdditiveTurning, TRUE)
	else
		act(DisallowAdditiveTurning, FALSE)
	end

	if GuardCommonFunction(FALSE, blend_type, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		ExecEventHalfBlend(Event_GuardOn, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_GuardStart, lower_state, FALSE) == TRUE then
		return
	end
end

function GuardStart_Upper_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function GuardOn_Upper_onActivate()
	act(Wait)
end

function GuardOn_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
		act(DisallowAdditiveTurning, TRUE)
	else
		act(DisallowAdditiveTurning, FALSE)
	end

	if GuardCommonFunction(FALSE, blend_type, FALSE) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_GuardOn, lower_state, FALSE) == TRUE then
		return
	end
end

function GuardOn_Upper_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function GuardEnd_Upper_onActivate()
	act(Wait)
end

function GuardEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
		act(DisallowAdditiveTurning, TRUE)
	else
		act(DisallowAdditiveTurning, FALSE)
	end

	if GuardCommonFunction(TRUE, blend_type, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and (env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE) then
		ExecEventHalfBlendNoReset(Event_MoveQuick, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_GuardEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function JustGuardStartCommonFunction(event)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
		act(DisallowAdditiveTurning, TRUE)
	else
		act(DisallowAdditiveTurning, FALSE)
	end
	if GuardCommonFunction(FALSE, blend_type, TRUE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		ExecEventHalfBlend(Event_GuardOn, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(event, lower_state, FALSE) == TRUE then
		return
	end
end

function GuardStart_JustGuard_Upper_onActivate()
	act(Wait)
	JUSTGUARD_IS_FIRSTFRAME = TRUE
end

function GuardStart_JustGuard_Upper_onUpdate()
	JustGuardStartCommonFunction(Event_GuardStart_JustGuard)
end

function GuardStart_JustGuard_Upper_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function GuardStart_JustGuard_SelfTrans_Upper_onActivate()
	act(Wait)
	JUSTGUARD_IS_FIRSTFRAME = TRUE
end

function GuardStart_JustGuard_SelfTrans_Upper_onUpdate()
	JustGuardStartCommonFunction(Event_GuardStart_JustGuard)
end

function GuardStart_JustGuard_SelfTrans_Upper_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function GuardStart_JustGuard2_Upper_onActivate()
	act(Wait)
	JUSTGUARD_IS_FIRSTFRAME = TRUE
end

function GuardStart_JustGuard2_Upper_onUpdate()
	JustGuardStartCommonFunction(Event_GuardStart_JustGuard2)
end

function GuardStart_JustGuard2_Upper_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function GuardStart_JustGuard3_Upper_onActivate()
	act(Wait)
	JUSTGUARD_IS_FIRSTFRAME = TRUE
end

function GuardStart_JustGuard3_Upper_onUpdate()
	JustGuardStartCommonFunction(Event_GuardStart_JustGuard3)
end

function GuardStart_JustGuard3_Upper_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function GuardStart_JustGuard4_Upper_onActivate()
	act(Wait)
	JUSTGUARD_IS_FIRSTFRAME = TRUE
end

function GuardStart_JustGuard4_Upper_onUpdate()
	JustGuardStartCommonFunction(Event_GuardStart_JustGuard4)
end

function GuardStart_JustGuard4_Upper_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function GuardStart_JustGuard4_SelfTrans_Upper_onActivate()
	act(Wait)
	JUSTGUARD_IS_FIRSTFRAME = TRUE
end

function GuardStart_JustGuard4_SelfTrans_Upper_onUpdate()
	JustGuardStartCommonFunction(Event_GuardStart_JustGuard4_SelfTrans)
end

function GuardStart_JustGuard4_SelfTrans_Upper_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function FallStart_onUpdate()
	if FallCommonFunction(TRUE, FALSE, FALL_DEFAULT) == TRUE then
		return
	end
end

function FallJumpStart_onUpdate()
	if FallCommonFunction(TRUE, TRUE, FALL_DEFAULT) == TRUE then
		return
	end
end

function FallLoop_onUpdate()
	if env(GetSpEffectID, 19935) == TRUE then
		if env(IsHamariFallDeath, 20) == TRUE then
			ExecEvent("W_FallDeath")
			return
		end
	elseif env(IsHamariFallDeath, 12) == TRUE then
		ExecEvent("W_FallDeath")
		return
	end
	if FallCommonFunction(TRUE, FALSE, FALL_DEFAULT) == TRUE then
		return
	end
end

function Land_onUpdate()
	if LandCommonFunction() == TRUE then
		return
	end
end

function LandLow_onActivate()
	act(Wait)
end

function LandLow_onUpdate()
	if IdleCommonFunction() == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventAllBody("W_Idle")
		return
	end
end

function FallStartFaceUp_onUpdate()
	if FallCommonFunction(TRUE, FALSE, FALL_FACEUP) == TRUE then
		return
	end
end

function FallStartFaceDown_onUpdate()
	if FallCommonFunction(TRUE, FALSE, FALL_FACEDOWN) == TRUE then
		return
	end
end

function FallLoopFaceUp_onUpdate()
	if env(GetSpEffectID, 19935) == TRUE then
		if env(IsHamariFallDeath, 20) == TRUE then
			ExecEvent("W_FallDeathFaceUp")
			return
		end
	elseif env(IsHamariFallDeath, 12) == TRUE then
		ExecEvent("W_FallDeathFaceUp")
		return
	end
	if FallCommonFunction(TRUE, FALSE, FALL_FACEUP) == TRUE then
		return
	end
end

function FallLoopFaceDown_onUpdate()
	if env(GetSpEffectID, 19935) == TRUE then
		if env(IsHamariFallDeath, 20) == TRUE then
			ExecEvent("W_FallDeathFaceDown")
			return
		end
	elseif env(IsHamariFallDeath, 12) == TRUE then
		ExecEvent("W_FallDeathFaceDown")
		return
	end
	if FallCommonFunction(TRUE, FALSE, FALL_FACEDOWN) == TRUE then
		return
	end
end

function LandFaceUp_onUpdate()
	if LandCommonFunction() == TRUE then
		return
	end
end

function LandFaceDown_onUpdate()
	if LandCommonFunction() == TRUE then
		return
	end
end

function Damage_Activate()
	ActivateRightArmAdd(START_FRAME_NONE)
end

function Damage_Update()
	UpdateRightArmAdd()
end

function Damage_NoThrowDef_Update()
	if env(GetSpEffectID, 30) == FALSE and env(GetSpEffectID, 19970) == FALSE and env(GetSpEffectID, 19865) == FALSE then
		SetThrowDefInvalid()
	end
end

function DamageSABreak_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return
	end
end

function DamageSleepResist_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return
	end
end

function DamageMad_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return
	end
end

function DamageBind_onActivate()
	ResetRequest()
end

function DamageBind_onUpdate()
	act(SetIsMagicInUse, 0)
	act(SetAllowedThrowDefenseType, 0)
	act(SetAllowedThrowAttackType, 0)

	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return
	end
	if env(GetSpEffectType, 32) == FALSE then
		ExecEventAllBody("W_Idle")
	end
end

function DamageLv1_Small_onUpdate()
	act(SetMovementScaleMult, 0)
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return
	end
end

function DamageLv2_Middle_onUpdate()
	act(SetMovementScaleMult, 0)
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return
	end
end

function DamageLv3_Large_onUpdate()
	act(SetMovementScaleMult, 0)

	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return
	end
end

function DamageLarge2_onUpdate()
	act(SetMovementScaleMult, 0)

	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return
	end
end

function DamageWeak_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return
	end
end

function DamageLv8_Minimum_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return
	end
end

function DamageLv6_Fling_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_DOWN, FALL_TYPE_FACEDOWN_LOOP) == TRUE then
		return
	end
end

function DamageLv4_ExLarge_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_DOWN, FALL_TYPE_FORCE_LOOP) == TRUE then
		return
	end
end

function DamageLv5_Push_onUpdate()
	act(SetMovementScaleMult, 0)

	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return
	end
end

function DamageLv7_SmallBlow_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_DOWN, FALL_TYPE_FORCE_LOOP) == TRUE then
		return
	end
end

function DamageLv9_Upper_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_DOWN, FALL_TYPE_FACEDOWN_LOOP) == TRUE then
		return
	end
end

function DamageLV10_ExBlast_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_DOWN, FALL_TYPE_FORCE_LOOP) == TRUE then
		return
	end
end

function DamageLv11_Breath_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_DOWN, FALL_TYPE_FORCE_LOOP) == TRUE then
		return
	end
end

function DamageParry_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end
end

function GuardDamageSmall_onActivate()
	JUSTGUARD_RELEASE_GUARD_BUTTON = FALSE
end

function GuardDamageSmall_onUpdate()
	act(SetStaminaRecoveryDisabled)

	if DamageCommonFunction(TO_GUARDON, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end

	if env(GetSpEffectID, 102000) == TRUE then
		SetJustGuardReinputState()
	end
end

function GuardDamageMiddle_onActivate()
	JUSTGUARD_RELEASE_GUARD_BUTTON = FALSE
end

function GuardDamageMiddle_onUpdate()
	act(SetStaminaRecoveryDisabled)

	if DamageCommonFunction(TO_GUARDON, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end

	if env(GetSpEffectID, 102000) == TRUE then
		SetJustGuardReinputState()
	end
end

function GuardDamageLarge_onActivate()
	JUSTGUARD_RELEASE_GUARD_BUTTON = FALSE
end

function GuardDamageLarge_onUpdate()
	act(SetStaminaRecoveryDisabled)

	if DamageCommonFunction(TO_GUARDON, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end
	if env(GetSpEffectID, 102000) == TRUE then
		SetJustGuardReinputState()
	end
end

function SetJustGuardSucceedEffect(level)
	if env(GetSpEffectID, 102010) == TRUE or env(GetSpEffectID, 102009) == TRUE then
		act(AddSpEffect, 102010)
	elseif env(GetSpEffectID, 102008) == TRUE then
		if level > 1 then
			act(AddSpEffect, 102010)
		else
			act(AddSpEffect, 102009)
		end
	elseif env(GetSpEffectID, 102007) == TRUE then
		if level > 2 then
			act(AddSpEffect, 102010)
		elseif level == 2 then
			act(AddSpEffect, 102009)
		else
			act(AddSpEffect, 102008)
		end
	elseif level > 3 then
		act(AddSpEffect, 102010)
	elseif level == 3 then
		act(AddSpEffect, 102009)
	elseif level == 2 then
		act(AddSpEffect, 102008)
	else
		act(AddSpEffect, 102007)
	end
	act(AddSpEffect, 102019)
end

function SetJustGuardReinputState()
	if env(ActionDuration, ACTION_ARM_L1) > 0 then
		if JUSTGUARD_RELEASE_GUARD_BUTTON == TRUE then
			if env(GetSpEffectID, 102018) == TRUE or env(GetSpEffectID, 102017) == TRUE or env(GetSpEffectID, 102016)
				== TRUE or env(GetSpEffectID, 102015) == TRUE then
				act(AddSpEffect, 102017)
			elseif env(GetSpEffectID, 102014) == TRUE or env(GetSpEffectID, 102013) == TRUE then
				act(AddSpEffect, 102015)
			elseif env(GetSpEffectID, 102012) == TRUE or env(GetSpEffectID, 102011) == TRUE then
				act(AddSpEffect, 102013)
			else
				act(AddSpEffect, 102011)
			end
		end
		JUSTGUARD_RELEASE_GUARD_BUTTON = FALSE
	else
		JUSTGUARD_RELEASE_GUARD_BUTTON = TRUE
	end
end

function GuardDamageSmall_JustGuard_onActivate()
	JUSTGUARD_RELEASE_GUARD_BUTTON = FALSE
end

function GuardDamageSmall_JustGuard_onUpdate()
	act(SetStaminaRecoveryDisabled)
	if DamageCommonFunction(TO_GUARDON, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end
	SetJustGuardReinputState()
end

function GuardDamageMiddle_JustGuard_onActivate()
	JUSTGUARD_RELEASE_GUARD_BUTTON = FALSE
end

function GuardDamageMiddle_JustGuard_onUpdate()
	act(SetStaminaRecoveryDisabled)
	if DamageCommonFunction(TO_GUARDON, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end
	SetJustGuardReinputState()
end

function GuardDamageLarge_JustGuard_onActivate()
	JUSTGUARD_RELEASE_GUARD_BUTTON = FALSE
end

function GuardDamageLarge_JustGuard_onUpdate()
	act(SetStaminaRecoveryDisabled)
	if DamageCommonFunction(TO_GUARDON, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end
	SetJustGuardReinputState()
end

function GuardBreak_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end
end

function GuardBreakRight_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end
end

function Repelled_Wall_onUpdate()
	act(FallPreventionAssist)

	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end
end

function Repelled_Small_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end
end

function Repelled_Large_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_DEFAULT) == TRUE then
		return
	end
end

function GuardDamageExLarge_onUpdate()
	if DamageCommonFunction(FALSE, ESTEP_DOWN, FALL_TYPE_DEFAULT) == TRUE then
		return
	end
end

function DeathIdle_onActivate()
	act(SetDeathStay, TRUE)
end

function DeathIdle_onDeactivate()
	act(SetDeathStay, FALSE)
end

function QuickTurnLeft180_Upper_onUpdate()
	if QuickTurnCommonFunction() == TRUE then
		return
	end
	if GetVariable("IsLockon") == false then
		ExecEventNoReset("W_Idle")
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_Idle")
		return
	end
end

function QuickTurnRight180_Upper_onUpdate()
	if QuickTurnCommonFunction() == TRUE then
		return
	end
	if GetVariable("IsLockon") == false then
		ExecEventNoReset("W_Idle")
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_Idle")
		return
	end
end

function AttackRight_Activate()
	SetAttackHand(HAND_RIGHT)
	SetGuardHand(HAND_RIGHT)
	ActivateRightArmAdd(START_FRAME_NONE)
end

function AttackRight_Update()
	UpdateRightArmAdd()
end

function AttackRightWhileGuard_Activate()
	SetAttackHand(HAND_RIGHT)
	SetGuardHand(HAND_LEFT)
end

function AttackRightLight1_onUpdate()
	local r1 = "W_AttackRightLight2"

	if g_ComboReset == TRUE then
		r1 = "W_AttackRightLight1"
	end

	if AttackCommonFunction(r1, "W_AttackRightHeavy1SubStart", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight2", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackRightLight2_onUpdate()
	if IsEnableNextAttack(2, HAND_RIGHT) == TRUE then
		local r1 = "W_AttackRightLight3"
		if g_ComboReset == TRUE then
			r1 = "W_AttackRightLight1"
		end
		if AttackCommonFunction(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
			"W_AttackBothLight3", "W_AttackBothHeavy1Start", FALSE, TRUE, 2) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightLight3_onUpdate()
	if IsEnableNextAttack(3, HAND_RIGHT) == TRUE then
		local r1 = "W_AttackRightLight4"
		if g_ComboReset == TRUE then
			r1 = "W_AttackRightLight1"
		end
		if AttackCommonFunction(r1, "W_AttackRightHeavy1SubStart", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
			"W_AttackBothLight4", "W_AttackBothHeavy1Start", FALSE, TRUE, 3) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightLight4_onUpdate()
	if IsEnableNextAttack(4, HAND_RIGHT) == TRUE then
		local r1 = "W_AttackRightLight5"
		if g_ComboReset == TRUE then
			r1 = "W_AttackRightLight1"
		end
		if AttackCommonFunction(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
			"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 4) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight2", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightLight5_onUpdate()
	if IsEnableNextAttack(5, HAND_RIGHT) == TRUE then
		local r1 = "W_AttackRightLight6"
		if g_ComboReset == TRUE then
			r1 = "W_AttackRightLight1"
		end
		if AttackCommonFunction(r1, "W_AttackRightHeavy1SubStart", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
			"W_AttackBothLight6", "W_AttackBothHeavy1Start", FALSE, TRUE, 5) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightLight6_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightLightStep_onUpdate()
	local r1 = "W_AttackRightLightSubStart"
	if g_ComboReset == TRUE then
		r1 = "W_AttackRightLight1"
	end
	if AttackCommonFunction(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackRightLightStealth_onUpdate()
	local r1 = "W_AttackRightLightSubStart"
	if g_ComboReset == TRUE then
		r1 = "W_AttackRightLight1"
	end
	if AttackCommonFunction(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackRightLightFastStep_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightLightDash_onUpdate()
	local r1 = "W_AttackRightLightSubStart"
	if g_ComboReset == TRUE then
		r1 = "W_AttackRightLight1"
	end
	if AttackCommonFunction(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackRightHeavyDash_onUpdate()
	local r1 = "W_AttackRightLightSubStart"
	if g_ComboReset == TRUE then
		r1 = "W_AttackRightLight1"
	end
	if AttackCommonFunction(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackRightWhileGuard_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", TO_GUARDON, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightHeavy1SubStart_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy2Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 0) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE or env(IsAnimEnd, 1) == TRUE then
		act(SetSpecialInterpolation, 0, TRUE)
		ExecEventAllBody("W_AttackRightHeavy1Start")
		return
	end
end

function AttackRightLightSubStart_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 0) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE or env(IsAnimEnd, 1) == TRUE then
		act(SetSpecialInterpolation, 0, TRUE)
		ExecEventAllBody("W_AttackRightLight2")
		return
	end
end

function AttackRightHeavy1Start_onUpdate()
	act(SetSpecialInterpolation, 0, FALSE)
	if IsEnableSpecialAttack(HAND_RIGHT) == TRUE and 0 < env(ActionDuration, ACTION_ARM_R2) and 0
		< env(ActionDuration, ACTION_ARM_SP_MOVE) and env(GetSpEffectID, 100290) == TRUE then
		ExecEventAllBody("W_AttackRightSpecial1")
		return
	end
	local r1 = "W_AttackRightLightSubStart"
	if g_ComboReset == TRUE then
		r1 = "W_AttackRightLight1"
	end
	if AttackCommonFunction(r1, "W_AttackRightHeavy2Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
	if 0 >= env(ActionDuration, ACTION_ARM_R2)
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_AttackRightHeavy1End")
		return
	end
end

function AttackRightHeavy1End_onUpdate()
	local r1 = "W_AttackRightLightSubStart"
	if g_ComboReset == TRUE then
		r1 = "W_AttackRightLight1"
	end
	if AttackCommonFunction(r1, "W_AttackRightHeavy2Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackRightHeavy2Start_onUpdate()
	if IsEnableSpecialAttack(HAND_RIGHT) == TRUE and env(ActionDuration, ACTION_ARM_R2) > 0
		and env(ActionDuration, ACTION_ARM_SP_MOVE) > 0 and env(GetSpEffectID, 100290) == TRUE then
		if env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT) == 953 then
			ExecEventAllBody("W_AttackRightSpecial1")
		else
			ExecEventAllBody("W_AttackRightSpecial2")
		end
		return
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_R2) <= 0
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_AttackRightHeavy2End")
		return
	end
end

function AttackRightHeavy2End_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightHeavySpecial1SubStart_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy2Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 0) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE or env(IsAnimEnd, 1) == TRUE then
		act(SetSpecialInterpolation, 0, TRUE)
		ExecEventAllBody("W_AttackRightHeavySpecial1Start")
		return
	end
end

function AttackRightHeavySpecial1Start_onUpdate()
	act(SetSpecialInterpolation, 0, FALSE)
	if env(IsAnimEnd, 0) == TRUE then
		SetRightSpecialHeavyAttackGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	local gen_trans = FALSE
	if env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT) == 852 then
		gen_trans = TRUE
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy2Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 0, gen_trans) == TRUE then
		return
	end
	if 0 >= env(ActionDuration, ACTION_ARM_R2)
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_AttackRightHeavySpecial1End")
		return
	end
end

function AttackRightHeavySpecial1End_onUpdate()
	if env(IsAnimEnd, 0) == TRUE then
		SetRightSpecialHeavyAttackGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	local gen_trans = FALSE
	if env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT) == 852 then
		gen_trans = TRUE
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy2Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 0, gen_trans) == TRUE then
		return
	end
end

function AttackRightHeavySpecial2Start_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
	if 0 >= env(ActionDuration, ACTION_ARM_R2)
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_AttackRightHeavySpecial2End")
		return
	end
end

function AttackRightHeavySpecial2End_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightSpecial1_onUpdate()
	if AttackCommonFunction("W_AttackRightBackstep", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightSpecial2_onUpdate()
	if AttackCommonFunction("W_AttackRightBackstep", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightBackstep_onUpdate()
	local r1 = "W_AttackRightLightSubStart"
	if g_ComboReset == TRUE then
		r1 = "W_AttackRightLight1"
	end
	if AttackCommonFunction(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackLeft_Activate()
	SetAttackHand(HAND_LEFT)
	SetGuardHand(HAND_LEFT)
	ActivateRightArmAdd(START_FRAME_A02)
end

function AttackLeft_Update()
	SetVariable("IndexDamageParryHand", 1)
	UpdateRightArmAdd()
end

function AttackLeft_Deactivate()
	SetVariable("IndexDamageParryHand", 0)
end

function AttackLeftLight1_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackLeftHeavy1_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", nil, "W_AttackLeftHeavy2",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackLeftHeavy2_onUpdate()
	if IsEnableNextAttack(2, HAND_LEFT) == TRUE then
		if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", nil, "W_AttackLeftHeavy3",
			"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", nil, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackLeftHeavy3_onUpdate()
	if IsEnableNextAttack(3, HAND_LEFT) == TRUE then
		if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", nil, "W_AttackLeftHeavy4",
			"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 3) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", nil, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackLeftHeavy4_onUpdate()
	if IsEnableNextAttack(4, HAND_LEFT) == TRUE then
		if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", nil, "W_AttackLeftHeavy5",
			"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", nil, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackLeftHeavy5_onUpdate()
	if IsEnableNextAttack(5, HAND_LEFT) == TRUE then
		if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", nil, "W_AttackLeftHeavy6",
			"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", nil, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackLeftHeavy6_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", nil, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackDual_Activate()
	SetAttackHand(HAND_RIGHT)
	SetGuardHand(HAND_LEFT)
	act(SetThrowPossibilityState_Defender, 400000)
end

function AttackDualLight1_onUpdate()
	local l1 = "W_AttackLeftLight2"
	if g_ComboReset == TRUE or GetDualAttackMaxNumber(HAND_RIGHT) <= 1 then
		l1 = "W_AttackLeftLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", l1, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackDualLight2_onUpdate()
	local l1 = "W_AttackLeftLight3"
	if g_ComboReset == TRUE or GetDualAttackMaxNumber(HAND_RIGHT) <= 2 then
		l1 = "W_AttackLeftLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", l1, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackDualLight3_onUpdate()
	local l1 = "W_AttackLeftLight4"
	if g_ComboReset == TRUE or GetDualAttackMaxNumber(HAND_RIGHT) <= 3 then
		l1 = "W_AttackLeftLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", l1, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackDualLight4_onUpdate()
	local l1 = "W_AttackLeftLight5"
	if g_ComboReset == TRUE or GetDualAttackMaxNumber(HAND_RIGHT) <= 4 then
		l1 = "W_AttackLeftLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", l1, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackDualLight5_onUpdate()
	local l1 = "W_AttackLeftLight6"
	if g_ComboReset == TRUE or GetDualAttackMaxNumber(HAND_RIGHT) <= 5 then
		l1 = "W_AttackLeftLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", l1, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackDualLight6_onUpdate()
	local l1 = "W_AttackLeftLight1"
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", l1, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackDualDash_onUpdate()
	local l1 = "W_AttackDualLightSubStart"
	if g_ComboReset == TRUE then
		l1 = "W_AttackLeftLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", l1, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackDualRolling_onUpdate()
	local l1 = "W_AttackDualLightSubStart"
	if g_ComboReset == TRUE then
		l1 = "W_AttackLeftLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", l1, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackDualStealth_onUpdate()
	local l1 = "W_AttackDualLightSubStart"
	if g_ComboReset == TRUE then
		l1 = "W_AttackLeftLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", l1, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackDualBackStep_onUpdate()
	local l1 = "W_AttackDualLightSubStart"
	if g_ComboReset == TRUE then
		l1 = "W_AttackLeftLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", l1, "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackDualLightSubStart_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end

	if env(GetEventEzStateFlag, 0) == TRUE or env(IsAnimEnd, 1) == TRUE then
		act(SetSpecialInterpolation, 0, TRUE)
		ExecEventAllBody("W_AttackDualLight2")
		return
	end
end

function AttackBoth_Activate()
	local hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end
	SetAttackHand(hand)
	SetGuardHand(hand)
end

function AttackBothLight1_onUpdate()
	local b1 = "W_AttackBothLight2"
	if g_ComboReset == TRUE then
		b1 = "W_AttackBothLight1"
	end
	if AttackCommonFunction("W_AttackRightLight2", "W_AttackRightHeavy1Start", "W_AttackBothLeft2",
		"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1SubStart", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackBothLight2_onUpdate()
	if IsEnableNextAttack(2, HAND_RIGHT) == TRUE then
		local b1 = "W_AttackBothLight3"
		if g_ComboReset == TRUE then
			b1 = "W_AttackBothLight1"
		end
		if AttackCommonFunction("W_AttackRightLight3", "W_AttackRightHeavy1Start", "W_AttackBothLeft3",
			"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1Start", FALSE, TRUE, 2) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLight3_onUpdate()
	if IsEnableNextAttack(3, HAND_RIGHT) == TRUE then
		local b1 = "W_AttackBothLight4"
		if g_ComboReset == TRUE then
			b1 = "W_AttackBothLight1"
		end
		if AttackCommonFunction("W_AttackRightLight4", "W_AttackRightHeavy1Start", "W_AttackBothLeft2",
			"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1SubStart", FALSE, TRUE, 3) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLight4_onUpdate()
	if IsEnableNextAttack(4, HAND_RIGHT) == TRUE then
		local b1 = "W_AttackBothLight5"
		if g_ComboReset == TRUE then
			b1 = "W_AttackBothLight1"
		end
		if AttackCommonFunction("W_AttackRightLight5", "W_AttackRightHeavy1Start", "W_AttackBothLeft2",
			"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1SubStart", FALSE, TRUE, 4) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLight5_onUpdate()
	if IsEnableNextAttack(5, HAND_RIGHT) == TRUE then
		local b1 = "W_AttackBothLight6"
		if g_ComboReset == TRUE then
			b1 = "W_AttackBothLight1"
		end
		if AttackCommonFunction("W_AttackRightLight6", "W_AttackRightHeavy1Start", "W_AttackBothLeft2",
			"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1SubStart", FALSE, TRUE, 5) == TRUE then
			return
		end
	elseif AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLight6_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft2",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1SubStart", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLeft1_onUpdate()
	if AttackCommonFunction("W_AttackRightLight2", "W_AttackRightHeavy1Start", "W_AttackBothLeft2",
		"W_AttackLeftHeavy1", "W_AttackBothLight2", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackBothLeft2_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft3",
		"W_AttackLeftHeavy1", "W_AttackBothLight3", "W_AttackBothHeavy1Start", FALSE, TRUE, 2) == TRUE then
		return
	end
end

function AttackBothLeft3_onUpdate()
	if AttackCommonFunction("W_AttackRightLight2", "W_AttackRightHeavy1Start", "W_AttackBothLeft2",
		"W_AttackLeftHeavy1", "W_AttackBothLight2", "W_AttackBothHeavy1Start", FALSE, TRUE, 3) == TRUE then
		return
	end
end

function AttackBothLeftDash_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLeftStep_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLeftSpecial1_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeftSpecial2",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLeftSpecial2_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeftSpecial3",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLeftSpecial3_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeftSpecial4",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLeftSpecial4_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeftSpecial5",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLeftSpecial5_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothLightSubStart_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 0) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE or env(IsAnimEnd, 1) == TRUE then
		act(SetSpecialInterpolation, 0, TRUE)
		ExecEventAllBody("W_AttackBothLight2")
		return
	end
end

function AttackBothHeavy1SubStart_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 0) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE or env(IsAnimEnd, 1) == TRUE then
		act(SetSpecialInterpolation, 0, TRUE)
		ExecEventAllBody("W_AttackBothHeavy1Start")
		return
	end
end

function AttackBothHeavy1Start_onUpdate()
	act(SetSpecialInterpolation, 0, FALSE)
	if IsEnableSpecialAttack(HAND_RIGHT) == TRUE and 0 < env(ActionDuration, ACTION_ARM_R2) and 0
		< env(ActionDuration, ACTION_ARM_SP_MOVE) and env(GetSpEffectID, 100290) == TRUE then
		ExecEventAllBody("W_AttackBothSpecial1")
		return
	end
	local b1 = "W_AttackBothLightSubStart"
	if g_ComboReset == TRUE then
		b1 = "W_AttackBothLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy2Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy2Start", FALSE, TRUE, 1) == TRUE then
		return
	end
	if 0 >= env(ActionDuration, ACTION_ARM_R2)
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_AttackBothHeavy1End")
		return
	end
end

function AttackBothHeavy1End_onUpdate()
	local b1 = "W_AttackBothLightSubStart"
	if g_ComboReset == TRUE then
		b1 = "W_AttackBothLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy2Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy2Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackBothHeavy2Start_onUpdate()
	if IsEnableSpecialAttack(HAND_RIGHT) == TRUE and env(ActionDuration, ACTION_ARM_R2) > 0
		and env(ActionDuration, ACTION_ARM_SP_MOVE) > 0 and env(GetSpEffectID, 100290) == TRUE then
		local hand = HAND_RIGHT
		if c_Style == HAND_LEFT_BOTH then
			hand = HAND_LEFT
		end
		if env(GetEquipWeaponSpecialCategoryNumber, hand) == 953 then
			ExecEventAllBody("W_AttackBothSpecial1")
		else
			ExecEventAllBody("W_AttackBothSpecial2")
		end
		return
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_R2) <= 0
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_AttackBothHeavy2End")
		return
	end
end

function AttackBothHeavy2End_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothHeavySpecial1SubStart_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 0) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE or env(IsAnimEnd, 1) == TRUE then
		act(SetSpecialInterpolation, 0, TRUE)
		ExecEventAllBody("W_AttackBothHeavySpecial1Start")
		return
	end
end

function AttackBothHeavySpecial1Start_onUpdate()
	act(SetSpecialInterpolation, 0, FALSE)
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 0) == TRUE then
		return
	end
	if 0 >= env(ActionDuration, ACTION_ARM_R2)
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_AttackBothHeavySpecial1End")
		return
	end
end

function AttackBothHeavySpecial1End_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothHeavySpecial2Start_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
	if 0 >= env(ActionDuration, ACTION_ARM_R2)
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_AttackBothHeavySpecial2End")
		return
	end
end

function AttackBothHeavySpecial2End_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothSpecial1_onUpdate()
	if AttackCommonFunction("W_AttackRightBackstep", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothBackstep", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothSpecial2_onUpdate()
	if AttackCommonFunction("W_AttackRightBackstep", "W_AttackRightHeavy1Start", "W_AttackBothLeft1",
		"W_AttackLeftHeavy1", "W_AttackBothBackstep", "W_AttackBothHeavy1Start", FALSE, TRUE, 0) == TRUE then
		return
	end
end

function AttackBothDash_onUpdate()
	local b1 = "W_AttackBothLightSubStart"
	if g_ComboReset == TRUE then
		b1 = "W_AttackBothLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackBothHeavyDash_onUpdate()
	local b1 = "W_AttackBothLightSubStart"
	if g_ComboReset == TRUE then
		b1 = "W_AttackBothLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackBothLightStep_onUpdate()
	local b1 = "W_AttackBothLightSubStart"
	if g_ComboReset == TRUE then
		b1 = "W_AttackBothLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackBothLightStealth_onUpdate()
	local b1 = "W_AttackBothLightSubStart"
	if g_ComboReset == TRUE then
		b1 = "W_AttackBothLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackBothBackstep_onUpdate()
	local b1 = "W_AttackBothLightSubStart"
	if g_ComboReset == TRUE then
		b1 = "W_AttackBothLight1"
	end
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackBothLightGuard_onUpdate()
	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", TO_GUARDON, TRUE, 0) == TRUE then
		return
	end
end

function AttackRightLightCounter_onUpdate()
	local r1 = "W_AttackRightLightSubStart"
	if g_ComboReset == TRUE then
		r1 = "W_AttackRightLight1"
	end
	if AttackCommonFunction(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight2", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackRightHeavyCounter_onUpdate()
	local r1 = "W_AttackRightLightSubStart"
	local b1 = "W_AttackBothLightSubStart"
	if g_ComboReset == TRUE then
		r1 = "W_AttackRightLight1"
		b1 = "W_AttackBothLight1"
	end
	if AttackCommonFunction(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1,
		"W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackBothLightCounter_onUpdate()
	local r1 = "W_AttackRightLightSubStart"
	local b1 = "W_AttackBothLightSubStart"

	if g_ComboReset == TRUE then
		r1 = "W_AttackRightLight1"
		b1 = "W_AttackBothLight1"
	end

	if AttackCommonFunction(r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLightSubStart", "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackBothHeavyCounter_onUpdate()
	local b1 = "W_AttackBothLightSubStart"
	if g_ComboReset == TRUE then
		b1 = "W_AttackBothLight1"
	end
	if AttackCommonFunction("W_AttackRightLight2", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1Start", FALSE, TRUE, 1) == TRUE then
		return
	end
end

function AttackArrowRight_Activate()
	local hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end
	SetAttackHand(hand)
	SetGuardHand(hand)
end

function AttackArrowLeft_Activate()
	local hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end
	SetAttackHand(hand)
	SetGuardHand(hand)
end

function AttackArrowRightStart_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventHalfBlend(Event_AttackArrowRightLoop, blend_type)
				return
			else
				ExecEventHalfBlend(Event_AttackArrowRightFireMove, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventHalfBlend(Event_AttackArrowRightLoop, blend_type)
			return
		else
			ExecEventHalfBlend(Event_AttackArrowRightFireMove, blend_type)
			return
		end
	end
	if ArrowLowerCommonFunction(Event_AttackArrowRightStart, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackArrowRightStartContinue_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventHalfBlend(Event_AttackArrowRightLoop, blend_type)
				return
			else
				ExecEventHalfBlend(Event_AttackArrowRightFireMove, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventHalfBlend(Event_AttackArrowRightLoop, blend_type)
			return
		else
			ExecEventHalfBlend(Event_AttackArrowRightFireMove, blend_type)
			return
		end
	end
	if ArrowLowerCommonFunction(Event_AttackArrowRightStartContinue, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackArrowRightLoop_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if g_ArrowSlot == 0 then
		if 0 >= env(ActionDuration, ACTION_ARM_R1) then
			ExecEventHalfBlend(Event_AttackArrowRightFireMove, blend_type)
			return
		end
	elseif 0 >= env(ActionDuration, ACTION_ARM_R2) then
		ExecEventHalfBlend(Event_AttackArrowRightFireMove, blend_type)
		return
	end
	if ArrowLowerCommonFunction(Event_AttackArrowRightLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackArrowRightFire_onUpdate()
	act(SetIsPreciseShootingPossible)
	if ArrowCommonFunction(ALLBODY, TRUE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if env(GetStamina) > 0 then
		local request = GetAttackRequest(FALSE)
		if request == ATTACK_REQUEST_ARROW_FIRE_RIGHT or request == ATTACK_REQUEST_ARROW_FIRE_RIGHT2 then
			if env(GetEquipWeaponCategory, HAND_RIGHT) ~= WEAPON_CATEGORY_LARGE_ARROW then
				if env(IsOutOfAmmo, 1) == TRUE then
					ExecEventAllBody("W_NoArrow")
					return
				else
					SetVariable("NoAmmo", 0)
					ExecEventHalfBlend(Event_AttackArrowRightStartContinue, ALLBODY)
					return
				end
			elseif env(IsOutOfAmmo, 1) == TRUE then
				ExecEventAllBody("W_NoArrow")
				return
			else
				ExecEventHalfBlend(Event_AttackArrowRightStartContinue, ALLBODY)
				return
			end
		end
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return
	end
end

function AttackArrowRightFireMove_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, TRUE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if env(GetStamina) > 0 then
		local request = GetAttackRequest(FALSE)
		if request == ATTACK_REQUEST_ARROW_FIRE_RIGHT or request == ATTACK_REQUEST_ARROW_FIRE_RIGHT2 then
			if env(GetEquipWeaponCategory, HAND_RIGHT) ~= WEAPON_CATEGORY_LARGE_ARROW then
				if env(IsOutOfAmmo, 1) == TRUE then
					ExecEventAllBody("W_NoArrow")
					return
				else
					SetVariable("NoAmmo", 0)
					act(DebugLogOutput, "AttackArrowRightStartContinue 0")
					ExecEventHalfBlend(Event_AttackArrowRightStartContinue, blend_type)
					act(DebugLogOutput, "AttackArrowRightStartContinue")
					return
				end
			elseif env(IsOutOfAmmo, 1) == TRUE then
				ExecEventAllBody("W_NoArrow")
				return
			else
				ExecEventHalfBlend(Event_AttackArrowRightStartContinue, blend_type)
				return
			end
		end
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if ArrowLowerCommonFunction(Event_AttackArrowRightFireMove, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackArrowRightFireDash_onUpdate()
	act(SetIsPreciseShootingPossible)
	if ArrowCommonFunction(ALLBODY, TRUE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if env(GetStamina) > 0 then
		local request = GetAttackRequest(FALSE)
		if request == ATTACK_REQUEST_ARROW_FIRE_RIGHT or request == ATTACK_REQUEST_ARROW_FIRE_RIGHT2 then
			if env(GetEquipWeaponCategory, HAND_RIGHT) ~= WEAPON_CATEGORY_LARGE_ARROW then
				if env(IsOutOfAmmo, 1) == TRUE then
					ExecEventAllBody("W_NoArrow")
					return
				else
					SetVariable("NoAmmo", 0)
					ExecEventHalfBlend(Event_AttackArrowRightStartContinue, ALLBODY)
					return
				end
			elseif env(IsOutOfAmmo, 1) == TRUE then
				ExecEventAllBody("W_NoArrow")
				return
			else
				ExecEventHalfBlend(Event_AttackArrowRightStartContinue, ALLBODY)
				return
			end
		end
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return
	end
end

function AttackArrowRightFireStep_onUpdate()
	act(SetIsPreciseShootingPossible)
	if ArrowCommonFunction(ALLBODY, TRUE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if env(GetStamina) > 0 then
		local request = GetAttackRequest(FALSE)
		if request == ATTACK_REQUEST_ARROW_FIRE_RIGHT or request == ATTACK_REQUEST_ARROW_FIRE_RIGHT2 then
			if env(GetEquipWeaponCategory, HAND_RIGHT) ~= WEAPON_CATEGORY_LARGE_ARROW then
				if env(IsOutOfAmmo, 1) == TRUE then
					ExecEventAllBody("W_NoArrow")
					return
				else
					SetVariable("NoAmmo", 0)
					ExecEventHalfBlend(Event_AttackArrowRightStartContinue, ALLBODY)
					return
				end
			elseif env(IsOutOfAmmo, 1) == TRUE then
				ExecEventAllBody("W_NoArrow")
				return
			else
				ExecEventHalfBlend(Event_AttackArrowRightStartContinue, ALLBODY)
				return
			end
		end
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return
	end
end

function AttackArrowLeftStart_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventHalfBlend(Event_AttackArrowLeftLoop, blend_type)
				return
			else
				ExecEventHalfBlend(Event_AttackArrowLeftFireMove, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventHalfBlend(Event_AttackArrowLeftLoop, blend_type)
			return
		else
			ExecEventHalfBlend(Event_AttackArrowLeftFireMove, blend_type)
			return
		end
	end
	if ArrowLowerCommonFunction(Event_AttackArrowLeftStart, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackArrowLeftStartContinue_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventHalfBlend(Event_AttackArrowLeftLoop, blend_type)
				return
			else
				ExecEventHalfBlend(Event_AttackArrowLeftFireMove, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventHalfBlend(Event_AttackArrowLeftLoop, blend_type)
			return
		else
			ExecEventHalfBlend(Event_AttackArrowLeftFireMove, blend_type)
			return
		end
	end
	if ArrowLowerCommonFunction(Event_AttackArrowLeftStartContinue, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackArrowLeftLoop_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if g_ArrowSlot == 0 then
		if 0 >= env(ActionDuration, ACTION_ARM_R1) then
			ExecEventHalfBlend(Event_AttackArrowLeftFireMove, blend_type)
			return
		end
	elseif 0 >= env(ActionDuration, ACTION_ARM_R2) then
		ExecEventHalfBlend(Event_AttackArrowLeftFireMove, blend_type)
		return
	end
	if ArrowLowerCommonFunction(Event_AttackArrowLeftLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackArrowLeftFire_onUpdate()
	act(SetIsPreciseShootingPossible)
	if ArrowCommonFunction(ALLBODY, TRUE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if env(GetStamina) <= 0 then
		return
	end
	local request = GetAttackRequest(FALSE)
	if request == ATTACK_REQUEST_ARROW_FIRE_LEFT or request == ATTACK_REQUEST_ARROW_FIRE_LEFT2 then
		if env(GetEquipWeaponCategory, HAND_LEFT) ~= WEAPON_CATEGORY_LARGE_ARROW then
			if env(IsOutOfAmmo, 0) == TRUE then
				ExecEventAllBody("W_NoArrow")
				return
			else
				if env(GetEquipWeaponCategory, HAND_LEFT) == WEAPON_CATEGORY_ARROW then
					ExecEventHalfBlend(Event_AttackArrowLeftStartContinue, ALLBODY)
				else
					ExecEventHalfBlend(Event_AttackArrowLeftStart, ALLBODY)
				end
				return
			end
		elseif env(IsOutOfAmmo, 0) == TRUE then
			ExecEventAllBody("W_NoArrow")
			return
		else
			ExecEventHalfBlend(Event_AttackArrowLeftStart, ALLBODY)
			return
		end
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return
	end
end

function AttackArrowLeftFireMove_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, TRUE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if env(GetStamina) > 0 then
		local request = GetAttackRequest(FALSE)
		if request == ATTACK_REQUEST_ARROW_FIRE_LEFT or request == ATTACK_REQUEST_ARROW_FIRE_LEFT2 then
			if env(GetEquipWeaponCategory, HAND_LEFT) ~= WEAPON_CATEGORY_LARGE_ARROW then
				if env(IsOutOfAmmo, 0) == TRUE then
					ExecEventAllBody("W_NoArrow")
					return
				else
					SetVariable("NoAmmo", 0)
					ExecEventHalfBlend(Event_AttackArrowLeftStartContinue, blend_type)
					return
				end
			elseif env(IsOutOfAmmo, 0) == TRUE then
				ExecEventAllBody("W_NoArrow")
				return
			else
				ExecEventHalfBlend(Event_AttackArrowLeftStartContinue, blend_type)
				return
			end
		end
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if ArrowLowerCommonFunction(Event_AttackArrowLeftFireMove, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackArrowLeftFireDash_onUpdate()
	act(SetIsPreciseShootingPossible)
	if ArrowCommonFunction(ALLBODY, TRUE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return
	end
end

function AttackArrowLeftFireStep_onUpdate()
	act(SetIsPreciseShootingPossible)
	if ArrowCommonFunction(ALLBODY, TRUE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return
	end
end

function NoArrow_onUpdate()
	if ArrowCommonFunction(ALLBODY, TRUE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if MoveStartonCancelTiming(Event_Move, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowRight_Activate()
	local hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end
	SetAttackHand(hand)
	SetGuardHand(hand)
end

function AttackCrossbowLeft_Activate()
	SetAttackHand(HAND_LEFT)
	SetGuardHand(HAND_LEFT)
	ActivateRightArmAdd(START_FRAME_A02)
end

function AttackCrossbowLeft_Update()
	UpdateRightArmAdd()
end

function AttackCrossbowRightStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventHalfBlend(Event_AttackCrossbowRightLoop, blend_type)
				return
			else
				ExecEventHalfBlend(Event_AttackCrossbowRightFire, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventHalfBlend(Event_AttackCrossbowRightLoop, blend_type)
			return
		else
			ExecEventHalfBlend(Event_AttackCrossbowRightFire, blend_type)
			return
		end
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowRightLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowRightLoop_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if g_ArrowSlot == 0 then
		if 0 >= env(ActionDuration, ACTION_ARM_R1) then
			ExecEventHalfBlend(Event_AttackCrossbowRightFire, blend_type)
			return
		end
	elseif 0 >= env(ActionDuration, ACTION_ARM_R2) then
		ExecEventHalfBlend(Event_AttackCrossbowRightFire, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowRightLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowRightFire_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowRightFire, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowRightReload_Upper_onUpdate()
	act(Set4DirectionMovementThreshold, 60, 80, 60, 60)
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowRightReload, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowRightEmpty_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowRightEmpty, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowLeftStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_L1) > 0 then
				ExecEventHalfBlend(Event_AttackCrossbowLeftLoop, blend_type)
				return
			else
				ExecEventHalfBlend(Event_AttackCrossbowLeftFire, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_L2) > 0 then
			ExecEventHalfBlend(Event_AttackCrossbowLeftLoop, blend_type)
			return
		else
			ExecEventHalfBlend(Event_AttackCrossbowLeftFire, blend_type)
			return
		end
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowLeftLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowLeftLoop_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if g_ArrowSlot == 0 then
		if 0 >= env(ActionDuration, ACTION_ARM_L1) then
			ExecEventHalfBlend(Event_AttackCrossbowLeftFire, blend_type)
			return
		end
	elseif 0 >= env(ActionDuration, ACTION_ARM_L2) then
		ExecEventHalfBlend(Event_AttackCrossbowLeftFire, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowLeftLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowLeftFire_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowLeftFire, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowLeftReload_Upper_onUpdate()
	act(Set4DirectionMovementThreshold, 60, 45, 60, 60)
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowLeftReload, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowLeftEmpty_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowLeftEmpty, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowBothLeftStart_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_L1) > 0 then
				ExecEventHalfBlend(Event_AttackCrossbowBothLeftLoop, blend_type)
				return
			else
				ExecEventHalfBlend(Event_AttackCrossbowBothLeftFire, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_l2) > 0 then
			ExecEventHalfBlend(Event_AttackCrossbowBothLeftLoop, blend_type)
			return
		else
			ExecEventHalfBlend(Event_AttackCrossbowBothLeftFire, blend_type)
			return
		end
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowBothLeftLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowBothLeftLoop_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if g_ArrowSlot == 0 then
		if 0 >= env(ActionDuration, ACTION_ARM_L1) then
			ExecEventHalfBlend(Event_AttackCrossbowBothLeftFire, blend_type)
			return
		end
	elseif 0 >= env(ActionDuration, ACTION_ARM_L2) then
		ExecEventHalfBlend(Event_AttackCrossbowBothLeftFire, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowBothLeftLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowBothLeftFire_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowBothLeftFire, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowBothLeftReload_Upper_onUpdate()
	act(Set4DirectionMovementThreshold, 60, 80, 60, 60)
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowBothLeftReload, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowBothLeftEmpty_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowBothLeftEmpty, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowBothRightStart_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	local fireEvent = Event_AttackCrossbowBothRightFire
	if c_Style == HAND_LEFT_BOTH then
		fireEvent = Event_AttackCrossbowBothLeftFire
	end
	if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventHalfBlend(Event_AttackCrossbowBothRightLoop, blend_type)
				return
			else
				ExecEventHalfBlend(fireEvent, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventHalfBlend(Event_AttackCrossbowBothRightLoop, blend_type)
			return
		else
			ExecEventHalfBlend(fireEvent, blend_type)
			return
		end
	end

	fireEvent = HalfBlendLowerCommonFunction
	fireEvent = fireEvent(Event_AttackCrossbowBothRightLoop, lower_state, FALSE)

	if fireEvent == TRUE then
		return
	end
end

function AttackCrossbowBothRightStartContinue_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	local fireEvent = Event_AttackCrossbowBothRightFire
	if c_Style == HAND_LEFT_BOTH then
		fireEvent = Event_AttackCrossbowBothLeftFire
	end
	if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventHalfBlend(Event_AttackCrossbowBothRightLoop, blend_type)
				return
			else
				ExecEventHalfBlend(fireEvent, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventHalfBlend(Event_AttackCrossbowBothRightLoop, blend_type)
			return
		else
			ExecEventHalfBlend(fireEvent, blend_type)
			return
		end
	end

	fireEvent = HalfBlendLowerCommonFunction
	fireEvent = fireEvent(Event_AttackCrossbowBothRightLoop, lower_state, FALSE)

	if fireEvent == TRUE then
		return
	end
end

function AttackCrossbowBothRightLoop_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	local fireEvent = Event_AttackCrossbowBothRightFire
	if c_Style == HAND_LEFT_BOTH then
		fireEvent = Event_AttackCrossbowBothLeftFire
	end
	if g_ArrowSlot == 0 then
		if 0 >= env(ActionDuration, ACTION_ARM_R1) then
			ExecEventHalfBlend(fireEvent, blend_type)
			return
		end
	elseif 0 >= env(ActionDuration, ACTION_ARM_R2) then
		ExecEventHalfBlend(fireEvent, blend_type)
		return
	end

	fireEvent = HalfBlendLowerCommonFunction
	fireEvent = fireEvent(Event_AttackCrossbowBothRightLoop, lower_state, FALSE)

	if fireEvent == TRUE then
		return
	end
end

function AttackCrossbowBothRightFire_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local attackHand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		attackHand = HAND_LEFT
	end

	local blend_type, lower_state = GetHalfBlendInfo()

	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowBothRightFire, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowBothRightReload_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	act(Set4DirectionMovementThreshold, 60, 80, 60, 60)
	local blend_type, lower_state = GetHalfBlendInfo()

	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowBothRightReload, lower_state, FALSE) == TRUE then
		return
	end
end

function AttackCrossbowBothRightEmpty_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_AttackCrossbowBothRightEmpty, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthAttackCrossbowRightStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end

	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventHalfBlend(Event_StealthAttackCrossbowRightLoop, blend_type)
				return
			else
				ExecEventHalfBlend(Event_StealthAttackCrossbowRightFire, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventHalfBlend(Event_StealthAttackCrossbowRightLoop, blend_type)
			return
		else
			ExecEventHalfBlend(Event_StealthAttackCrossbowRightFire, blend_type)
			return
		end
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowRightLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthAttackCrossbowRightLoop_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if g_ArrowSlot == 0 then
		if 0 >= env(ActionDuration, ACTION_ARM_R1) then
			ExecEventHalfBlend(Event_StealthAttackCrossbowRightFire, blend_type)
			return
		end
	elseif 0 >= env(ActionDuration, ACTION_ARM_R2) then
		ExecEventHalfBlend(Event_StealthAttackCrossbowRightFire, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowRightLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthAttackCrossbowRightFire_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowRightFire, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowRightEmpty_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowRightEmpty, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowRightReload_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowRightReload, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowLeftStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_L1) > 0 then
				ExecEventHalfBlend(Event_StealthAttackCrossbowLeftLoop, blend_type)
				return
			else
				ExecEventHalfBlend(Event_StealthAttackCrossbowLeftFire, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_L2) > 0 then
			ExecEventHalfBlend(Event_StealthAttackCrossbowLeftLoop, blend_type)
			return
		else
			ExecEventHalfBlend(Event_StealthAttackCrossbowLeftFire, blend_type)
			return
		end
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowLeftLoop, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if 0 < GetVariable("MoveSpeedLevel") then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowLeftLoop_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if g_ArrowSlot == 0 then
		if 0 >= env(ActionDuration, ACTION_ARM_L1) then
			ExecEventHalfBlend(Event_StealthAttackCrossbowLeftFire, blend_type)
			return
		end
	elseif 0 >= env(ActionDuration, ACTION_ARM_L2) then
		ExecEventHalfBlend(Event_StealthAttackCrossbowLeftFire, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowLeftLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthAttackCrossbowLeftFire_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowLeftFire, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowLeftEmpty_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowLeftEmpty, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowLeftReload_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowLeftReload, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowBothLeftStart_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_L1) > 0 then
				ExecEventHalfBlend(Event_StealthAttackCrossbowBothLeftLoop, blend_type)
				return
			else
				ExecEventHalfBlend(Event_StealthAttackCrossbowBothLeftFire, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_l2) > 0 then
			ExecEventHalfBlend(Event_StealthAttackCrossbowBothLeftLoop, blend_type)
			return
		else
			ExecEventHalfBlend(Event_StealthAttackCrossbowBothLeftFire, blend_type)
			return
		end
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowBothLeftLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthAttackCrossbowBothLeftLoop_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if g_ArrowSlot == 0 then
		if 0 >= env(ActionDuration, ACTION_ARM_L1) then
			ExecEventHalfBlend(Event_StealthAttackCrossbowBothLeftFire, blend_type)
			return
		end
	elseif 0 >= env(ActionDuration, ACTION_ARM_L2) then
		ExecEventHalfBlend(Event_StealthAttackCrossbowBothLeftFire, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowBothLeftLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthAttackCrossbowBothLeftFire_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowBothLeftFire, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowBothLeftEmpty_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowBothLeftEmpty, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowBothLeftReload_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowBothLeftReload, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowBothRightStart_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	local fireEvent = Event_StealthAttackCrossbowBothRightFire
	if c_Style == HAND_LEFT_BOTH then
		fireEvent = Event_StealthAttackCrossbowBothLeftFire
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventHalfBlend(Event_StealthAttackCrossbowBothRightLoop, blend_type)
				return
			else
				ExecEventHalfBlend(fireEvent, blend_type)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventHalfBlend(Event_StealthAttackCrossbowBothRightLoop, blend_type)
			return
		else
			ExecEventHalfBlend(fireEvent, blend_type)
			return
		end
	end

	fireEvent = HalfBlendLowerCommonFunction
	fireEvent = fireEvent(Event_StealthAttackCrossbowBothRightLoop, lower_state, FALSE)

	if fireEvent == TRUE then
		return
	end
end

function StealthAttackCrossbowBothRightLoop_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if CrossbowCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	local fireEvent = Event_StealthAttackCrossbowBothRightFire
	if c_Style == HAND_LEFT_BOTH then
		fireEvent = Event_StealthAttackCrossbowBothLeftFire
	end
	if g_ArrowSlot == 0 then
		if 0 >= env(ActionDuration, ACTION_ARM_R1) then
			ExecEventHalfBlend(fireEvent, blend_type)
			return
		end
	elseif 0 >= env(ActionDuration, ACTION_ARM_R2) then
		ExecEventHalfBlend(fireEvent, blend_type)
		return
	end

	fireEvent = HalfBlendLowerCommonFunction
	fireEvent = fireEvent(Event_StealthAttackCrossbowBothRightLoop, lower_state, FALSE)

	if fireEvent == TRUE then
		return
	end
end

function StealthAttackCrossbowBothRightFire_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()

	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowBothRightFire, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowBothRightReload_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowBothRightReload, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthAttackCrossbowBothRightEmpty_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if CrossbowCommonFunction(blend_type, TRUE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthAttackCrossbowBothRightEmpty, lower_state, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		if GetVariable("MoveSpeedLevel") > 0 then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function SwordArts_Activate()
	local hand = c_SwordArtsHand
	SetAttackHand(hand)
	SetGuardHand(hand)
	ActivateRightArmAdd(START_FRAME_NONE)
end

function SwordArts_Update()
	UpdateRightArmAdd()
end

function DrawStanceRightStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_LARGE_ARROW)
		== TRUE then
		act(SetIsPreciseShootingPossible)
		if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
			return
		end
		if ArrowStanceCommonFunction(blend_type, FALSE) == TRUE then
			return
		end
	end
	if GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_CROSSBOW) == TRUE then
		act(SetIsPreciseShootingPossible)
		if CrossbowStanceCommonFunction(blend_type, FALSE) == TRUE then
			return
		end
	end
	local r1 = "W_DrawStanceRightAttackLight"
	local r2 = "W_DrawStanceRightAttackHeavy"
	local b1 = "W_DrawStanceRightAttackLight"
	local b2 = "W_DrawStanceRightAttackHeavy"
	if c_SwordArtsID == 239 or c_SwordArtsID == 309 then
		r1 = "W_AttackRightLight2"
		r2 = "W_AttackRightHeavy1Start"
		b1 = "W_AttackBothLight2"
		b2 = "W_AttackBothHeavy1Start"
	end

	if env(GetSpEffectID, 100530) == TRUE then
		r1 = "W_SwordArtsStanceAttackLightStart"
		r2 = "W_SwordArtsStanceAttackHeavyStart"
		b1 = "W_SwordArtsStanceAttackLightStart"
		b2 = "W_SwordArtsStanceAttackHeavyStart"
	elseif env(GetSpEffectID, 100540) == TRUE then
		r1 = "W_SwordArtsStanceAttackLight180"
		r2 = "W_SwordArtsStanceAttackHeavy180"
		b1 = "W_SwordArtsStanceAttackLight180"
		b2 = "W_SwordArtsStanceAttackHeavy180"
	end
	local enable_turn = TRUE
	if c_SwordArtsID == 309 then
		enable_turn = FALSE
	end
	if ArtsStanceCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, blend_type,
		TURN_TYPE_STANCE, TRUE, TRUE, FALSE, enable_turn) == TRUE then
		return
	end

	if env(GetSpEffectID, 19945) == TRUE then
		SetVariable("DrawStanceRightEndType", 1)
	else
		SetVariable("DrawStanceRightEndType", 0)
	end

	if env(GetGeneralTAEFlag, 10) == TRUE
		and (env(ActionDuration, ACTION_ARM_L2) < 200 or env(ActionCancelRequest, ACTION_ARM_L2) == TRUE) then
		ExecEventHalfBlend(Event_DrawStanceRightEnd, blend_type)
		return
	end
	if env(IsAnimEnd, 1) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		local index = c_SwordArtsID
		if index == 10 or index == 11 or index == 340 or index == 341 or index == 309 then
			drawStanceNoSyncLoop_NoMP = GetVariable("IsEnoughArtPointsL2")
			ExecEventHalfBlendNoReset(Event_DrawStanceNoSyncLoop, blend_type)
		else
			ExecEventHalfBlendNoReset(Event_DrawStanceRightLoop, blend_type)
		end
		return
	end
	if HalfBlendLowerCommonFunction(Event_DrawStanceRightStart, lower_state, FALSE) == TRUE then
		return
	end
end

function DrawStanceRightLoop_Upper_onUpdate()
	if c_SwordArtsID == 318 then
		SetSwordArtsPointInfo(ACTION_ARM_R1, TRUE)
	else
		SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)
	end
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_LARGE_ARROW)
		== TRUE then
		act(DebugLogOutput, "ArrowStanceRightLoop")
		act(SetIsPreciseShootingPossible)
		if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
			return
		end
		if ArrowStanceCommonFunction(blend_type, FALSE) == TRUE then
			return
		end
	end
	if GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_CROSSBOW) == TRUE then
		act(SetIsPreciseShootingPossible)
		if CrossbowStanceCommonFunction(blend_type, FALSE) == TRUE then
			return
		end
	end
	local r1 = "W_DrawStanceRightAttackLight"
	local r2 = "W_DrawStanceRightAttackHeavy"
	local b1 = "W_DrawStanceRightAttackLight"
	local b2 = "W_DrawStanceRightAttackHeavy"
	if c_SwordArtsID == 239 then
		r1 = "W_AttackRightLight2"
		r2 = "W_AttackRightHeavy1Start"
		b1 = "W_AttackBothLight2"
		b2 = "W_AttackBothHeavy1Start"
	end
	if env(GetSpEffectID, 100530) == TRUE then
		r1 = "W_SwordArtsStanceAttackLightStart"
		r2 = "W_SwordArtsStanceAttackHeavyStart"
		b1 = "W_SwordArtsStanceAttackLightStart"
		b2 = "W_SwordArtsStanceAttackHeavyStart"
	elseif env(GetSpEffectID, 100540) == TRUE then
		r1 = "W_SwordArtsStanceAttackLight180"
		r2 = "W_SwordArtsStanceAttackHeavy180"
		b1 = "W_SwordArtsStanceAttackLight180"
		b2 = "W_SwordArtsStanceAttackHeavy180"
	end
	if ArtsStanceCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, blend_type,
		TURN_TYPE_STANCE, TRUE, TRUE, FALSE, TRUE) == TRUE then
		return
	end

	if env(GetSpEffectID, 19945) == TRUE then
		SetVariable("DrawStanceRightEndType", 1)
	else
		SetVariable("DrawStanceRightEndType", 0)
	end

	if c_SwordArtsID == 239 then
		if env(GetStamina) <= 0 then
			ExecEventHalfBlend(Event_DrawStanceRightEnd, blend_type)
			return
		end
		if GetVariable("IsEnoughArtPointsL2") == 1 then
			ExecEventHalfBlend(Event_DrawStanceRightEnd, blend_type)
			return
		end
	end
	if c_SwordArtsID == 25 and env(GetStamina) <= 0 then
		ExecEventHalfBlend(Event_DrawStanceRightEnd, blend_type)
		return
	end
	if GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_LARGE_ARROW) == TRUE and MoveStartonCancelTiming(Event_Move, FALSE)
		== TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 or env(ActionCancelRequest, ACTION_ARM_L2) == TRUE then
		ExecEventHalfBlend(Event_DrawStanceRightEnd, blend_type)
		return
	end
	if GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_LARGE_ARROW) == FALSE and c_SwordArtsID ~= 105 and c_SwordArtsID
		~= 108 and c_SwordArtsID ~= 169 and HalfBlendLowerCommonFunction(Event_DrawStanceRightLoop, lower_state, FALSE)
		== TRUE then
		return
	end
end

drawStanceNoSyncLoop_NoMP = 0

function DrawStanceNoSyncLoop_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 90, 90)
	end
	local r1 = "W_DrawStanceRightAttackLight"
	local r2 = "W_DrawStanceRightAttackHeavy"
	local b1 = "W_DrawStanceRightAttackLight"
	local b2 = "W_DrawStanceRightAttackHeavy"

	if env(GetSpEffectID, 100530) == TRUE then
		r1 = "W_SwordArtsStanceAttackLightStart"
		r2 = "W_SwordArtsStanceAttackHeavyStart"
		b1 = "W_SwordArtsStanceAttackLightStart"
		b2 = "W_SwordArtsStanceAttackHeavyStart"
	elseif env(GetSpEffectID, 100540) == TRUE then
		r1 = "W_SwordArtsStanceAttackLight180"
		r2 = "W_SwordArtsStanceAttackHeavy180"
		b1 = "W_SwordArtsStanceAttackLight180"
		b2 = "W_SwordArtsStanceAttackHeavy180"
	end
	if ArtsStanceCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, blend_type,
		TURN_TYPE_STANCE, TRUE, TRUE, FALSE, FALSE) == TRUE then
		return
	end

	if env(GetSpEffectID, 19945) == TRUE then
		SetVariable("DrawStanceRightEndType", 1)
	else
		SetVariable("DrawStanceRightEndType", 0)
	end

	if env(GetEventEzStateFlag, 0) == TRUE
		and (env(ActionDuration, ACTION_ARM_L2) <= 0 or env(ActionCancelRequest, ACTION_ARM_L2) == TRUE
			or env(GetStamina) <= 0 or drawStanceNoSyncLoop_NoMP == FALSE and GetVariable("IsEnoughArtPointsL2") == 1
			or drawStanceNoSyncLoop_NoMP == FALSE and GetVariable("IsEnoughArtPointsL2_DrawStanceNoSyncLoop") == 1) then
		ExecEventHalfBlend(Event_DrawStanceRightEnd, blend_type)
		return
	end
	if HalfBlendLowerCommonFunctionNoSync(Event_DrawStanceNoSyncLoop, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function DrawStanceNoSyncLoopMax_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 90, 90)
	end
	local r1 = "W_DrawStanceRightAttackMaxLight"
	local r2 = "W_DrawStanceRightAttackMaxHeavy"
	local b1 = "W_DrawStanceRightAttackMaxLight"
	local b2 = "W_DrawStanceRightAttackMaxHeavy"
	if env(GetSpEffectID, 100530) == TRUE then
		r1 = "W_DrawStanceRightAttackMaxLightR90"
		r2 = "W_DrawStanceRightAttackMaxHeavyR90"
		b1 = "W_DrawStanceRightAttackMaxLightR90"
		b2 = "W_DrawStanceRightAttackMaxHeavyR90"
	elseif env(GetSpEffectID, 100540) == TRUE then
		r1 = "W_DrawStanceRightAttackMaxLight180"
		r2 = "W_DrawStanceRightAttackMaxHeavy180"
		b1 = "W_DrawStanceRightAttackMaxLight180"
		b2 = "W_DrawStanceRightAttackMaxHeavy180"
	elseif env(GetSpEffectID, 100550) == TRUE then
		r1 = "W_DrawStanceRightAttackMaxLightL90"
		r2 = "W_DrawStanceRightAttackMaxHeavyL90"
		b1 = "W_DrawStanceRightAttackMaxLightL90"
		b2 = "W_DrawStanceRightAttackMaxHeavyL90"
	end
	if ArtsStanceCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, blend_type, TRUE, TRUE,
		FALSE, FALSE) == TRUE then
		return
	end

	if env(GetSpEffectID, 19945) == TRUE then
		SetVariable("DrawStanceRightEndType", 1)
	else
		SetVariable("DrawStanceRightEndType", 0)
	end

	if env(ActionDuration, ACTION_ARM_L2) <= 0 or env(ActionCancelRequest, ACTION_ARM_L2) == TRUE then
		ExecEventHalfBlend(Event_DrawStanceRightEnd, blend_type)
		return
	end
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, c_SwordArtsHand)
	if sp_kind == 248 and env(GetStamina) <= 0 then
		ExecEventHalfBlend(Event_DrawStanceRightEnd, blend_type)
		return
	end
	if HalfBlendLowerCommonFunctionNoSync(Event_DrawStanceRightLoopMaxNoSync, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function DrawStanceRightEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	end
	if GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_LARGE_ARROW)
		== TRUE then
		act(SetIsPreciseShootingPossible)
		if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
			return
		end
	end
	local enable_turn = TRUE
	if c_SwordArtsID == 309 then
		enable_turn = FALSE
	end
	if ArtsStanceCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", blend_type,
		TURN_TYPE_DEFAULT, FALSE, FALSE, TRUE, enable_turn) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		SetArtsGeneratorTransitionIndex()
		return
	end
	if lower_state == LOWER_END_TURN then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
	elseif HalfBlendLowerCommonFunction(Event_DrawStanceRightEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function DrawStanceRightAttackLight_onUpdate()
	if GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_LARGE_ARROW)
		== TRUE then
		act(SetIsPreciseShootingPossible)
		if ArrowCommonFunction(ALLBODY, TRUE, TURN_TYPE_DEFAULT) == TRUE then
			return
		end
		if env(GetSpEffectID, 100280) == TRUE
			and (g_ArrowSlot == 0 and env(ActionDuration, ACTION_ARM_R1) <= 0 or g_ArrowSlot == 1
				and env(ActionDuration, ACTION_ARM_R2) <= 0) then
			ExecEventAllBody("W_DrawStanceRightAttackLightCancel")
			return
		end
		if ArrowStanceCommonFunction(ALLBODY, TRUE) == TRUE then
			return
		end
	end

	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"

	if env(GetEquipWeaponCategory, HAND_RIGHT) == WEAPON_CATEGORY_STRAIGHT_SWORD then
		r1 = "W_AttackRightLight2"
		r2 = "W_AttackRightHeavy2Start"
		b1 = "W_AttackBothLight2"
		b2 = "W_AttackBothHeavy2Start"
	end

	local artsr1 = FALSE
	local artsr2 = FALSE

	if env(GetSpEffectID, 19921) == TRUE and env(ActionDuration, ACTION_ARM_L2) > 0 then
		r1 = "W_DrawStanceRightAttackLight"
		r2 = "W_DrawStanceRightAttackHeavy"
		b1 = "W_DrawStanceRightAttackLight"
		b2 = "W_DrawStanceRightAttackHeavy"
		artsr1 = TRUE
		artsr2 = TRUE
	end

	if c_SwordArtsID == 318 then
		if env(GetSpEffectID, 100054) == TRUE then
			r1 = "W_SwordArtsOneShotComboEnd_MesmerSowrdArts"
			b1 = "W_SwordArtsOneShotComboEnd_MesmerSowrdArts"
		elseif env(GetSpEffectID, 100055) == TRUE then
			r1 = "W_SwordArtsOneShotComboEnd_2"
			b1 = "W_SwordArtsOneShotComboEnd_2"
		end
	end

	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, artsr1, artsr2, TRUE,
		FALSE, ALLBODY) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE then
		local blend_type = ALLBODY
		if c_SwordArtsID ~= 105 and c_SwordArtsID ~= 108 and c_SwordArtsID ~= 169 and MoveStart(LOWER, Event_Move, FALSE)
			== TRUE then
			blend_type = UPPER
		end
		if env(ActionDuration, ACTION_ARM_L2) <= 0 then
			ExecEventHalfBlend(Event_DrawStanceRightEnd, blend_type)
		else
			ExecEventHalfBlend(Event_DrawStanceRightLoop, blend_type)
		end
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function DrawStanceRightAttackLightCancel_onUpdate()
	if GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_LARGE_ARROW)
		== TRUE then
		act(SetIsPreciseShootingPossible)
		if ArrowCommonFunction(ALLBODY, TRUE, TURN_TYPE_DEFAULT) == TRUE then
			return
		end
		if ArrowStanceCommonFunction(ALLBODY, TRUE) == TRUE then
			return
		end
	end

	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"

	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, FALSE, FALSE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE then
		local blend_type = ALLBODY
		if MoveStart(LOWER, Event_Move, FALSE) == TRUE then
			blend_type = UPPER
		end
		if env(ActionDuration, ACTION_ARM_L2) <= 0 then
			ExecEventHalfBlend(Event_DrawStanceRightEnd, blend_type)
		else
			ExecEventHalfBlend(Event_DrawStanceRightLoop, blend_type)
		end
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function DrawStanceHalfRightAttackLight_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if GetEquipType(c_SwordArtsHand, WEAPON_CATEGORY_CROSSBOW) == TRUE and env(ActionDuration, ACTION_ARM_L2) > 0 then
		act(SetIsPreciseShootingPossible)
		if CrossbowStanceCommonFunction(blend_type, TRUE) == TRUE then
			return
		end
	end
	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, FALSE, FALSE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_DrawStanceHalfRightAttackLight, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsStanceAttackLightStart_onUpdate()
	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"
	if env(GetEquipWeaponCategory, HAND_RIGHT) == WEAPON_CATEGORY_STRAIGHT_SWORD then
		r1 = "W_AttackRightLight2"
		r2 = "W_AttackRightHeavy2Start"
		b1 = "W_AttackBothLight2"
		b2 = "W_AttackBothHeavy2Start"
	end
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, FALSE, FALSE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsStanceAttackLight180_onUpdate()
	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackBothRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"

	if env(GetEquipWeaponCategory, HAND_RIGHT) == WEAPON_CATEGORY_STRAIGHT_SWORD then
		r1 = "W_AttackRightLight2"
		r2 = "W_AttackRightHeavy2Start"
		b1 = "W_AttackBothLight2"
		b2 = "W_AttackBothHeavy2Start"
	end
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, FALSE, FALSE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function DrawStanceRightAttackHeavy_onUpdate()
	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"

	if env(GetSpEffectID, 100250) == TRUE then
		r2 = "W_DrawStanceRightAttackHeavy2"
		b2 = "W_DrawStanceRightAttackHeavy2"
	else
		r2 = "W_AttackRightHeavy1Start"
		b2 = "W_AttackBothHeavy1Start"
	end

	if env(GetEquipWeaponCategory, HAND_RIGHT) == WEAPON_CATEGORY_STRAIGHT_SWORD then
		r1 = "W_AttackRightLight2"
		r2 = "W_AttackRightHeavy2Start"
		b1 = "W_AttackBothLight2"
		b2 = "W_AttackBothHeavy2Start"
	end

	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, FALSE, FALSE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function DrawStanceRightAttackHeavy2_onUpdate()
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, FALSE, FALSE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
end

function SwordArtsStanceAttackHeavyStart_onUpdate()
	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"
	if env(GetEquipWeaponCategory, HAND_RIGHT) == WEAPON_CATEGORY_STRAIGHT_SWORD then
		r1 = "W_AttackRightLight2"
		r2 = "W_AttackRightHeavy2Start"
		b1 = "W_AttackBothLight2"
		b2 = "W_AttackBothHeavy2Start"
	end
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, FALSE, FALSE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsStanceAttackHeavy180_onUpdate()
	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"

	if env(GetEquipWeaponCategory, HAND_RIGHT) == WEAPON_CATEGORY_STRAIGHT_SWORD then
		r1 = "W_AttackRightLight2"
		r2 = "W_AttackRightHeavy2Start"
		b1 = "W_AttackBothLight2"
		b2 = "W_AttackBothHeavy2Start"
	end
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, FALSE, FALSE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsOneShot_onUpdate()
	local canThrow = FALSE
	if c_SwordArtsID == 130 or c_SwordArtsID == 55 or c_SwordArtsID == 323 then
		canThrow = TRUE
	end
	if env(GetSpEffectID, 102050) == TRUE then
		act(LockonFixedAngleCancel)
	end
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end
	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end
	if c_SwordArtsID == 157 or c_SwordArtsID == 113 then
		r1 = "W_AttackRightLightStep"
		b1 = "W_AttackBothLightStep"
	end
	if c_SwordArtsID == 1 or c_SwordArtsID == 2 or c_SwordArtsID == 6 or c_SwordArtsID == 7 or c_SwordArtsID == 130
		or c_SwordArtsID == 131 or c_SwordArtsID == 170 or c_SwordArtsID == 171 or c_SwordArtsID == 191 or c_SwordArtsID
		== 198 or c_SwordArtsID == 65 or c_SwordArtsID == 243 or c_SwordArtsID == 283 or c_SwordArtsID == 300
		or c_SwordArtsID == 370 then
		r1 = "W_AttackRightLight2"
		b1 = "W_AttackBothLight2"
	end
	if (c_SwordArtsID == 115 or c_SwordArtsID == 116 or c_SwordArtsID == 193) and env(GetSpEffectID, 100660) == TRUE then
		if env(IsTruelyLanding) == TRUE then
			ExecEventAllBody("W_SwordArtsLoopEnd")
		else
			ExecEventAllBody("W_SwordArtsLoopLoop")
		end
	end
	if c_SwordArtsID == 229 or c_SwordArtsID == 323 then
		if env(IsAnimEnd, 0) == TRUE then
			ExecEventAllBody("W_SwordArtsLoopEnd")
		elseif env(GetSpEffectID, 100670) == TRUE and env(IsTruelyLanding) == TRUE then
			ExecEventAllBody("W_SwordArtsLoopEnd")
		end
	end
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, canThrow,
		ALLBODY) == TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 then
		if env(GetSpEffectID, 100285) == TRUE then
			local idle_cat = env(GetStayAnimCategory)
			local wep_cat = env(GetEquipWeaponCategory, c_SwordArtsHand)
			local arts_cat = GetSwordArtsDiffCategory(c_SwordArtsID, idle_cat, wep_cat)
			local arts_idx = 0

			if arts_cat == WEAPON_CATEGORY_LARGE_SHIELD then
				arts_idx = 1
			elseif arts_cat == WEAPON_CATEGORY_SMALL_SHIELD then
				arts_idx = 2
			elseif arts_cat == WEAPON_CATEGORY_DUELING_SHIELD then
				arts_idx = 3
			elseif arts_cat == SWORD_ART_DIFF_CAT_LARGE_WEAPON then
				arts_idx = 4
			elseif arts_cat == SWORD_ART_DIFF_CAT_POLEARM then
				arts_idx = 5
			end

			SetVariable("SwordArtsChargeCategory", arts_idx)
			ExecEventAllBody("W_SwordArtsChargeCancelEarly")
			return
		elseif env(GetSpEffectID, 100286) == TRUE then
			ExecEventAllBody("W_SwordArtsChargeCancelLate")
			return
		end
	end
	if c_SwordArtsID == 356 then
		act(ReserveArtsPointsUse, ACTION_ARM_L2, c_SwordArtsHand)
		if env(HasEnoughArtsPoints, ACTION_ARM_L2, c_SwordArtsHand) == FALSE and env(GetSpEffectID, 100285) == TRUE then
			ExecEventAllBody("W_SwordArtsChargeCancelEarly")
		end
	end
	if env(IsAnimEnd, 0) == TRUE then
		local arts_category = c_SwordArtsID + 600
		local loop_animID = SWORDARTS_ANIM_ID_RIGHT_LOOP
		if env(DoesAnimExist, arts_category, loop_animID) == TRUE
			and (c_SwordArtsID ~= 201 and c_SwordArtsID ~= 202 or GetVariable("IsEnoughArtPointsL2") == FALSE) then
			if env(ActionDuration, ACTION_ARM_L2) > 0 then
				ExecEventAllBody("W_SwordArtsLoopLoop")
			else
				ExecEventAllBody("W_SwordArtsLoopEnd")
			end
			return
		end
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsOneShot_Sub_onUpdate()
	local canThrow = FALSE
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, canThrow,
		ALLBODY) == TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 and env(GetSpEffectID, 100285) == TRUE then
		if GetVariable("SwordArtsSubCategory") == 0 then
			SetVariable("SwordArtsSubCategory2", 0)
		elseif GetVariable("SwordArtsSubCategory") == 1 then
			SetVariable("SwordArtsSubCategory2", 1)
		end
		ExecEventAllBody("W_SwordArtsChargeCancelEarly_Sub")
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsHalfOneShot_Upper_onUpdate()
	local canThrow = FALSE
	if c_SwordArtsID == 130 or c_SwordArtsID == 55 then
		canThrow = TRUE
	end

	local blend_type, lower_state = GetHalfBlendInfo()
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end
	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end

	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, canThrow,
		blend_type) == TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 then
		if env(GetSpEffectID, 100285) == TRUE then
			if IsHalfBlendArts(c_SwordArtsID) == TRUE then
				ExecEventHalfBlend(Event_SwordArtsHalfChargeCancelEarly, blend_type)
			else
				ExecEventAllBody("W_SwordArtsChargeCancelEarly")
			end
			return
		elseif env(GetSpEffectID, 100286) == TRUE then
			ExecEventAllBody("W_SwordArtsChargeCancelLate")
			return
		end
	end

	if c_SwordArtsID == 206 and env(ActionDuration, ACTION_ARM_L2) <= 0 and env(GetSpEffectID, 100700) == FALSE then
		ExecEventHalfBlend(Event_SwordArtsHalfLoopEnd, blend_type)
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		local arts_category = c_SwordArtsID + 600
		local loop_animID = SWORDARTS_ANIM_ID_RIGHT_LOOP
		if env(DoesAnimExist, arts_category, loop_animID) == TRUE
			and (c_SwordArtsID ~= 201 and c_SwordArtsID ~= 202 or GetVariable("IsEnoughArtPointsL2") == FALSE) then
			if c_SwordArtsID == 334 then
				SetVariable("IsMadTorch", 1)
			else
				SetVariable("IsMadTorch", 0)
			end

			if env(ActionDuration, ACTION_ARM_L2) > 0 then
				if c_SwordArtsID == 334 and GetVariable("IsEnoughArtPointsL2_MadTorchEnd") == TRUE then
					ExecEventHalfBlend(Event_SwordArtsHalfLoopEnd, blend_type)
				else
					ExecEventHalfBlend(Event_SwordArtsHalfLoopLoop, blend_type)
				end
			else
				ExecEventHalfBlend(Event_SwordArtsHalfLoopEnd, blend_type)
			end
			return
		end

		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfOneShot, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsOneShotComboEnd_onUpdate()
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end
	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end
	if c_SwordArtsID == 113 then
		r1 = "W_AttackRightLightStep"
		b1 = "W_AttackBothLightStep"
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 then
		if env(GetSpEffectID, 100285) == TRUE then
			ExecEventAllBody("W_SwordArtsChargeCancelEarly2")
			return
		elseif env(GetSpEffectID, 100286) == TRUE then
			ExecEventAllBody("W_SwordArtsChargeCancelEarly2")
			return
		end
	end
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsOneShotComboEnd_MesmerSowrdArts_onUpdate()
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end
	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end
	if c_SwordArtsID == 113 then
		r1 = "W_AttackRightLightStep"
		b1 = "W_AttackBothLightStep"
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 then
		if env(GetSpEffectID, 100285) == TRUE then
			ExecEventAllBody("W_SwordArtsChargeCancelEarly2")
			return
		elseif env(GetSpEffectID, 100286) == TRUE then
			ExecEventAllBody("W_SwordArtsChargeCancelEarly2")
			return
		end
	end
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsHalfOneShotComboEnd_Upper_onUpdate()
	local canThrow = FALSE
	if c_SwordArtsID == 130 or c_SwordArtsID == 55 then
		canThrow = TRUE
	end

	local blend_type, lower_state = GetHalfBlendInfo()
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end
	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, canThrow,
		blend_type) == TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 then
		if env(GetSpEffectID, 100285) == TRUE then
			ExecEventAllBody("W_SwordArtsChargeCancelEarly2")
			return
		elseif env(GetSpEffectID, 100286) == TRUE then
			ExecEventAllBody("W_SwordArtsChargeCancelEarly2")
			return
		end
	end
	if env(IsAnimEnd, 1) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfOneShotCombo1, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsOneShotComboEnd_2_onUpdate()
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end
	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsHalfOneShotComboEnd_2_Upper_onUpdate()
	local canThrow = FALSE
	if c_SwordArtsID == 130 or c_SwordArtsID == 55 then
		canThrow = TRUE
	end

	local blend_type, lower_state = GetHalfBlendInfo()
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end
	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end
	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, canThrow,
		blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfOneShotCombo2, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsOneShotShieldLeft_onUpdate()
	local index = SWORDARTS_PARRY + GetVariable("SwordArtsOneShotShieldIndex")
	local canThrow = FALSE

	if index == SWORDARTS_PARRY or index == SWORDARTS_SPELL_PARRY or index == SWORDARTS_PROJECTILE_PARRY or index
		== SWORDARTS_BUCKLER_PARRY or index == SWORDARTS_DAGGER_PARRY then
		canThrow = TRUE
	end

	if env(ActionDuration, ACTION_ARM_L2) <= 0 then
		local idle_cat = env(GetStayAnimCategory)
		local wep_cat = env(GetEquipWeaponCategory, c_SwordArtsHand)
		local arts_cat = GetSwordArtsDiffCategory(c_SwordArtsID, idle_cat, wep_cat)
		local arts_idx = 0

		if arts_cat == WEAPON_CATEGORY_LARGE_SHIELD then
			arts_idx = 1
		elseif arts_cat == WEAPON_CATEGORY_SMALL_SHIELD then
			arts_idx = 2
		end

		SetVariable("SwordArtsOneShotShieldCancelCategory", arts_idx)

		if env(GetSpEffectID, 100285) == TRUE then
			ExecEventAllBody("W_SwordArtsOneShotShieldLeft_Cancel")
		elseif env(GetSpEffectID, 100286) == TRUE then
			ExecEventAllBody("W_SwordArtsOneShotShieldLeft_Cancel")
		end
	end
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, canThrow, ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		local arts_category = c_SwordArtsID + 600
		local loop_animID = SWORDARTS_ANIM_ID_RIGHT_LOOP
		if env(DoesAnimExist, arts_category, loop_animID) == TRUE
			and (c_SwordArtsID ~= 201 and c_SwordArtsID ~= 202 or GetVariable("IsEnoughArtPointsL2") == FALSE) then
			if env(ActionDuration, ACTION_ARM_L2) > 0 then
				ExecEventAllBody("W_SwordArtsLeftLoopLoop")
			else
				ExecEventAllBody("W_SwordArtsLeftLoopEnd")
			end
			return
		end
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsLeftGuardCounter_onUpdate()
	local canThrow = FALSE
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, canThrow, ALLBODY) == TRUE then
		return
	end

	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsBothGuardCounter_onUpdate()
	local canThrow = FALSE
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, canThrow, ALLBODY) == TRUE then
		return
	end

	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsHalfOneShotShieldLeft_Upper_onUpdate()
	local index = SWORDARTS_PARRY + GetVariable("SwordArtsOneShotShieldIndex")
	local canThrow = FALSE
	if index == SWORDARTS_PARRY or index == SWORDARTS_SPELL_PARRY or index == SWORDARTS_PROJECTILE_PARRY or index
		== SWORDARTS_BUCKLER_PARRY or index == SWORDARTS_DAGGER_PARRY then
		canThrow = TRUE
	end
	local blend_type, lower_state = GetHalfBlendInfo()
	local idle_cat = env(GetStayAnimCategory)
	local wep_cat = env(GetEquipWeaponCategory, c_SwordArtsHand)
	local arts_cat = GetSwordArtsDiffCategory(c_SwordArtsID, idle_cat, wep_cat)
	local arts_idx = 0

	if arts_cat == WEAPON_CATEGORY_LARGE_SHIELD then
		arts_idx = 1
	elseif arts_cat == WEAPON_CATEGORY_SMALL_SHIELD then
		arts_idx = 2
	end

	SetVariable("SwordArtsOneShotShieldCancelCategory", arts_idx)

	if 0 >= env(ActionDuration, ACTION_ARM_L2) then
		if env(GetSpEffectID, 100285) == TRUE then
			ExecEventAllBody("W_SwordArtsOneShotShieldLeft_Cancel")
		elseif env(GetSpEffectID, 100286) == TRUE then
			ExecEventAllBody("W_SwordArtsOneShotShieldLeft_Cancel")
		end
	end
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, FALSE, canThrow, ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		local arts_category = c_SwordArtsID + 600
		local loop_animID = SWORDARTS_ANIM_ID_RIGHT_LOOP
		if env(DoesAnimExist, arts_category, loop_animID) == TRUE
			and (c_SwordArtsID ~= 201 and c_SwordArtsID ~= 202 or GetVariable("IsEnoughArtPointsL2") == FALSE) then
			if 0 < env(ActionDuration, ACTION_ARM_L2) then
				if c_SwordArtsID == 334 then
					SetVariable("IsMadTorch", 1)
				else
					SetVariable("IsMadTorch", 0)
				end
				if c_SwordArtsID == 334 and GetVariable("IsEnoughArtPointsL2") == TRUE then
					ExecEventHalfBlend(Event_SwordArtsHalfLeftLoopEnd, blend_type)
				else
					ExecEventHalfBlend(Event_SwordArtsHalfLeftLoopLoop, blend_type)
				end
			else
				ExecEventHalfBlend(Event_SwordArtsHalfLeftLoopEnd, blend_type)
			end
			return
		end
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfOneShotShieldLeft, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsOneShotShieldLeft_Cancel_onUpdate()
	local index = SWORDARTS_PARRY + GetVariable("SwordArtsOneShotShieldIndex")
	local canThrow = FALSE
	if index == SWORDARTS_PARRY or index == SWORDARTS_SPELL_PARRY or index == SWORDARTS_PROJECTILE_PARRY or index
		== SWORDARTS_BUCKLER_PARRY or index == SWORDARTS_DAGGER_PARRY then
		canThrow = TRUE
	end
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, FALSE, canThrow, ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsOneShotShieldBoth_onUpdate()
	local index = SWORDARTS_PARRY + GetVariable("SwordArtsOneShotShieldIndex")
	local canThrow = FALSE
	if index == SWORDARTS_PARRY or index == SWORDARTS_SPELL_PARRY or index == SWORDARTS_PROJECTILE_PARRY or index
		== SWORDARTS_BUCKLER_PARRY or index == SWORDARTS_DAGGER_PARRY then
		canThrow = TRUE
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 then
		local idle_cat = env(GetStayAnimCategory)
		local wep_cat = env(GetEquipWeaponCategory, c_SwordArtsHand)
		local arts_cat = GetSwordArtsDiffCategory(c_SwordArtsID, idle_cat, wep_cat)
		local arts_idx = 0

		if arts_cat == 47 then
			arts_idx = 1
		elseif arts_cat == 48 then
			arts_idx = 2
		elseif arts_cat == 57 then
			arts_idx = 3
		end
		SetVariable("SwordArtsOneShotShieldCancelCategory", arts_idx)
		if env(GetSpEffectID, 100285) == TRUE then
			ExecEventAllBody("W_SwordArtsOneShotShieldBoth_Cancel")
		elseif env(GetSpEffectID, 100286) == TRUE then
			ExecEventAllBody("W_SwordArtsOneShotShieldBoth_Cancel")
		end
	end
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, canThrow, ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		local arts_category = c_SwordArtsID + 600
		local loop_animID = SWORDARTS_ANIM_ID_RIGHT_LOOP
		if env(DoesAnimExist, arts_category, loop_animID) == TRUE
			and (c_SwordArtsID ~= 201 and c_SwordArtsID ~= 202 or GetVariable("IsEnoughArtPointsL2") == FALSE) then
			if env(ActionDuration, ACTION_ARM_L2) > 0 then
				ExecEventAllBody("W_SwordArtsBothLoopLoop")
			else
				ExecEventAllBody("W_SwordArtsBothLoopEnd")
			end
			return
		end
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsOneShotShieldBoth_Cancel_onUpdate()
	local index = SWORDARTS_PARRY + GetVariable("SwordArtsOneShotShieldIndex")
	local canThrow = FALSE
	if index == SWORDARTS_PARRY or index == SWORDARTS_SPELL_PARRY or index == SWORDARTS_PROJECTILE_PARRY or index
		== SWORDARTS_BUCKLER_PARRY or index == SWORDARTS_DAGGER_PARRY then
		canThrow = TRUE
	end
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, FALSE, canThrow, ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsHalfOneShotShieldBoth_Upper_onUpdate()
	local index = SWORDARTS_PARRY + GetVariable("SwordArtsOneShotShieldIndex")
	local canThrow = FALSE
	if index == SWORDARTS_PARRY or index == SWORDARTS_SPELL_PARRY or index == SWORDARTS_PROJECTILE_PARRY or index
		== SWORDARTS_BUCKLER_PARRY or index == SWORDARTS_DAGGER_PARRY then
		canThrow = TRUE
	end
	local blend_type, lower_state = GetHalfBlendInfo()
	local idle_cat = env(GetStayAnimCategory)
	local wep_cat = env(GetEquipWeaponCategory, c_SwordArtsHand)
	local arts_cat = GetSwordArtsDiffCategory(c_SwordArtsID, idle_cat, wep_cat)

	local arts_idx = 0
	if arts_cat == 47 then
		arts_idx = 1
	elseif arts_cat == 48 then
		arts_idx = 2
	end
	SetVariable("SwordArtsOneShotShieldCancelCategory", arts_idx)
	if 0 >= env(ActionDuration, ACTION_ARM_L2) then
		if env(GetSpEffectID, 100285) == TRUE then
			ExecEventAllBody("W_SwordArtsOneShotShieldBoth_Cancel")
		elseif env(GetSpEffectID, 100286) == TRUE then
			ExecEventAllBody("W_SwordArtsOneShotShieldBoth_Cancel")
		end
	end
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, FALSE, canThrow, ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		local arts_category = c_SwordArtsID + 600
		local loop_animID = SWORDARTS_ANIM_ID_RIGHT_LOOP
		if env(DoesAnimExist, arts_category, loop_animID) == TRUE
			and (c_SwordArtsID ~= 201 and c_SwordArtsID ~= 202 or GetVariable("IsEnoughArtPointsL2") == FALSE) then
			if 0 < env(ActionDuration, ACTION_ARM_L2) then
				if c_SwordArtsID == 334 then
					SetVariable("IsMadTorch", 1)
				else
					SetVariable("IsMadTorch", 0)
				end
				if c_SwordArtsID == 334 and GetVariable("IsEnoughArtPointsL2") == TRUE then
					ExecEventHalfBlend(Event_SwordArtsHalfBothLoopEnd, blend_type)
				else
					ExecEventHalfBlend(Event_SwordArtsHalfBothLoopLoop, blend_type)
				end
			else
				ExecEventHalfBlend(Event_SwordArtsHalfBothLoopEnd, blend_type)
			end
			return
		end
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfOneShotShieldBoth, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsRolling_onUpdate()
	SetEnableAimMode()
	local r1 = "W_AttackRightLightStep"
	local b1 = "W_AttackBothLightStep"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"
	if GetVariable("SwordArtsRollingDirection") ~= 0 then
		r1 = "W_AttackRightBackstep"
		b1 = "W_AttackBothBackstep"
	end

	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end

	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2,
		QUICKTYPE_ROLLING) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsRolling_SelfTrans_onUpdate()
	SetEnableAimMode()
	local r1 = "W_AttackRightLightStep"
	local b1 = "W_AttackBothLightStep"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if GetVariable("SwordArtsRollingDirection") ~= 0 then
		r1 = "W_AttackRightBackstep"
		b1 = "W_AttackBothBackstep"
	end

	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end

	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2,
		QUICKTYPE_ROLLING) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsRolling_SelfTrans2_onUpdate()
	SetEnableAimMode()
	local r1 = "W_AttackRightLightStep"
	local b1 = "W_AttackBothLightStep"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if GetVariable("SwordArtsRollingDirection") ~= 0 then
		r1 = "W_AttackRightBackstep"
		b1 = "W_AttackBothBackstep"
	end

	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end

	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2,
		QUICKTYPE_ROLLING) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsRolling_Sub_onUpdate()
	local rollingAngle = c_ArtsRollingAngle
	rollingAngle = GetVariable("MoveAngle")
	local turn_target_angle = 0
	local rollingDirection = 0

	if c_SwordArtsID == 276 then
		if rollingAngle <= 0 and rollingAngle >= -180 then
			rollingDirection = 2
			turn_target_angle = rollingAngle + 90
		elseif rollingAngle > 0 and rollingAngle < 180 then
			rollingDirection = 3
			turn_target_angle = rollingAngle - 90
		else
			rollingDirection = 2
			turn_target_angle = rollingAngle + 90
		end
	end

	if c_SwordArtsID == 313 then
		if rollingAngle <= 0 and rollingAngle >= -120 then
			rollingDirection = 2
			turn_target_angle = rollingAngle + 90
		elseif rollingAngle > 0 and rollingAngle < 120 then
			rollingDirection = 3
			turn_target_angle = rollingAngle - 90
		else
			rollingDirection = 1
			turn_target_angle = rollingAngle - 180
		end
	end

	SetVariable("SwordArtsRollingDirection", rollingDirection)
	SetVariable("RollingAngleReal", rollingAngle)

	if AttackCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy2Start", FALSE, TRUE, 0) == TRUE then
		return
	end

	if env(GetEventEzStateFlag, 0) == TRUE or env(IsAnimEnd, 1) == TRUE then
		act(SetSpecialInterpolation, 0, TRUE)
		ExecEventAllBody("W_SwordArtsRolling")
		return
	end
end

function SwordArtsLoopLoop_onUpdate()
	if c_SwordArtsID == 115 or c_SwordArtsID == 116 or c_SwordArtsID == 193 then
		local height = env(GetFallHeight) / 100
		local damage_type = env(GetReceivedDamageType)
		if damage_type == DAMAGE_TYPE_DEATH_FALLING then
			ExecEventAllBody("W_FallDeath")
			return TRUE
		end
		if not (height >= 60) or env(GetStateChangeType, 266) == TRUE then
		else
			ExecEventAllBody("W_FallDeath")
			return TRUE
		end
		if env(GetSpEffectID, 100670) == TRUE and env(IsTruelyLanding) == TRUE then
			ExecEventAllBody("W_SwordArtsLoopEnd")
		end
	elseif c_SwordArtsID == 13 then
		SetSwordArtsPointInfo(ACTION_ARM_R2, TRUE)
		if env(ActionDuration, ACTION_ARM_L2) <= 0 or env(GetStamina) <= 0
			or env(HasEnoughArtsPoints, ACTION_ARM_R2, c_SwordArtsHand) == FALSE then
			ExecEventAllBody("W_SwordArtsLoopEnd")
			return
		end
	elseif env(ActionDuration, ACTION_ARM_L2) <= 0 or env(GetStamina) <= 0 or GetVariable("IsEnoughArtPointsL2") == 0
		and env(HasEnoughArtsPoints, ACTION_ARM_L2, c_SwordArtsHand) == FALSE then
		ExecEventAllBody("W_SwordArtsLoopEnd")
		return
	end
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, FALSE, ALLBODY) == TRUE then
		return
	end
end

function SwordArtsHalfLoopLoop_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if c_SwordArtsID == 334 then
		SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)
	end
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, canThrow, blend_type) == TRUE then
		return
	end
	if c_SwordArtsID == 334 then
		SetVariable("IsMadTorch", 1)
		if env(GetSpEffectID, 100700) == FALSE
			and (env(ActionDuration, ACTION_ARM_L2) <= 0 or env(GetStamina) <= 0 or GetVariable("IsEnoughArtPointsL2")
				== 1 and env(HasEnoughArtsPoints, ACTION_ARM_L2, c_SwordArtsHand) == FALSE) then
			ExecEventHalfBlend(Event_SwordArtsHalfLoopEnd, blend_type)
			return
		end
	else
		SetVariable("IsMadTorch", 0)
		if env(GetSpEffectID, 100700) == FALSE
			and (env(ActionDuration, ACTION_ARM_L2) <= 0 or env(GetStamina) <= 0 or GetVariable("IsEnoughArtPointsL2")
				== 0 and env(HasEnoughArtsPoints, ACTION_ARM_L2, c_SwordArtsHand) == FALSE) then
			ExecEventHalfBlend(Event_SwordArtsHalfLoopEnd, blend_type)
			return
		end
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfLoopLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsLoopEnd_onUpdate()
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, FALSE, ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsHalfLoopEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, canThrow, blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfLoopEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsBothLoopLoop_onUpdate()
	if env(ActionDuration, ACTION_ARM_L2) <= 0 then
		ExecEventAllBody("W_SwordArtsBothLoopEnd")
		return
	end
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, FALSE, canThrow, ALLBODY) == TRUE then
		return
	end
end

function SwordArtsBothLoopEnd_onUpdate()
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, FALSE, ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsHalfBothLoopLoop_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, FALSE, canThrow, ALLBODY) == TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 or env(ActionCancelRequest, ACTION_ARM_L2) == TRUE or env(GetStamina) <= 0
		or GetVariable("IsEnoughArtPointsL2") == 1 then
		if c_SwordArtsID == 334 then
			SetVariable("IsMadTorch", 1)
		else
			SetVariable("IsMadTorch", 0)
		end
		ExecEventHalfBlend(Event_SwordArtsHalfBothLoopEnd, blend_type)
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfBothLoopLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsHalfBothLoopEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, canThrow, blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfBothLoopEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsHalfLeftLoopLoop_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, FALSE, canThrow, ALLBODY) == TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 or env(ActionCancelRequest, ACTION_ARM_L2) == TRUE or env(GetStamina) <= 0
		or GetVariable("IsEnoughArtPointsL2") == 1 then
		if c_SwordArtsID == 334 then
			SetVariable("IsMadTorch", 1)
		else
			SetVariable("IsMadTorch", 0)
		end
		ExecEventHalfBlend(Event_SwordArtsHalfLeftLoopEnd, blend_type)
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfLeftLoopLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsHalfLeftLoopEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, canThrow, blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfLeftLoopEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsLeftLoopLoop_onUpdate()
	if env(ActionDuration, ACTION_ARM_L2) <= 0 then
		ExecEventAllBody("W_SwordArtsLeftLoopEnd")
		return
	end
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, FALSE, canThrow, ALLBODY) == TRUE then
		return
	end
end

function SwordArtsHalfLeftLoopLoop_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	SetSwordArtsPointInfo(ACTION_ARM_L2, TRUE)
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, FALSE, canThrow, ALLBODY) == TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 or env(ActionCancelRequest, ACTION_ARM_L2) == TRUE or env(GetStamina) <= 0
		or GetVariable("IsEnoughArtPointsL2") == 1 then
		ExecEventHalfBlend(Event_SwordArtsHalfLeftLoopEnd, blend_type)
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfLeftLoopLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsLeftLoopEnd_onUpdate()
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, FALSE, FALSE, ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsHalfLeftLoopEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ArtsCommonFunction("W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1", "W_AttackLeftHeavy1",
		"W_AttackBothLight1", "W_AttackBothHeavy1Start", FALSE, TRUE, TRUE, TRUE, canThrow, blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfLeftLoopEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsChargeCancelEarly_onUpdate()
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end

	if env(GetSpEffectID, 102050) == TRUE then
		act(LockonFixedAngleCancel)
	end

	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if c_SwordArtsID == 198 or c_SwordArtsID == 283 or c_SwordArtsID == 300 or c_SwordArtsID == 370 then
		r1 = "W_AttackRightLight2"
		b1 = "W_AttackBothLight2"
	end

	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end

	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end

	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsChargeCancelLate_onUpdate()
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"
	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end
	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end

	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
end

function SwordArtsChargeCancelEarly2_onUpdate()
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"
	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end
	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end

	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
end

function SwordArtsChargeCancelEarly_Sub_onUpdate()
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"

	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
end

function SwordArtsHalfChargeCancelEarly_Upper_onUpdate()
	local r1 = "W_AttackRightLight1"
	local b1 = "W_AttackBothLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b2 = "W_AttackBothHeavy1Start"
	local blend_type, lower_state = GetHalfBlendInfo()
	if env(GetSpEffectID, 100054) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd"
		b1 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100055) == TRUE then
		r1 = "W_SwordArtsOneShotComboEnd_2"
		b1 = "W_SwordArtsOneShotComboEnd_2"
	end
	if env(GetSpEffectID, 100050) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd"
		b2 = "W_SwordArtsOneShotComboEnd"
	elseif env(GetSpEffectID, 100051) == TRUE then
		r2 = "W_SwordArtsOneShotComboEnd_2"
		b2 = "W_SwordArtsOneShotComboEnd_2"
	end

	if ArtsCommonFunction(r1, r2, "W_AttackLeftLight1", "W_AttackLeftHeavy1", b1, b2, FALSE, TRUE, TRUE, TRUE, FALSE,
		ALLBODY) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		SetArtsGeneratorTransitionIndex()
		ExecEventAllBody("W_Idle")
		return
	end
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsHalfChargeCancelEarly, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsStandDodge_onUpdate()
	if ExecDamage(FALSE, FALSE) == TRUE then
		return TRUE
	end
	if ExecFallAttack() == TRUE then
		return
	end
	if env(IsFalling) == TRUE or env(IsAnimEnd, 0) == TRUE then
		ExecEventAllBody("W_FallLoop")
		return
	end
end

function SwordArtsLeft_Activate()
	SetAttackHand(HAND_LEFT)
	SetGuardHand(HAND_LEFT)
end

function SwordArtsArrowStanceStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	act(SetIsPreciseShootingPossible)
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if ArrowStanceCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE
		and (env(ActionDuration, ACTION_ARM_L2) <= 0 or env(ActionCancelRequest, ACTION_ARM_L2) == TRUE) then
		ExecEventHalfBlend(Event_SwordArtsArrowStanceEnd, blend_type)
		if lower_state == LOWER_MOVE then
			ExecEventHalfBlendNoReset(Event_Move, LOWER)
		end
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlend(Event_SwordArtsArrowStanceLoop, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsArrowStanceStartMirror, lower_state, FALSE) == TRUE then
		return
	end
end

function SetSwordArtsWepCategory_DrawStanceRightAttackLight()
	local idle_cat = env(GetStayAnimCategory)
	local wep_cat = env(GetEquipWeaponCategory, c_SwordArtsHand)
	local arts_cat = GetSwordArtsDiffCategory(c_SwordArtsID, idle_cat, wep_cat)
	local arts_idx = 0

	if arts_cat == WEAPON_CATEGORY_LARGE_ARROW then
		arts_idx = 1
	end
	SetVariable("DrawStanceRightAttackLightCategory", arts_idx)
end

function ArrowStanceCommonFunction(blend_type, checkHold)
	local request = GetAttackRequest(FALSE)
	local arrowHand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		arrowHand = HAND_LEFT
	end
	if (request == ATTACK_REQUEST_ARROW_FIRE_LEFT or request == ATTACK_REQUEST_ARROW_FIRE_RIGHT)
		and (checkHold == FALSE or env(ActionDuration, ACTION_ARM_L2) > 0) then
		g_ArrowSlot = 0
		act(ChooseBowAndArrowSlot, 0)
		if env(IsOutOfAmmo, arrowHand) == TRUE then
			ExecEventAllBody("W_NoArrow")
			return TRUE
		end
		if env(GetStamina) > 0 then
			SetSwordArtsPointInfo(ACTION_ARM_R1, TRUE)
			SetSwordArtsWepCategory_DrawStanceRightAttackLight()
			ExecEventAllBody("W_DrawStanceRightAttackLight")
			return TRUE
		end
	elseif (request == ATTACK_REQUEST_ARROW_FIRE_LEFT2 or request == ATTACK_REQUEST_ARROW_FIRE_RIGHT2)
		and (checkHold == FALSE or env(ActionDuration, ACTION_ARM_L2) > 0) then
		act(ResetInputQueue)
		g_ArrowSlot = 1
		act(ChooseBowAndArrowSlot, 1)
		if env(IsOutOfAmmo, arrowHand) == TRUE then
			ExecEventAllBody("W_NoArrow")
			return TRUE
		end
		if env(GetStamina) > 0 then
			SetSwordArtsPointInfo(ACTION_ARM_R1, TRUE)
			SetSwordArtsWepCategory_DrawStanceRightAttackLight()
			ExecEventAllBody("W_DrawStanceRightAttackLight")
			return TRUE
		end
	end
	return FALSE
end

function CrossbowStanceCommonFunction(blend_type, IsShooting)
	local request = GetAttackRequest(FALSE)
	local arrowHand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		arrowHand = HAND_LEFT
	end
	if IsShooting == TRUE then
		if env(ActionDuration, ACTION_ARM_L2) > 0
			and (request == ATTACK_REQUEST_RIGHT_CROSSBOW or request == ATTACK_REQUEST_LEFT_CROSSBOW or request
				== ATTACK_REQUEST_BOTHRIGHT_CROSSBOW or request == ATTACK_REQUEST_BOTHLEFT_CROSSBOW or request
				== ATTACK_REQUEST_RIGHT_CROSSBOW2 or request == ATTACK_REQUEST_LEFT_CROSSBOW2 or request
				== ATTACK_REQUEST_BOTHRIGHT_CROSSBOW2 or request == ATTACK_REQUEST_BOTHLEFT_CROSSBOW2) then
			ExecEventHalfBlend(Event_DrawStanceRightStart, blend_type)
			return TRUE
		end
	elseif (request == ATTACK_REQUEST_RIGHT_CROSSBOW or request == ATTACK_REQUEST_LEFT_CROSSBOW or request
		== ATTACK_REQUEST_BOTHRIGHT_CROSSBOW or request == ATTACK_REQUEST_BOTHLEFT_CROSSBOW)
		and env(ActionDuration, ACTION_ARM_L2) > 0 then
		g_ArrowSlot = 0
		act(ChooseBowAndArrowSlot, 0)
		if env(IsOutOfAmmo, arrowHand) == TRUE then
			ExecEventHalfBlend(Event_AttackCrossbowRightEmpty, blend_type)
			return TRUE
		end
		if env(GetStamina) > 0 then
			SetSwordArtsPointInfo(ACTION_ARM_R1, TRUE)
			SetSwordArtsWepCategory_DrawStanceRightAttackLight()
			if IsHalfBlendArts(c_SwordArtsID) == TRUE then
				local blend_type, lower_state = GetHalfBlendInfo()
				ExecEventHalfBlend(Event_DrawStanceHalfRightAttackLight, blend_type)
			else
				ExecEventAllBody("W_DrawStanceRightAttackLight")
			end
			return TRUE
		end
	elseif (request == ATTACK_REQUEST_RIGHT_CROSSBOW2 or request == ATTACK_REQUEST_LEFT_CROSSBOW2 or request
		== ATTACK_REQUEST_BOTHRIGHT_CROSSBOW2 or request == ATTACK_REQUEST_BOTHLEFT_CROSSBOW2)
		and env(ActionDuration, ACTION_ARM_L2) > 0 then
		act(ResetInputQueue)
		g_ArrowSlot = 1
		act(ChooseBowAndArrowSlot, 1)

		if env(IsOutOfAmmo, arrowHand) == TRUE then
			ExecEventHalfBlend(Event_AttackCrossbowRightEmpty, blend_type)
			return TRUE
		end
		if env(GetStamina) > 0 then
			SetSwordArtsPointInfo(ACTION_ARM_R1, TRUE)
			SetSwordArtsWepCategory_DrawStanceRightAttackLight()

			if IsHalfBlendArts(c_SwordArtsID) == TRUE then
				local blend_type, lower_state = GetHalfBlendInfo()
				ExecEventHalfBlend(Event_DrawStanceHalfRightAttackLight, blend_type)
			else
				ExecEventAllBody("W_DrawStanceRightAttackLight")
			end
			return TRUE
		end
	end
	return FALSE
end

function SwordArtsArrowStanceLoop_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if ArrowStanceCommonFunction(blend_type, FALSE) == TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0 or env(ActionCancelRequest, ACTION_ARM_L2) == TRUE then
		ExecEventHalfBlend(Event_SwordArtsArrowStanceEnd, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsArrowStanceLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsArrowDrawStart_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlend(Event_SwordArtsArrowDrawLoop, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsArrowStanceStartMirror, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsArrowDrawLoop_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if g_ArrowSlot == 0 and 0 >= env(ActionDuration, ACTION_ARM_R1) or g_ArrowSlot == 1 and 0
		>= env(ActionDuration, ACTION_ARM_R2) then
		SetSwordArtsPointInfo(ACTION_ARM_R1, TRUE)
		ExecEventAllBody("W_SwordArtsArrowFire")
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsArrowStanceLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function SwordArtsArrowFire_onUpdate()
	act(SetIsPreciseShootingPossible)
	if ArrowCommonFunction(ALLBODY, TRUE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if env(GetSpEffectID, 100280) == TRUE
		and (g_ArrowSlot == 0 and env(ActionDuration, ACTION_ARM_R1) <= 0 or g_ArrowSlot == 1
			and env(ActionDuration, ACTION_ARM_R2) <= 0) then
		ExecEventAllBody("W_SwordArtsArrowFireEnd")
		return
	end
	if ArrowStanceCommonFunction(ALLBODY, TRUE) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE or env(IsAnimEnd, 0) == TRUE then
		if env(ActionDuration, ACTION_ARM_L2) > 0 then
			ExecEventHalfBlendNoReset(Event_SwordArtsArrowStanceLoop, ALLBODY)
			return
		else
			ExecEventHalfBlend(Event_SwordArtsArrowStanceEnd, ALLBODY)
			return
		end
	end
end

function SwordArtsArrowFireEnd_onUpdate()
	act(SetIsPreciseShootingPossible)
	if ArrowCommonFunction(ALLBODY, TRUE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if ArrowStanceCommonFunction(ALLBODY, TRUE) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE or env(IsAnimEnd, 0) == TRUE then
		if env(ActionDuration, ACTION_ARM_L2) > 0 then
			ExecEventHalfBlendNoReset(Event_SwordArtsArrowStanceLoop, ALLBODY)
			return
		else
			ExecEventHalfBlend(Event_SwordArtsArrowStanceEnd, ALLBODY)
			return
		end
	end
end

function SwordArtsArrowStanceEnd_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_DEFAULT)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_DEFAULT) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_SwordArtsArrowStanceEnd, lower_state, TRUE) == TRUE then
		return
	end
end

function WeaponChangeStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if WeaponChangeCommonFunction(blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlendNoReset(Event_WeaponChangeEnd, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_WeaponChangeStartMirror, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthWeaponChangeStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if WeaponChangeCommonFunction(blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlendNoReset(Event_StealthWeaponChangeEnd, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthWeaponChangeStart, lower_state, FALSE) == TRUE then
		return
	end
end

function WeaponChangeEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if WeaponChangeCommonFunction(blend_type) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_WeaponChangeEndMirror, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthWeaponChangeEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if WeaponChangeCommonFunction(blend_type) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Stealth_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthWeaponChangeEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function HandChangeStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if HandChangeCommonFunction(blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlendNoReset(Event_HandChangeEnd, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_HandChangeStartMirror, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthHandChangeStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if HandChangeCommonFunction(blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlendNoReset(Event_StealthHandChangeEnd, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthHandChangeStart, lower_state, FALSE) == TRUE then
		return
	end
end

function HandChangeEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if HandChangeCommonFunction(blend_type) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_HandChangeEndMirror, lower_state, FALSE) == TRUE then
		return
	end
end

function HandChangeEnd_Upper_onDeactivate()
	HandChangeTest_ToR1 = FALSE
	HandChangeTest_ToR2 = FALSE
	HandChangeTest_ToL1 = FALSE
	HandChangeTest_ToL2 = FALSE
end

function StealthHandChangeEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if HandChangeCommonFunction(blend_type) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Stealth_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthHandChangeEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthHandChangeEnd_Upper_onDeactivate()
	HandChangeTest_ToR1 = FALSE
	HandChangeTest_ToR2 = FALSE
	HandChangeTest_ToL1 = FALSE
	HandChangeTest_ToL2 = FALSE
end

function Item_Upper_Activate()
	ActivateRightArmAdd(START_FRAME_NONE)
end

function Item_Upper_Update()
	UpdateRightArmAdd()
end

function QuickItemEnchantNormal_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, blend_type, QUICKTYPE_NORMAL) == TRUE then
		return
	end
	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		ClearAttackQueue()
		return
	end
	if HalfBlendLowerCommonFunction(Event_QuickItemEnchantNormal, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function QuickItemEnchantDash_Upper_onActivate()
	act(LockonFixedAngleCancel)
end

function QuickItemEnchantDash_Upper_onUpdate()
	act(LockonFixedAngleCancel)
	local r1 = "W_AttackRightLight1"
	local r2 = "W_AttackRightHeavy1Start"
	local b1 = "W_AttackBothLight1"
	local b2 = "W_AttackBothHeavy1Start"
	if GetVariable("MoveSpeedIndex") >= 1 then
		r1 = "W_AttackRightLightDash"
		r2 = "W_AttackRightHeavyDash"
		b1 = "W_AttackBothDash"
		b2 = "W_AttackBothHeavyDash"
	end
	local blend_type, lower_state = GetHalfBlendInfo()
	if QuickItemCommonFunction(r1, r2, g_l1, g_l2, b1, b2, blend_type, QUICKTYPE_NORMAL) == TRUE then
		return
	end
	if env(GetSpEffectID, 100220) == FALSE
		and HalfBlendLowerCommonFunction(Event_StopHalfBlendDashStop, lower_state, FALSE) == TRUE then
		SetVariable("MoveSpeedLevelReal", 0)
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		ExecEvent("W_Idle")
		return
	end
end

function QuickItemEnchantStep_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	
	if QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, blend_type, QUICKTYPE_NORMAL) == TRUE then
		return
	end

	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		ClearAttackQueue()
		return
	end
	
	if HalfBlendLowerCommonFunction(Event_QuickItemEnchantStep, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function QuickItemEnchantAttackRight_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, blend_type, QUICKTYPE_NORMAL) == TRUE then
		return
	end

	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end

	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		ClearAttackQueue()
		return
	end

	if HalfBlendLowerCommonFunction(Event_QuickItemEnchantAttackRight, lower_state, FALSE, TRUE) == TRUE then
		return
	end 
end

function QuickItemEnchantAttackLeft_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()

	if QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, blend_type, QUICKTYPE_NORMAL) == TRUE then
		return
	end

	if blend_type ~= UPPER and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end

	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		ClearAttackQueue()
		return
	end

	if HalfBlendLowerCommonFunction(Event_QuickItemEnchantAttackLeft, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function QuickItemThrowKnifeNormal_Upper_onUpdate()
	if QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, ALLBODY, QUICKTYPE_COMBO) == TRUE then
		return
	end
end

function QuickItemThrowKnifeDash_Upper_onUpdate()
	if QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, ALLBODY, QUICKTYPE_COMBO) == TRUE then
		return
	end
end

function QuickItemThrowKnifeStep_Upper_onUpdate()
	if QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, ALLBODY, QUICKTYPE_COMBO) == TRUE then
		return
	end
end

function QuickItemThrowKnifeAttackRight_Upper_onUpdate()
	if QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, ALLBODY, QUICKTYPE_COMBO) == TRUE then
		return
	end
end

function QuickItemThrowKnifeAttackRight2_Upper_onUpdate()
	if QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, ALLBODY, QUICKTYPE_ATTACK) == TRUE then
		return
	end
end

function QuickItemThrowKnifeAttackLeft_Upper_onUpdate()
	if QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, ALLBODY, QUICKTYPE_COMBO) == TRUE then
		return
	end
end

function QuickItemThrowKnifeAttackLeft2_Upper_onUpdate()
	if QuickItemCommonFunction(g_r1, g_r2, g_l1, g_l2, g_b1, g_b2, ALLBODY, QUICKTYPE_ATTACK) == TRUE then
		return
	end
end

function ItemRecover_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemRecover, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemEatJerky_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemRecover, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemLanternOn_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemRecover, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemLanternOff_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemRecover, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemElixir_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemRecover, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemHorn_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemRecover, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemWeaponEnchant_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemWeaponEnchant, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemThrowKnife_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemThrowKnife, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemThrowBottle_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemThrowBottle, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemMeganeStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		act(RemoveBinoculars)
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlend(Event_ItemMeganeLoop, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemMeganeStart, lower_state, FALSE, TRUE) == TRUE then
		act(RemoveBinoculars)
		return
	end
end

function ItemMeganeLoop_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		act(RemoveBinoculars)
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemMeganeLoop, lower_state, FALSE) == TRUE then
		act(RemoveBinoculars)
		return
	end
end

function ItemMeganeEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemMeganeEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemWeaponRepair_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemWeaponRepair, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemSoul_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemSoul, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemMessage_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemMessage, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemPray_Upper_onUpdate()
	act(SetAllowedThrowDefenseType, 255)
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if GetVariable("RideOnSummonTest") == 1 then
		if env(IsMovingOnMount) == TRUE then
			FireRideEvent("W_RideOn", "W_RideOn", FALSE)
			return TRUE
		elseif env(IsIdleOnMount) == TRUE then
			ExecEventAllBody("W_Idle")
			return TRUE
		end
	elseif env(IsSummoningRide) == TRUE then
		if env(IsNewRidingTest) == TRUE then
			SetVariable("RideOnSummonTest", 1)
			FireRideEvent("W_RideOn", "W_RideOn", FALSE)
		else
			SetVariable("RideOnSummonTest", 0)
			ExecEventAllBody("W_RideAdjustFromCalling")
		end
		return TRUE
	elseif env(GetEventEzStateFlag, 0) == TRUE then
		act(Mounting)
		return TRUE
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemPray, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemTrap_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemTrap, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemDrinkStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	local isEnd = env(IsAnimEnd, 1)
	if env(GetEventEzStateFlag, 0) == TRUE or isEnd == TRUE then
		local item_type = env(GetItemAnimType)
		if item_type ~= ITEM_NO_DRINK then
			ExecEventHalfBlendNoReset(Event_ItemDrinking, blend_type)
			return
		elseif item_type == ITEM_NO_DRINK and isEnd == TRUE then
			ExecEventHalfBlendNoReset(Event_ItemDrinkEmpty, blend_type)
			return
		end
	end
	if HalfBlendLowerCommonFunction(Event_ItemDrinkStart, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemDrinkNothing_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemDrinkNothing, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemDrinking_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlendNoReset(Event_ItemDrinkEnd, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemDrinking, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemDrinkEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemDrinkEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemShockWeaveStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemShockWeaveStart, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemShockWeaveEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemShockWeaveEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemDrinkStartMP_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE then
		ExecEventHalfBlendNoReset(Event_ItemDrinkingMP, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemDrinkStartMP, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemDrinkingMP_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlendNoReset(Event_ItemDrinkEnd, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemDrinkingMP, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemThrowSpear_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemThrowSpear, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function DragonFullStartAfter_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemThrowSpear, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemPrayMulti_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemPrayMulti, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemReturnBuddy_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemReturnBuddy, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemSummonBuddy_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemSummonBuddy, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemCopySleep_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemCopySleep, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemVoice_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemVoice, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemHolySymbol_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemHolySymbol, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemHost_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemHost, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemMultKick_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemMultKick, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemTongue_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemTongue, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemThrowBackBottle_Upper_onUpdate()
	act(LockonFixedAngleCancel)
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemThrowBackBottle, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemAromaWide_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemAromaWide, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemAromaUp_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemAromaUp, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemAromaBreath_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemAromaBreath, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemAromaDrink_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemAromaDrink, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemAromaFront_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemAromaFront, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemDrinkEmpty_Upper_onActivate()
	if env(IsCOMPlayer) == TRUE then
		act(AddSpEffect, 5630)
	end
end

function ItemDrinkEmpty_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemDrinkEmpty, lower_state, FALSE) == TRUE then
		return
	end
end

function ItemDragonThrowSpearMax_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemDragonThrowSpearMax, lower_state, FALSE, TRUE) == TRUE then
		return
	end
	if env(ActionDuration, ACTION_ARM_USE_ITEM) <= 0
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventHalfBlend(Event_ItemDragonThrowSpearCancel, blend_type)
		return
	end
end

function ItemDragonThrowSpearCancel_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemDragonThrowSpearCancel, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemThrowBigBottle_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemThrowBigBottle, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemDancingSwordsmanFire_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemDancingSwordsmanFire, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemTransformDragonPriest_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemTransformDragonPriest, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemTransformGodman_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemTransformGodman, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemTransformGodmanNPC_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemTransformGodmanNPC, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemTransformGodmanBreathNPC_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemTransformGodmanBreathNPC, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemCrySickness_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemCrySickness, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemCrySicknessPhantom_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemCrySicknessPhantom, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemSwitchExplosive_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemSwitchExplosive, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemSwitch_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemSwitch, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemThorn_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemThorn, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemErdtree_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemErdtree, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemElixir2_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemElixir2, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemOneShot_Upper_onUpdate()
	if GetVariable("IndexItemUseAnim") == 52 then
		SetEnableMimicry()
	end
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemOneShot, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemOneShot_SelfTrans_Upper_onUpdate()
	if GetVariable("IndexItemUseAnim_SelfTrans") == 52 then
		SetEnableMimicry()
	end
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemOneShot_SelfTrans, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemCombo_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemCombo, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

IsSummonDash = FALSE

function ItemDash_Upper_onUpdate()
	act(LockonFixedAngleCancel)
	act(SetAllowedThrowDefenseType, 255)
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if GetLocomotionState() == PLAYER_STATE_MOVE and GetVariable("MoveSpeedIndex") >= 1
		and GetVariable("ItemDashSpeedIndex") == 0 then
		act(DebugLogOutput, "SummonHorse ChangeSpeedIndex")
		IsSummonDash = TRUE
		SetVariable("ItemDashSpeedIndex", 1)
	end
	if env(IsSummoningRide) == TRUE then
		act(DebugLogOutput, "SummonHorse SummonRequest true")
		if env(IsNewRidingTest) == TRUE and IsSummonDash == TRUE then
			act(DebugLogOutput, "SummonHorse RideOnDash")
			SetVariable("RideOnSummonTest", 2)
			FireRideEvent("W_RideOn", "W_RideOnDash", FALSE)
		elseif env(IsNewRidingTest) == TRUE then
			act(DebugLogOutput, "SummonHorse RideOn")
			SetVariable("RideOnSummonTest", 1)
			FireRideEvent("W_RideOn", "W_RideOn", FALSE)
		else
			SetVariable("RideOnSummonTest", 0)
			ExecEventAllBody("W_RideAdjustFromCalling")
		end
		return
	elseif env(GetEventEzStateFlag, 0) == TRUE then
		if GetVariable("MoveSpeedLevel") >= 0.8999999761581421 then
		else
			IsSummonDash = FALSE
		end
		if env(IsAnimEnd, 1) == TRUE then
			ExecEventAllBody("W_Idle")
		end
		act(Mounting)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemDash, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemInvalid_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if ItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_ItemInvalid, lower_state, FALSE, TRUE) == TRUE then
		return
	end
end

function ItemLadderRecoverRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function ItemLadderSoulRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function ItemLadderElixirRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function ItemLadderElixir2Right_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function ItemLadderEatJerkyRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function ItemLadderDrinkStartRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, TRUE) == TRUE then
		return
	end
	local isEnd = env(IsAnimEnd, 1)
	if env(GetEventEzStateFlag, 0) == TRUE or isEnd == TRUE then
		local item_type = env(GetItemAnimType)
		if item_type ~= ITEM_NO_DRINK then
			ExecEvent("W_ItemLadderDrinkingRight")
			return
		elseif item_type == ITEM_NO_DRINK and isEnd == TRUE then
			ExecEvent("W_ItemLadderDrinkEmptyRight")
			return
		end
	end
end

function ItemLadderDrinkingRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, TRUE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEvent("W_ItemLadderDrinkEndRight")
		return
	end
end

function ItemLadderDrinkMPStartRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, TRUE) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE then
		ExecEvent("W_ItemLadderDrinkingMPRight")
		return
	end
end

function ItemLadderDrinkingMPRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, TRUE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEvent("W_ItemLadderDrinkEndRight")
		return
	end
end

function ItemLadderDrinkEndRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function ItemLadderDrinkEmptyRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function ItemLadderDrinkNothingRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function ItemLadderInvalidRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderItemCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function ItemLadderRecoverLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function ItemLadderSoulLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function ItemLadderElixirLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function ItemLadderElixir2Left_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function ItemLadderEatJerkyLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function ItemLadderDrinkStartLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, TRUE) == TRUE then
		return
	end
	local isEnd = env(IsAnimEnd, 1)
	if env(GetEventEzStateFlag, 0) == TRUE or isEnd == TRUE then
		local item_type = env(GetItemAnimType)
		if item_type ~= ITEM_NO_DRINK then
			ExecEvent("W_ItemLadderDrinkingLeft")
			return
		elseif item_type == ITEM_NO_DRINK and isEnd == TRUE then
			ExecEvent("W_ItemLadderDrinkEmptyLeft")
			return
		end
	end
end

function ItemLadderDrinkingLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, TRUE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEvent("W_ItemLadderDrinkEndLeft")
		return
	end
end

function ItemLadderDrinkMPStartLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, TRUE) == TRUE then
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE then
		ExecEvent("W_ItemLadderDrinkingMPLeft")
		return
	end
end

function ItemLadderDrinkingMPLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, TRUE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEvent("W_ItemLadderDrinkEndLeft")
		return
	end
end

function ItemLadderDrinkEndLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function ItemLadderDrinkEmptyLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function ItemLadderDrinkNothingLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function ItemLadderInvalidLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderItemCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function GestureStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if GestureCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_GestureStart, lower_state, FALSE) == TRUE then
		return
	end
end

function GestureLoopStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if GestureLoopCommonFunction(blend_type, lower_state, TRUE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlend(Event_GestureLoop, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_GestureLoopStart, lower_state, FALSE) == TRUE then
		return
	end
end

function GestureLoop_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if GestureLoopCommonFunction(blend_type, lower_state, FALSE) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_GestureLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function GestureEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if GestureCommonFunction() == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_GestureEnd, lower_state, FALSE) == TRUE then
		return
	end
end

function Magic_Upper_Activate()
end

function MagicRight_Upper_Activate()
	local style = c_Style
	act(DebugLogOutput, "MagicRight_Upper_Activate check" .. style .. " ==" .. HAND_LEFT_BOTH)
	if style == HAND_LEFT_BOTH then
		SetAttackHand(HAND_LEFT)
		SetGuardHand(HAND_LEFT)
	else
		SetAttackHand(HAND_RIGHT)
		SetGuardHand(HAND_RIGHT)
	end
	ActivateRightArmAdd(START_FRAME_NONE)
end

function MagicRight_Upper_Update()
	UpdateRightArmAdd()
end

function MagicLeft_Upper_Activate()
	act(DebugLogOutput, "MagicLeft_Upper_Activate")
	SetAttackHand(HAND_LEFT)
	SetGuardHand(HAND_LEFT)
	ActivateRightArmAdd(START_FRAME_A02)
end

function MagicLeft_Upper_Update()
	UpdateRightArmAdd()
end

function MagicLaunchRight_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	local magic_index = env(GetMagicAnimType)
	if MagicCommonFunction(blend_type, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if env(GetMagicAnimType) ~= MAGIC_REQUEST_CRYSTAL_MOON and blend_type ~= UPPER
		and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if env(IsAnimEndBySkillCancel) == TRUE or env(IsAnimEnd, 1) == TRUE then
		if ExecRollingMagic(HAND_RIGHT, magic_index, blend_type) == TRUE then
			return
		else
			ExecEventHalfBlend(Event_MagicFireRight, blend_type)
			return
		end
	end
	if HalfBlendLowerCommonFunction(Event_MagicLaunchRight, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicLoopRight_Upper_onUpdate()
	act(NotifyAIOfBehaviourState, IDX_AINOTE_STATETYPE, IDX_AINOTE_STATETYPE_CHARGEMAGIC)
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	local wep_hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		wep_hand = HAND_LEFT
	end

	local button = ACTION_ARM_R1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		button = ACTION_ARM_R2
	end

	if env(ActionDuration, button) <= 0 or env(IsMagicUseable, wep_hand, 1) == FALSE or env(GetStamina) <= 0 then
		local magic_index = env(GetMagicAnimType)
		if magic_index == MAGIC_REQUEST_EX_LARGE_ARROW then
			ExecEventHalfBlend(Event_MagicFireRightCancel2, blend_type)
		else
			ExecEventHalfBlend(Event_MagicFireRightCancel, blend_type)
		end
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicLoopRight, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicFireRight_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	local is_throw = FALSE
	local magic_index = env(GetMagicAnimType)
	if magic_index == MAGIC_REQUEST_MAD_THROW then
		is_throw = TRUE
	end
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, is_throw) == TRUE then
		return
	end
	local wep_hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		wep_hand = HAND_LEFT
	end

	local button = ACTION_ARM_R1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		button = ACTION_ARM_R2
	end

	if env(GetSpEffectID, 100610) == TRUE
		and (env(ActionDuration, button) <= 0 or env(IsMagicUseable, wep_hand, 1) == FALSE) then
		ExecEventHalfBlend(Event_MagicFireRightCancel, blend_type)
		return
	end

	if CheckIfHoldMagic() == TRUE and (env(IsAnimEndBySkillCancel) == TRUE or env(IsAnimEnd, 1) == TRUE) then
		if env(ActionDuration, button) > 0 then
			ExecEventHalfBlend(Event_MagicLoopRight, blend_type)
			return
		else
			ExecEventHalfBlend(Event_MagicFireRightCancel, blend_type)
			return
		end
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		SetMagicGeneratorTransitionIndex()
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireRight, lower_state, FALSE) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
end

function MagicFireRightCancel_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		SetMagicGeneratorTransitionIndex()
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireRightCancel, lower_state, FALSE) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
end

function MagicLaunchLeft_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	local magic_index = env(GetMagicAnimType)
	if MagicCommonFunction(blend_type, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if env(GetMagicAnimType) ~= MAGIC_REQUEST_CRYSTAL_MOON and blend_type ~= UPPER
		and ExecQuickTurn(LOWER, TURN_TYPE_DEFAULT) == TRUE then
		return TRUE
	end
	if env(IsAnimEndBySkillCancel) == TRUE or env(IsAnimEnd, 1) == TRUE then
		if ExecRollingMagic(HAND_LEFT, magic_index, blend_type) == TRUE then
			return
		else
			ExecEventHalfBlend(Event_MagicFireLeft, blend_type)
		end
	end
	if HalfBlendLowerCommonFunction(Event_MagicLaunchLeft, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicLoopLeft_Upper_onUpdate()
	act(NotifyAIOfBehaviourState, IDX_AINOTE_STATETYPE, IDX_AINOTE_STATETYPE_CHARGEMAGIC)
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	local button = ACTION_ARM_L1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		button = ACTION_ARM_L2
	end
	if env(ActionDuration, button) <= 0 or env(IsMagicUseable, HAND_LEFT, 1) == FALSE or env(GetStamina) <= 0 then
		local magic_index = env(GetMagicAnimType)
		if magic_index == MAGIC_REQUEST_EX_LARGE_ARROW then
			ExecEventHalfBlend(Event_MagicFireLeftCancel2, blend_type)
		else
			ExecEventHalfBlend(Event_MagicFireLeftCancel, blend_type)
		end
	end
	if HalfBlendLowerCommonFunction(Event_MagicLoopLeft, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicFireLeftCancel_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		SetMagicGeneratorTransitionIndex()
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireLeftCancel, lower_state, FALSE) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
end

function MagicFireRight2_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	local mp_condition = 0
	if GetVariable("IndexChargeMagicType") == 2 then
		mp_condition = 33
	end
	local wep_hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		wep_hand = HAND_LEFT
	end
	local button = ACTION_ARM_R1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		button = ACTION_ARM_R2
	end
	if env(GetSpEffectID, 100610) == TRUE and (env(ActionDuration, button) <= 0 or mp_condition >= env(GetFP)) then
		ExecEventHalfBlend(Event_MagicFireRightCancel2, blend_type)
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireRight2, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicFireRight3_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	local mp_condition = 0
	if GetVariable("IndexChargeMagicType") == 2 then
		mp_condition = 33
	end
	local wep_hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		wep_hand = HAND_LEFT
	end
	local button = ACTION_ARM_R1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		button = ACTION_ARM_R2
	end
	if env(GetSpEffectID, 100610) == TRUE and (env(ActionDuration, button) <= 0 or mp_condition >= env(GetFP)) then
		ExecEventHalfBlend(Event_MagicFireRightCancel3, blend_type)
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireRight3, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicFireLeft_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	local is_throw = FALSE
	local magic_index = env(GetMagicAnimType)
	if magic_index == MAGIC_REQUEST_MAD_THROW then
		is_throw = TRUE
	end
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, is_throw) == TRUE then
		return
	end

	local button = ACTION_ARM_L1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		button = ACTION_ARM_L2
	end

	if env(GetSpEffectID, 100610) == TRUE
		and (env(ActionDuration, button) <= 0 or env(IsMagicUseable, HAND_LEFT, 1) == FALSE) then
		ExecEventHalfBlend(Event_MagicFireLeftCancel, blend_type)
		return
	end
	if CheckIfHoldMagic() == TRUE and (env(IsAnimEndBySkillCancel) == TRUE or env(IsAnimEnd, 1) == TRUE) then
		if env(ActionDuration, button) > 0 then
			ExecEventHalfBlend(Event_MagicLoopLeft, blend_type)
			return
		else
			ExecEventHalfBlend(Event_MagicFireLeftCancel, blend_type)
			return
		end
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		SetMagicGeneratorTransitionIndex()
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireLeft, lower_state, FALSE) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
end

function MagicFireRightCancel2_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		SetMagicGeneratorTransitionIndex()
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireRight2, lower_state, FALSE) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
end

function MagicFireRightCancel3_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireRight3, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicFireLeftCancel2_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		SetMagicGeneratorTransitionIndex()
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireLeft2, lower_state, FALSE) == TRUE then
		SetMagicGeneratorTransitionIndex()
		return
	end
end

function MagicFireLeft2_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end

	local button = ACTION_ARM_L1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		button = ACTION_ARM_L2
	end

	if env(GetSpEffectID, 100610) == TRUE
		and (env(ActionDuration, button) <= 0 or env(IsMagicUseable, HAND_LEFT, 1) == FALSE) then
		ExecEventHalfBlend(Event_MagicFireLeftCancel2, blend_type)
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireLeft2, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicFireLeftCancel3_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireLeftCancel3, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicFireLeft3_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end

	local button = ACTION_ARM_L1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		button = ACTION_ARM_L2
	end

	if env(GetSpEffectID, 100610) == TRUE
		and (env(ActionDuration, button) <= 0 or env(IsMagicUseable, HAND_LEFT, 1) == FALSE) then
		ExecEventHalfBlend(Event_MagicFireLeftCancel3, blend_type)
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireLeftCancel3, lower_state, FALSE) == TRUE then
		return
	end
end

function QuickMagicFireRightDash_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_ATTACK, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_QuickMagicFireRightDash, lower_state, FALSE) == TRUE then
		return
	end
end

function QuickMagicFireRightStep_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_ATTACK, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_QuickMagicFireRightStep, lower_state, FALSE) == TRUE then
		return
	end
end

function QuickMagicFireRightBackStep_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_ATTACK, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_QuickMagicFireRightBackStep, lower_state, FALSE) == TRUE then
		return
	end
end

function QuickMagicFireRightAttackLeft_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_ATTACK, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_QuickMagicFireRightAttackLeft, lower_state, FALSE) == TRUE then
		return
	end
end

function QuickMagicFireRightAttackRight_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_ATTACK, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_QuickMagicFireRightAttackRight, lower_state, FALSE) == TRUE then
		return
	end
end

function QuickMagicFireLeftDash_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_ATTACK, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_QuickMagicFireLeftDash, lower_state, FALSE) == TRUE then
		return
	end
end

function QuickMagicFireLeftStep_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_ATTACK, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_QuickMagicFireLeftStep, lower_state, FALSE) == TRUE then
		return
	end
end

function QuickMagicFireLeftBackStep_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_ATTACK, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_QuickMagicFireLeftBackStep, lower_state, FALSE) == TRUE then
		return
	end
end

function QuickMagicFireLeftAttackRight_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_ATTACK, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_QuickMagicFireLeftAttackRight, lower_state, FALSE) == TRUE then
		return
	end
end

function QuickMagicFireLeftAttackLeft_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_ATTACK, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_QuickMagicFireLeftAttackRight, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicFireRightJump_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	local wep_hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		wep_hand = HAND_LEFT
	end

	local button = ACTION_ARM_R1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		button = ACTION_ARM_R2
	end

	if env(GetSpEffectID, 100610) == TRUE
		and (env(ActionDuration, button) <= 0 or env(IsMagicUseable, wep_hand, 1) == FALSE) then
		ExecEventHalfBlend(Event_MagicFireRightJumpCancel, blend_type)
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireRightJump, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicFireRightJumpCancel_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireRightJumpCancel, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicFireLeftJump_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	local wep_hand = HAND_LEFT
	local button = ACTION_ARM_L1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		button = ACTION_ARM_L2
	end
	if env(GetSpEffectID, 100610) == TRUE
		and (env(ActionDuration, button) <= 0 or env(IsMagicUseable, wep_hand, 1) == FALSE) then
		ExecEventHalfBlend(Event_MagicFireRightJumpCancel, blend_type)
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireLeftJump, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicFireLeftJumpCancel_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicFireLeftJumpCancel, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthMagicRightLaunch_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if env(IsAnimEndBySkillCancel) == TRUE or env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlend(Event_StealthMagicRightFire, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthMagicRightLaunch, lower_state, FALSE, FALSE) == TRUE then
		return
	end
end

function StealthMagicRightFire_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Stealth_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthMagicRightFire, lower_state, FALSE, FALSE) == TRUE then
		return
	end
end

function StealthMagicLeftLaunch_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if env(IsAnimEndBySkillCancel) == TRUE or env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlend(Event_StealthMagicLeftFire, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthMagicLeftLaunch, lower_state, FALSE, FALSE) == TRUE then
		return
	end
end

function StealthMagicLeftFire_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Stealth_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthMagicLeftFire, lower_state, FALSE, FALSE) == TRUE then
		return
	end
end

function RollingMagicRight_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_RollingMagicRight, lower_state, FALSE) == TRUE then
		return
	end
end

function RollingMagicLeft_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(blend_type, QUICKTYPE_NORMAL, FALSE) == TRUE then
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_RollingMagicLeft, lower_state, FALSE) == TRUE then
		return
	end
end

function MagicInvalid_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if MagicCommonFunction(ALLBODY, QUICKTYPE_ATTACK, FALSE) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_MagicInvalidMirror, lower_state, FALSE) == TRUE then
		return
	end
end

function ThrowBackStab_Activate()
	act(InvokeBackstab)
	local hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end
	SetAttackHand(hand)
	SetGuardHand(hand)
end

function ThrowBackStab_onActivate()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		local Level = DMN_RuneGain_Level
		if Effect_GetMaxLevel() / 2 < Level then
			Level = Effect_GetMaxLevel() / 2
		end

		if Timer_IsActive(GV_Character.TimerID_RuneGain) == TRUE then
			GV_Timer.Actions[GV_Character.TimerID_RuneGain][6][2] = Level * 2
		else
			GV_Character.TimerID_RuneGain = Timer_AddAction(System_SecondsToFrames(10), Effect_GetDurationLong(), Effect_AddByInfo, {GC_SPEIDS.RUNE_GAIN, Level}, nil, nil)
		end
	end
	-- CUSTOM: End.

	SetVariable("ThrowHandIndex", 0)
end

function ThrowBackStab_onUpdate()
	if env(HasThrowRequest) == FALSE then
		if BackStabCommonFunction() == TRUE then
			return
		end
	else
		ResetRequest()
		return
	end
end

function Throw_Activate()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		local Level = DMN_RuneGain_Level
		if env(GetSpEffectID, GC_SPEIDS.RUNE_GAIN) == TRUE then
			if Effect_GetMaxLevel() / 2 < Level then
				Level = Effect_GetMaxLevel() / 2
			end
		end

		if Timer_IsActive(GV_Character.TimerID_RuneGain) == TRUE then
			GV_Timer.Actions[GV_Character.TimerID_RuneGain][6][2] = Level * 2
		else
			GV_Character.TimerID_RuneGain = Timer_AddAction(System_SecondsToFrames(10), Effect_GetDurationLong(), Effect_AddByInfo, {GC_SPEIDS.RUNE_GAIN, Level}, nil, nil)
		end
	end
	-- CUSTOM: End.

	ResetRequest()
	SetVariable("MoveSpeedLevelReal", 0)
	SetThrowInvalid()
	local id = env(GetThrowAnimID)
	if id >= 0 then
		SetVariable("ThrowID", id)
	end
	if c_Style == HAND_LEFT_BOTH then
		SetAttackHand(HAND_LEFT)
		SetGuardHand(HAND_LEFT)
	else
		SetAttackHand(HAND_RIGHT)
		SetGuardHand(HAND_RIGHT)
	end
	SetVariable("ThrowHandIndex", 0)
	SetVariable("ThrowHoldBlendWeight", 0)
	SetVariable("ThrowHolding", false)
	SetVariable("ThrowNoRegistTime", 0)
end

function Throw_Update()
	SetThrowInvalid()
end

function Throw_Deactivate()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		Action_SetSpecial(FALSE)
		Action_SetCritical(FALSE)
		Timer_EndAction(GV_Character.TimerID_RuneGain)
	end
	-- CUSTOM: End.

	act(RequestThrowAnimInterrupt)
end

function ThrowAtk_onActivate()
	Replanning()
end

function ThrowAtk_onUpdate()
	if ThrowCommonFunction(FALSE) == TRUE then
		act(RequestThrowAnimInterrupt)
		return
	end
end

function ThrowDef_onActivate()
	Replanning()
end

function ThrowDef_onUpdate()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		if DMN_DeflectEvade_Mode == GC_MODES.DEFLECT_EVADE_ENABLE then
			if Deflect_IsActive() == TRUE then
				ExecEventAllBody("W_DMN_DeflectH_Back1")
				Timer_AddAction(System_SecondsToFrames(7), Effect_GetDurationLong(), Effect_AddByID, GC_SPEIDS.INVISIBLE_LONG, nil, nil)
			end
		end
	end
	-- CUSTOM: End.

	if env(GetSpEffectID, 19682) == TRUE and env(GetSpEffectID, 19681) == TRUE then
		act(AddSpEffect, 19680)
	end
	if env(GetEventEzStateFlag, 0) == TRUE and env(GetSpEffectID, 19680) == TRUE then
		SetVariable("IndexDeath", DEATH_TYPE_CHARM)
		ExecEvent("W_DeathStart")
		return
	end
	SetThrowDefBlendWeight()
	if env(IsThrowSelfDeath) == TRUE then
		ExecEvent("ThrowDeath")
		return
	end
	if env(IsThrowSuccess) == TRUE then
		ExecEvent("W_ThrowEscape")
		return
	end
	if ThrowCommonFunction(ESTEP_DOWN) == TRUE then
		act(RequestThrowAnimInterrupt)
		return
	end
end

function ThrowEscape_onUpdate()
	if ThrowCommonFunction() == TRUE then
		act(RequestThrowAnimInterrupt)
		return
	end
end

function ThrowDeath_onActivate()
	act(SetThrowState, THROW_TYPE_DEATH)
end

function ThrowDeathIdle_onActivate()
	act(SetThrowState, THROW_TYPE_INVALID)
end

function Event_onActivate()
	ResetEventState()
	SetVariable("TestIsEventBlend", 1)
	if GetVariable("TestIsEventBlend") then
		local testmoveangle = env(GetObjActTargetDirection)
		SetVariable("TestMoveAngle", testmoveangle)
		TestBlendrate = 0
	end
	blendtimemax = env(GetObjActRemainingInterpolateTime)
end

function Event_onUpdate()
	if GetVariable("TestIsEventBlend") then
		blendtime = env(GetObjActRemainingInterpolateTime)
		if blendtime > 0 then
			if blendtime > EVENT_BLEND_RATE * 2 then
				SetVariable("TestEventBlend_Move", 1)
				SetVariable("TestEventBlend_Event", 0)
			else
				local blendstoptime = blendtimemax / 2
				if blendstoptime < 300 then
					blendstoptime = 300
				elseif blendstoptime > 750 then
					blendstoptime = 750
				end
				local blendmove = (blendtime - 300) / EVENT_BLEND_RATE
				local blendevent = 1 - (blendtime - 300) / EVENT_BLEND_RATE
				if blendmove < 0 then
					blendmove = 0
				end
				if blendevent > 1 then
					blendevent = 1
				end
				SetVariable("TestEventBlend_Move", blendmove)
				SetVariable("TestEventBlend_Event", blendevent)
			end
		end
	end
end

function Event26001_onActivate()
	ResetEventState()
	act(SetTurnAnimCorrectionRate, 90)
end

function Event26001_onUpdate()
	act(SetIsTurnAnimInProgress)
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event26011_onActivate()
	ResetEventState()
	act(SetTurnAnimCorrectionRate, 90)
end

function Event26011_onUpdate()
	act(SetIsTurnAnimInProgress)
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event26020_onActivate()
	ResetEventState()
end

function Event26020_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event26030_onActivate()
	ResetEventState()
end

function Event26030_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event26021_onActivate()
	ResetEventState()
	act(SetTurnAnimCorrectionRate, 180)
end

function Event26021_onUpdate()
	act(SetIsTurnAnimInProgress)
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event26031_onActivate()
	ResetEventState()
	act(SetTurnAnimCorrectionRate, 180)
end

function Event26031_onUpdate()
	act(SetIsTurnAnimInProgress)
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event50050_onActivate()
	ResetEventState()
end

function Event50050_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event50050_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event50250_onActivate()
	ResetEventState()
end

function Event50250_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event50250_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60000_onActivate()
	ResetEventState()
end

function Event60000_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event60000_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60001_onActivate()
	ResetEventState()
end

function Event60001_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event60001_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60002_onActivate()
	ResetEventState()
end

function Event60002_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event60002_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60003_onActivate()
	ResetEventState()
end

function Event60003_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event60003_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60010_onActivate()
	ResetEventState()
end

function Event60010_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60020_onActivate()
	ResetEventState()
end

function Event60020_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60030_onActivate()
	ResetEventState()
end

function Event60030_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60040_onActivate()
	ResetEventState()
end

function Event60040_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60060_onActivate()
	ResetEventState()
end

function Event60060_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60070_onActivate()
	ResetEventState()
end

function Event60070_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event60070_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60071_onActivate()
	ResetEventState()
end

function Event60071_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event60071_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function EventHalfBlend60071_Upper_onActivate()
	ResetEventState()
end

function EventHalfBlend60071_Upper_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	act(Wait)
	local blend_type, lower_state = GetHalfBlendInfo()
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Move, UPPER)
		act(SetIsEventActionPossible, FALSE)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
	if HalfBlendLowerCommonFunction(Event_EventHalfBlend60071, lower_state, FALSE) == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function EventHalfBlend60071_Upper_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function EventHalfBlend360070_Upper_onActivate()
	ResetEventState()
end

function EventHalfBlend360070_Upper_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	act(Wait)
	local blend_type, lower_state = GetHalfBlendInfo()
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
	if lower_state == LOWER_MOVE and env(IsMoveCancelPossible) == TRUE then
		ExecEventHalfBlendNoReset(Event_Stealth_Move, UPPER)
		act(SetIsEventActionPossible, FALSE)
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
	if HalfBlendLowerCommonFunction(Event_EventHalfBlend360070, lower_state, FALSE) == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function EventHalfBlend360070_Upper_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60080_onActivate()
	ResetEventState()
end

function Event60080_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60090_onActivate()
	ResetEventState()
end

function Event60090_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event60090_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60100_onActivate()
	ResetEventState()
end

function Event60100_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60110_onActivate()
	ResetEventState()
end

function Event60110_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60120_onActivate()
	ResetEventState()
end

function Event60120_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60130_onActivate()
	ResetEventState()
end

function Event60130_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60131_onActivate()
	ResetEventState()
end

function Event60131_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60160_onActivate()
	ResetEventState()
end

function Event60160_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event60160_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60170_onActivate()
	ResetEventState()
end

function Event60170_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event60170_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60180_onActivate()
	ResetEventState()
end

function Event60180_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event60180_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60190_onActivate()
	ResetEventState()
end

function Event60190_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event60190_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event60200_onActivate()
	ResetEventState()
end

function Event60200_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60201_onActivate()
	ResetEventState()
end

function Event60201_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60202_onActivate()
	ResetEventState()
end

function Event60202_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60210_onActivate()
	ResetEventState()
end

function Event60210_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60220_onActivate()
	ResetEventState()
end

function Event60220_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60230_onActivate()
	ResetEventState()
end

function Event60230_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60231_onActivate()
	ResetEventState()
end

function Event60231_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60240_onActivate()
	ResetEventState()
end

function Event60240_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60241_onActivate()
	ResetEventState()
end

function Event60241_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60250_onActivate()
	ResetEventState()
end

function Event60250_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60260_onActivate()
	ResetEventState()
end

function Event60260_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60265_onActivate()
	ResetEventState()
end

function Event60265_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60270_onActivate()
	ResetEventState()
end

function Event60270_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60370_onActivate()
	ResetEventState()
end

function Event60370_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60380_onActivate()
	ResetEventState()
end

function Event60380_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60390_onActivate()
	ResetEventState()
end

function Event60390_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60400_onActivate()
	ResetEventState()
end

function Event60400_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60450_onActivate()
	ResetEventState()
end

function Event60450_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60451_onActivate()
	ResetEventState()
end

function Event60451_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60455_onActivate()
	ResetEventState()
end

function Event60455_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60456_onActivate()
	ResetEventState()
end

function Event60455_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60460_onActivate()
	ResetEventState()
end

function Event60460_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60470_onActivate()
	ResetEventState()
end

function Event60470_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60471_onActivate()
	ResetEventState()
end

function Event60471_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60472_onActivate()
	ResetEventState()
end

function Event60472_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60473_onActivate()
	ResetEventState()
end

function Event60473_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60480_onActivate()
	ResetEventState()
end

function Event60480_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60481_onActivate()
	ResetEventState()
end

function Event60481_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60482_onActivate()
	ResetEventState()
end

function Event60482_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60490_onActivate()
	ResetEventState()
end

function Event60490_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60500_onActivate()
	ResetEventState()
end

function Event60500_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60501_onActivate()
	ResetEventState()
end

function Event60501_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60502_onActivate()
	ResetEventState()
end

function Event60502_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60503_onActivate()
	ResetEventState()
end

function Event60503_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60504_onActivate()
	ResetEventState()
end

function Event60504_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60505_onActivate()
	ResetEventState()
end

function Event60505_onUpdate()
	if env(IsAnimEnd, 1) == TRUE then
		act(ChangeBuddyState)
	end
end

function Event60505_onDeactivate()
	act(ChangeBuddyState)
end

function Event60520_onActivate()
	ResetEventState()
end

function Event60520_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60521_onActivate()
	ResetEventState()
end

function Event60521_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60522_onActivate()
	ResetEventState()
end

function Event60522_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60523_onActivate()
	ResetEventState()
end

function Event60523_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60524_onActivate()
	ResetEventState()
end

function Event60524_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60525_onActivate()
	ResetEventState()
end

function Event60525_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60530_onActivate()
	ResetEventState()
end

function Event60530_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60550_onActivate()
	ResetEventState()
end

function Event60550_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60560_onActivate()
	ResetEventState()
end

function Event60560_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60750_onActivate()
	ResetEventState()
end

function Event60750_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60760_onActivate()
	ResetEventState()
end

function Event60760_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60780_onActivate()
	ResetEventState()
end

function Event60780_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60790_onActivate()
	ResetEventState()
end

function Event60790_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60800_onActivate()
	ResetEventState()
end

function Event60800_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60810_onActivate()
	ResetEventState()
end

function Event60810_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event60811_onActivate()
	ResetEventState()
end

function Event60811_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event63000_onActivate()
	ResetEventState()
end

function Event63000_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event63010_onActivate()
	ResetEventState()
end

function Event63010_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event63020_onActivate()
	ResetEventState()
end

function Event63020_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event63021_onActivate()
	ResetEventState()
end

function Event63040_onActivate()
	ResetEventState()
end

function Event63040_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event63050_onActivate()
	ResetEventState()
end

function Event63050_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event63060_onActivate()
	ResetEventState()
end

function Event63060_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event63061_onActivate()
	ResetEventState()
end

function Event63061_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event63070_onActivate()
	ResetEventState()
end

function Event63070_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event63080_onActivate()
	ResetEventState()
end

function Event63080_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event63090_onActivate()
	ResetEventState()
end

function Event63090_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event65012_onActivate()
	ResetEventState()
end

function Event65012_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event65013_onActivate()
	ResetEventState()
end

function Event65013_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67000_onActivate()
	ResetEventState()
end

function Event67000_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67001_onActivate()
	ResetEventState()
end

function Event67001_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67010_onActivate()
	ResetEventState()
end

function Event67010_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67011_onActivate()
	ResetEventState()
end

function Event67011_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67020_onActivate()
	ResetEventState()
end

function Event67020_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67030_onActivate()
	ResetEventState()
end

function Event67030_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67040_onActivate()
	ResetEventState()
end

function Event67040_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67050_onActivate()
	ResetEventState()
end

function Event67050_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67060_onActivate()
	ResetEventState()
end

function Event67060_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67070_onActivate()
	ResetEventState()
end

function Event67070_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67080_onActivate()
	ResetEventState()
end

function Event67080_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67090_onActivate()
	ResetEventState()
end

function Event67090_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67080_onActivate()
	ResetEventState()
end

function Event67080_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event67100_onActivate()
	ResetEventState()
end

function Event67100_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event68043_onActivate()
	ResetEventState()
end

function Event68043_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event68110_onActivate()
	ResetEventState()
end

function Event68110_onUpdate()
	if env(IsAnimEnd, 1) == TRUE then
		ExecEvent("W_BonfireLevelUpLoop")
		return
	end
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event69000_onActivate()
	ResetEventState()
end

function Event69000_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event69001_onActivate()
	ResetEventState()
end

function Event69001_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event69002_onActivate()
	ResetEventState()
end

function Event69002_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event69003_onActivate()
	ResetEventState()
end

function Event69003_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event69010_onActivate()
	ResetEventState()
end

function Event69010_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event69030_onActivate()
	ResetEventState()
end

function Event69030_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event6000_onActivate()
	ResetEventState()
end

function Event6000_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event6000_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event6001_onActivate()
	ResetEventState()
end

function Event6001_onUpdate()
	if env(GetSpEffectID, 10665) == TRUE then
		act(SetIsEventActionPossible, FALSE)
	else
		act(SetIsEventActionPossible, TRUE)
	end
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event6001_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event6002_onActivate()
	ResetEventState()
end

function Event6002_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event17140_onActivate()
	ResetEventState()
end

function Event18140_onActivate()
	ResetEventState()
end

function Event18140_onUpdate()
	act(SetDeathStay, TRUE)
end

function Event18140_onDeactivate()
	act(SetDeathStay, FALSE)
end

function Event99999_onActivate()
	ResetEventState()
end

function Event99999_onUpdate()
	if EventCommonFunction() == TRUE then
		return
	end
end

function Event150250_onActivate()
	ResetEventState()
end

function Event150250_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
	local lower_only = TRUE
	local enable_turn = FALSE
	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end
	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event150250_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event160070_onActivate()
	ResetEventState()
end

function Event160070_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
	local lower_only = TRUE
	local enable_turn = FALSE
	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end
	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event160070_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Event360070_onActivate()
	ResetEventState()
end

function Event360070_onUpdate()
	act(SetIsEventActionPossible, TRUE)
	if env(IsAnimEnd, 0) == TRUE then
		ExecEventAllBody("W_Stealth_Idle")
		act(SetIsEventActionPossible, FALSE)
		return
	end
	if EventCommonFunction() == TRUE then
		act(SetIsEventActionPossible, FALSE)
		return
	end
end

function Event360070_onDeactivate()
	act(SetIsEventActionPossible, FALSE)
end

function Ladder_Activate()
	act(ClearSlopeInfo)
	act(SetCanChangeEquipmentOn)
	Flag_LadderDamage = LADDER_DAMAGE_NONE
	Flag_LadderJump = LADDER_JUMP_INVALID
	SetThrowInvalid()
end

function Ladder_Update()
	SetThrowInvalid()
	LadderSetActionState(INVALID)
end

function LadderAttachBottom_onUpdate()
	if env(IsObjActInterpolatedMotion) == TRUE then
		return
	end
	ExecEvent("W_LadderStartBottom")
end

function LadderAttachTop_onUpdate()
	if env(IsObjActInterpolatedMotion) == TRUE then
		return
	end
	ExecEvent("W_LadderStartTop")
end

function LadderStartTop_onActivate()
	act(ClearSlopeInfo)
end

function LadderStartTop_onUpdate()
	LadderSetActionState(LADDER_ACTION_START_TOP)
	if LadderMoveCommonFunction(HAND_STATE_LEFT, TRUE) == TRUE then
		return
	end
end

function LadderStartBottom_onActivate()
	act(ClearSlopeInfo)
end

function LadderStartBottom_onUpdate()
	LadderSetActionState(LADDER_ACTION_START_BOTTOM)
	if LadderMoveCommonFunction(HAND_STATE_LEFT, TRUE) == TRUE then
		return
	end
end

function LadderUpRight_onActivate()
	LadderSendCommand(LADDER_CALL_UP)
end

function LadderUpRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_UP_RIGHT)
	if LadderMoveCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function LadderUpLeft_onActivate()
	LadderSendCommand(LADDER_CALL_UP)
end

function LadderUpLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_UP_LEFT)
	if LadderMoveCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function LadderDownLeft_onActivate()
	LadderSendCommand(LADDER_CALL_DOWN)
end

function LadderDownLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_DOWN_LEFT)
	if LadderMoveCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function LadderDownRight_onActivate()
	LadderSendCommand(LADDER_CALL_DOWN)
end

function LadderDownRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_DOWN_RIGHT)
	if LadderMoveCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function LadderEndBottomLeft_onActivate()
	LadderSendCommand(LADDER_EVENT_COMMAND_EXIT)
end

function LadderEndBottomLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_END_BOTTOM)
	if LadderEndCommonFunction() == TRUE then
		return
	end
end

function LadderEndBottomRight_onActivate()
	LadderSendCommand(LADDER_CALL_DOWN)
end

function LadderEndBottomRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_END_BOTTOM)
	if LadderEndCommonFunction() == TRUE then
		return
	end
end

function LadderEndTopLeft_onActivate()
	LadderSendCommand(LADDER_CALL_UP)
end

function LadderEndTopLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_END_TOP)
	if LadderEndCommonFunction() == TRUE then
		return
	end
end

function LadderEndTopRight_onActivate()
	LadderSendCommand(LADDER_CALL_UP)
end

function LadderEndTopRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_END_TOP)
	if LadderEndCommonFunction() == TRUE then
		return
	end
end

function LadderIdleLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_LEFT)
	if LadderIdleCommonFunction(HAND_STATE_LEFT) == TRUE then
		return
	end
end

function LadderIdleRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_IDLE_RIGHT)
	if LadderIdleCommonFunction(HAND_STATE_RIGHT) == TRUE then
		return
	end
end

function LadderAttackUpRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_ATTACK_UP_RIGHT)
	if LadderAttackCommonFunction(HAND_STATE_RIGHT) == TRUE then
		return
	end
end

function LadderAttackUpLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_ATTACK_UP_LEFT)
	if LadderAttackCommonFunction(HAND_STATE_LEFT) == TRUE then
		return
	end
end

function LadderAttackDownRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_ATTACK_DOWN_RIGHT)
	if LadderAttackCommonFunction(HAND_STATE_RIGHT) == TRUE then
		return
	end
end

function LadderAttackDownLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_ATTACK_DOWN_RIGHT)
	if LadderAttackCommonFunction(HAND_STATE_LEFT) == TRUE then
		return
	end
end

function LadderCoastStart_onUpdate()
	LadderSetActionState(LADDER_ACTION_COAST_START)
	if LadderCoastCommonFunction(HAND_STATE_LEFT, TRUE) == TRUE then
		return
	end
end

function LadderCoastRight_onActivate()
	LadderSendCommand(LADDER_CALL_DOWN)
end

function LadderCoastRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_COAST_RIGHT)
	if LadderCoastCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function LadderCoastLeft_onActivate()
	LadderSendCommand(LADDER_CALL_DOWN)
end

function LadderCoastLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_COAST_LEFT)
	if LadderCoastCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function LadderCoastStopLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_COAST_STOP)
	if LadderMoveCommonFunction(HAND_STATE_LEFT, FALSE) == TRUE then
		return
	end
end

function LadderCoastStopRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_COAST_STOP)
	if LadderMoveCommonFunction(HAND_STATE_RIGHT, FALSE) == TRUE then
		return
	end
end

function LadderCoastLanding_onActivate()
	LadderSendCommand(LADDER_CALL_DOWN)
end

function LadderCoastLanding_onUpdate()
	LadderSetActionState(LADDER_ACTION_COAST_LANDING)
	if LadderEndCommonFunction() == TRUE then
		return
	end
end

function LadderDamageLargeRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_DAMAGE_LARGE)
	if LadderDamageCommonFunction(HAND_STATE_RIGHT) == TRUE then
		return
	end
end

function LadderDamageSmallRight_onUpdate()
	LadderSetActionState(LADDER_ACTION_DAMAGE_SMALL)
	if LadderDamageCommonFunction(HAND_STATE_RIGHT) == TRUE then
		return
	end
end

function LadderDamageLargeLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_DAMAGE_LARGE)
	if LadderDamageCommonFunction(HAND_STATE_LEFT) == TRUE then
		return
	end
end

function LadderDamageSmallLeft_onUpdate()
	LadderSetActionState(LADDER_ACTION_DAMAGE_SMALL)
	if LadderDamageCommonFunction(HAND_STATE_LEFT) == TRUE then
		return
	end
end

function LadderDeathStart_onActivate()
	LadderSendCommand(LADDER_EVENT_COMMAND_EXIT)
end

function LadderDeathLoop_onUpdate()
	if env(IsLanding) == TRUE then
		ExecEvent("LadderDeathLand")
	end
	local height = env(GetFallHeight) / 100
	if height > 60 then
		ExecEvent("W_LadderDeathIdle")
	end
end

function LadderDeathIdle_onActivate()
	act(SetDeathStay, TRUE)
end

function LadderDeathIdle_onDeactivate()
	act(SetDeathStay, FALSE)
end

function LadderFallStart_onActivate()
	LadderSendCommand(LADDER_EVENT_COMMAND_EXIT)
end

function LadderFallLoop_onUpdate()
	if FallCommonFunction(TRUE, FALSE, FALL_LADDER) == TRUE then
		return
	end
end

function LadderFallLanding_onUpdate()
	if LandCommonFunction() == TRUE then
		return
	end
end

function LadderDrop_onUpdate()
	act(SetMovementScaleMult, math.random(160, 200) / 100)
	act(SetCanChangeEquipmentOn)
	if env(IsFalling) == TRUE then
		ExecEventAllBody("W_FallLoop")
		return
	end
end

function Initialize()
	SetBonfireIndex()
	ClearAttackQueue()
	act(AddSpEffect, 6990)
	act(AddSpEffect, 6300)
	if env(IsFemale) == FALSE then
		c_IsFemale = TRUE
	end
end

function SetBonfireIndex()
	SetVariable("IndexBonfire", 0)
end

function SetThrowAtkInvalid()
	act(SetAllowedThrowAttackType, THROW_STATE_INVALID)
end

function SetThrowDefInvalid()
	act(SetAllowedThrowDefenseType, THROW_STATE_INVALID)
end

function SetThrowInvalid()
	act(SetAllowedThrowAttackType, THROW_STATE_INVALID)
	act(SetAllowedThrowDefenseType, THROW_STATE_INVALID)
end

function AddDamageDefault_onUpdate()
	SetVariable("AddDamageBlend", 0)
end

function AddDamageDefaultGuard_onUpdate()
	SetVariable("AddDamageGuardBlend", 0)
end

function SAMagic_Default_onUpdate()
	SetVariable("SAMagicBlendRate", 0)
end

function DamageDirNoAdd_onUpdate()
	SetVariable("DamageDirBlendRate", 0)
end

function AddDamageLv0_Default_onUpdate()
	SetVariable("AddDamageLv0_Blend", 0)
end

function ChangeMoveSpeedIndex(index)
	SetVariable("MoveSpeedIndex", index)
	if index >= 2 then
		SetVariable("MoveSpeedIndexBLR", 1)
	else
		SetVariable("MoveSpeedIndexBLR", index)
	end
end

function SpeedUpdate()
	local stick_level = GetVariable("MoveSpeedLevel")
	local move_angle = GetVariable("MoveAngle")
	local is_aim = env(IsPrecisionShoot)
	local is_lockon = GetVariable("IsLockon")

	if is_aim == TRUE then
		if stick_level > 1 then
			stick_level = 1
		end
	elseif env(GetSpEffectID, 100020) == TRUE and stick_level > 1 then
		stick_level = 1
	end

	local speed = GetMoveSpeed(stick_level)
	SetVariable("MoveSpeedLevelReal", speed)

	if env(GetStamina) <= 0 then
		act(AddSpEffect, 100020)
	end

	local weight = math.mod(env(GetMoveAnimParamID), 20)

	if is_aim == TRUE then
		ChangeMoveSpeedIndex(0)
	elseif weight == WEIGHT_OVERWEIGHT then
		ChangeMoveSpeedIndex(0)
	elseif env(GetSpEffectID, 503520) == TRUE then
		ChangeMoveSpeedIndex(0)
	elseif env(GetSpEffectID, 4101) == TRUE then -- Duplicate Condition #1
		ChangeMoveSpeedIndex(0)
	elseif g_IsMimicry == TRUE then
		if stick_level > 1.100000023841858 then
			ResetMimicry()
		else
			ChangeMoveSpeedIndex(0)
		end
	elseif env(GetSpEffectID, 4101) == TRUE then -- Duplicate Condition #2
		if stick_level > 1.100000023841858 then
			ChangeMoveSpeedIndex(1)
		end
	elseif env(GetSpEffectID, 425) == TRUE or env(GetSpEffectID, 19670) == TRUE then
		if stick_level > 1.100000023841858 then
			ChangeMoveSpeedIndex(1)
		end
	elseif env(GetSpEffectID, 100220) == TRUE then
		ChangeMoveSpeedIndex(2)
	else

		-- CUSTOM: Begin.
		if Game_IsPlayer() == TRUE then
			if Movement_AdjustSprinting() == TRUE then
				return
			end
		end
		-- CUSTOM: End.

		local runLevel = 0.6000000238418579

		if GetVariable("IsEnableToggleDashTest") >= 1 and GetVariable("MoveSpeedIndex") >= 1 then
			runLevel = 0.4000000059604645
		end

		-- Sprint (stick + O)
		if stick_level > 1.100000023841858 then
			if env(GetSpEffectID, 100020) == TRUE then
				ChangeMoveSpeedIndex(1)
				SetVariable("ToggleDash", 0)
			else
				act(LockonFixedAngleCancel)
				ChangeMoveSpeedIndex(2)
			end
			-- Normal Walk (stick)
		elseif runLevel < stick_level then
			ChangeMoveSpeedIndex(1)
			if env(GetSpEffectID, 100002) == FALSE
				and (GetVariable("IsEnableToggleDashTest") >= 2 or env(GetSpEffectID, 100301) == FALSE) then
				SetVariable("ToggleDash", 0)
			end
			-- Stop
		else
			ChangeMoveSpeedIndex(0)
			if env(GetSpEffectID, 100002) == FALSE
				and (GetVariable("IsEnableToggleDashTest") >= 2 or env(GetSpEffectID, 100301) == FALSE) then
				SetVariable("ToggleDash", 0)
			end
		end
	end

	if env(GetSpEffectID, 100002) == TRUE then
		act(SetStaminaRecoveryDisabled)
	end
end

function GetMoveSpeed(stick_level)
	local speed = GetVariable("MoveSpeedLevelReal")
	local inc_val = ACCELERATION_WALK_SPEED_UP
	local dec_val = ACCELERATION_SPEED_DOWN
	if stick_level == 2 then
		inc_val = ACCELERATION_DASH_SPEED_UP
		dec_val = ACCELERATION_DASH_SPEED_DOWN
	end
	local ret = ConvergeValue(stick_level, speed, inc_val, dec_val)
	return ret
end

function StealthTransitionIndexUpdate()
	local move_speed_level = GetVariable("MoveSpeedLevel")
	local MoveIndex = GetVariable("MoveSpeedIndex")
	if MoveIndex == 2 then
		SetVariable("StealthTransitionIndex", 3)
	elseif MoveIndex == 1 then
		SetVariable("StealthTransitionIndex", 2)
	elseif move_speed_level > 0 then
		SetVariable("StealthTransitionIndex", 1)
	else
		SetVariable("StealthTransitionIndex", 0)
	end
end

function SetThrowDefBlendWeight()
	if env(DoesAnimExist, GetVariable("ThrowID") + 4) == FALSE then
		return
	end
	local regist_num = env(GetThrowDefenseCount)
	local dT = GetDeltaTime()
	local blend_weight = GetVariable("ThrowHoldBlendWeight")
	local is_holding = GetVariable("ThrowHolding")
	local no_regist_time = GetVariable("ThrowNoRegistTime")
	if regist_num > 0 then
		is_holding = true
	end
	if is_holding == true then
		if regist_num <= 0 then
			no_regist_time = no_regist_time + dT
		end
		if no_regist_time > 0.699999988079071 then
			is_holding = false
		else
			blend_weight = blend_weight + 2 * dT
			if blend_weight > 0.9900000095367432 then
				blend_weight = 0.9900000095367432
			end
			SetVariable("IsEnableTAEThrowHold", true)
		end
	else
		no_regist_time = 0
		blend_weight = blend_weight - 4 * dT
		if blend_weight < 0.009999999776482582 then
			blend_weight = 0.009999999776482582
			SetVariable("IsEnableTAEThrowHold", false)
		else
			SetVariable("IsEnableTAEThrowHold", true)
		end
	end
	SetVariable("ThrowHoldBlendWeight", blend_weight)
	SetVariable("ThrowHolding", is_holding)
	SetVariable("ThrowNoRegistTime", no_regist_time)
end

function SetNpcTurnSpeed(turn_speed)
	if env(IsCOMPlayer) == TRUE and turn_speed >= 0 then
		act(SetTurnSpeed, turn_speed)
	end
end

function GetDeltaTime()
	return env(ObtainedDT) / 1000
end

function GetConstVariable()
	c_HasActionRequest = CheckActionRequest()
	c_RollingAngle = env(GetRollAngle) * 0.009999999776482582
	c_ArtsRollingAngle = env(GetSwordArtsRollAngle) * 0.009999999776482582
	c_Style = env(GetWeaponSwitchState)
	c_SwordArtsID, c_SwordArtsHand = GetSwordArtInfo()
	c_IsEnableSwordArts = IsEnableSwordArts()
	c_IsStealth = env(GetSpEffectID, 8001)
end

function GetHalfBlendInfo()
	local blend_type = ALLBODY
	local lower_state = LOWER_IDLE
	if GetLocomotionState() == PLAYER_STATE_MOVE then
		blend_type = UPPER
		lower_state = LOWER_MOVE
	elseif IsLowerQuickTurn() == TRUE then
		if ExitQuickTurnLower() == TRUE then
			lower_state = LOWER_END_TURN
		else
			blend_type = UPPER
			lower_state = LOWER_TURN
		end
	end
	return blend_type, lower_state
end

-------------------------------
-- Main Update
-------------------------------
function Update()
	GetConstVariable()
	SetStyleSpecialEffect()
	act(SwitchMotion, FALSE)

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		System_Update()
	end
	-- CUSTOM: End.

	if env(ActionDuration, ACTION_ARM_ACTION) > 0 then
		SetThrowAtkInvalid()
	end

	SetVariable("EyeBlinkBlend", 1 - g_TimeActEditor_11)
	act(LockonSystemUnableToTurnAngle, 0, 0)

	if env(IsOnMount) == TRUE then
		act(LockonFixedAngleCancel)
		if env(GetSpiritspringJumpHeight) > 0 or env(GetSpEffectID, 183) == TRUE then
			act(AddSpEffect, 185)
		end
	end

	SetVariable("LocomotionState", GetLocomotionState())
	SetMoveType()
	ChangeWaistTwist(-10, 0, -20, 0)

	if IsLowerQuickTurn() == TRUE then
		SetVariable("LookAtTwist30_OnGain", 1)
	else
		SetVariable("LookAtTwist30_OnGain", 0.10000000149011612)
	end

	GreyOutSwordArtFE()
	SetArtCancelType()

	if GetVariable("IsKeepAttackQueue") == false then
		ClearAttackQueue()
	end

	if c_Style == HAND_LEFT_BOTH then
		SetVariable("IndexHandBothStyle", 1)
	else
		SetVariable("IndexHandBothStyle", 0)
	end

	GetTimeActEditorVariable()
	UpdatePostureTwist()
	g_IsMimicry = env(GetSpEffectID, 503040)

	if g_EnableMimicry == FALSE and g_IsMimicry == TRUE then
		ResetMimicry()
	end

	g_EnableMimicry = FALSE

	if env(GetSpEffectID, 503317) == TRUE then
		if env(GetSpEffectID, 503315) == TRUE then
			act(AddSpEffect, 503312)
		elseif env(GetSpEffectID, 9642) == TRUE then
		else
			act(AddSpEffect, 503313)
		end
	end

	if env(IsPrecisionShoot) == TRUE and env(GetSpEffectID, 19990) == TRUE and env(GetSpEffectID, 3240) == FALSE then
		act(AddSpEffect, 19991)
	end
	if env(GetSpEffectID, 19985) == TRUE then
		SetWeightIndex()
		if GetVariable("EvasionWeightIndex") == EVASION_WEIGHT_INDEX_HEAVY then
			act(AddSpEffect, 19986)
		elseif GetVariable("EvasionWeightIndex") == EVASION_WEIGHT_INDEX_OVERWEIGHT then
			act(AddSpEffect, 19987)
		end
	end

	-- Euporia
	local isChangingWeaponRight = FALSE
	local isChangingWeaponLeft = FALSE
	if IsNodeActive("WeaponChangeStart_Selector00") == TRUE or IsNodeActive("WeaponChangeEnd_Selector00") == TRUE or
		IsNodeActive("WeaponChangeStart_Selector01") == TRUE or IsNodeActive("WeaponChangeEnd_Selector01") == TRUE or
		IsNodeActive("RideWeaponChangeStart_Selector") == TRUE or IsNodeActive("RideWeaponChangeEnd_Selector") == TRUE then

		if GetVariable("WeaponChangeType") <= WEAPON_CHANGE_REQUEST_RIGHT_SPEAR and GetVariable("WeaponChangeType") ~= WEAPON_CHANGE_REQUEST_INVALID then
			isChangingWeaponRight = TRUE
		else
			isChangingWeaponLeft = TRUE
		end
	end
	if env(GetSpEffectID, 19875) == TRUE then
		if isChangingWeaponLeft == FALSE and (c_Style == HAND_RIGHT or c_Style == HAND_LEFT_BOTH) and env(GetSwordArtID, HAND_LEFT) == 328 then
			act(AddSpEffect, 19887)
		end
		if isChangingWeaponRight == FALSE and (c_Style == HAND_RIGHT or c_Style == HAND_RIGHT_BOTH) and env(GetSwordArtID, HAND_RIGHT) == 328 then
			act(AddSpEffect, 19883)
		end
	elseif env(GetSpEffectID, 19874) == TRUE then
		if isChangingWeaponLeft == FALSE and (c_Style == HAND_RIGHT or c_Style == HAND_LEFT_BOTH) and env(GetSwordArtID, HAND_LEFT) == 328 then
			act(AddSpEffect, 19885)
		end
		if isChangingWeaponRight == FALSE and (c_Style == HAND_RIGHT or c_Style == HAND_RIGHT_BOTH) and env(GetSwordArtID, HAND_RIGHT) == 328 then
			act(AddSpEffect, 19881)
		end
	end

	if env(GetSpEffectID, 102380) == TRUE then
		act(AddSpEffect, 102381)
	end

	g_FrameCount = g_FrameCount + 1
end

function CopyLocalMatrix(source, dest)
	local sourceMatrix = hkbGetBoneLocalSpace(source)
	hkbSetBoneLocalSpace(dest, sourceMatrix)
end

function CopyModelMatrix(source, dest)
	local sourceMatrix = hkbGetBoneModelSpace(source)
	hkbSetBoneModelSpace(dest, sourceMatrix)
end

function CalculateFootTarget2(source, YaxisOffset, dest)
	local sourceMatrix = hkbGetBoneModelSpace(dest)
	local sourcePosition = hkbGetBoneModelSpace(source):getTranslation()
	sourcePosition[1] = sourcePosition[1] + YaxisOffset
	sourceMatrix:setTranslation(sourcePosition)
	hkbSetBoneModelSpace(dest, sourceMatrix)
end

function Master_Layer_onGenerate()
	local offset = 0.8659999966621399
	CalculateFootTarget2("L_Foot", offset, "L_Foot_Target2")
	CopyModelMatrix("L_Foot", "L_Foot_Target")
	CalculateFootTarget2("R_Foot", offset, "R_Foot_Target2")
	CopyModelMatrix("R_Foot", "R_Foot_Target")
end

function ModifiersLayer_onGenerate()
	CopyLocalMatrix("Neck", "Collar")
end

----------------------------------------
-- Torrent
----------------------------------------
function Ride_Activate()
end

function Ride_Update()
	if IsEnableFeedAddBlend == TRUE then
		Ride_Feed_Rate = 1
		act(ApplyRideBlend, "Ride_Feed_AddBlend", 1)
	else
		Ride_Feed_Rate = ConvergeValue(0, Ride_Feed_Rate, 4, 4)
		act(ApplyRideBlend, "Ride_Feed_AddBlend", Ride_Feed_Rate)
	end

	if RIDE_ISENABLE_DOUBLEJUMP == FALSE and env(IsMountInFallLoop) == TRUE then
		RIDE_ISENABLE_DOUBLEJUMP = TRUE
	end
end

function Ride_Deactivate()
	if IsNodeActive("Jump_RideOff LayerGenerator") == FALSE then
		act(Dismount)
	end
end

function Ride_NoThrow_Activate()
	SetThrowInvalid()
end

function Ride_NoThrow_Update()
	SetThrowInvalid()

	local hand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end

	SetAttackHand(hand)
	SetGuardHand(hand)
end

function ExecRide()
	if env(IsSummoningRide) == TRUE then
		SetVariable("RideOnSummonTest", 1)
		FireRideEvent("W_RideOn", "W_RideOn", FALSE)
		return TRUE
	elseif env(ActionRequest, ACTION_ARM_RIDEON) == TRUE then
		act(Mounting)
		return TRUE
	end
	return FALSE
end

function FireRideEvent(upper_event, lower_event, lower_only)
	if lower_only == TRUE then
		act(PlayRideAnim, lower_event)
	else
		ExecEventAllBody(upper_event)
		act(PlayRideAnim, lower_event)
	end
end

function FireRideEventNoReset(upper_event, lower_event, lower_only)
	if lower_only == TRUE then
		act(PlayRideAnim, lower_event)
	else
		ExecEventNoReset(upper_event)
		act(PlayRideAnim, lower_event)
	end
end

-- Torrent Dismount
function ExecRideOff(is_force, rideOffAnyway)
	if is_force == FALSE and env(ActionRequest, ACTION_ARM_L3) == FALSE then
		return FALSE
	end
	if is_force == FALSE and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ResetRequest()
		return FALSE
	end

	local unhorseDir = -1

	if env(GetMountReceivedDamageDirection, 2) == TRUE then
		unhorseDir = 2
	elseif env(GetMountReceivedDamageDirection, 3) == TRUE then
		unhorseDir = 3
	elseif env(GetMountReceivedDamageDirection, 1) == TRUE then
		unhorseDir = 1
	end

	if unhorseDir < 0 then
		if rideOffAnyway == FALSE then
			return FALSE
		else
			unhorseDir = 2
		end
	end

	local event = "W_RideOff"
	local event_under = "W_RideOff"

	if env(GetSpEffectID, 19995) == TRUE then
		event = "W_RideDamage_Fall_AbyssalForest"
		event_under = "W_RideDamage_Fall_AbyssalForest"
	elseif GetVariable("MoveSpeedLevel") >= 0.8999999761581421 and rideOffAnyway ~= TRUE then
		event = "W_Jump_RideOff"

		if GetVariable("MoveSpeedLevel") >= 1.5 or 1 <= GetVariable("ToggleDash") then
			event_under = "W_RideOffGallop"
			SetVariable("RideOff_Jump_Speed", 1)
		else
			event_under = "W_RideOffDash"
			SetVariable("RideOff_Jump_Speed", 0)
		end

		local style = c_Style

		if style == HAND_RIGHT then
			SetVariable("JumpAttack_HandCondition", 0)
		elseif style == HAND_RIGHT_BOTH then
			SetVariable("JumpAttack_HandCondition", 1)
		elseif style == HAND_LEFT_BOTH then
			if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW) == TRUE then
				SetVariable("JumpAttack_HandCondition", 4)
			else
				SetVariable("JumpAttack_HandCondition", 1)
			end
		end

		SetVariable("JumpAttackForm", 0)
		SetVariable("JumpUseMotion_Bool", false)
		SetVariable("JumpMotion_Override", 0.009999999776482582)
		SetVariable("JumpAttack_Land", 0)
		SetVariable("SwingPose", 0)
		SetVariable("IsEnableDirectionJumpTAE", true)

		if GetVariable("IsEnableToggleDashTest") == 2 then
			SetVariable("ToggleDash", 0)
		end
	elseif unhorseDir == 2 then
		SetVariable("Int16Variable02", 0)
	elseif unhorseDir == 3 then
		SetVariable("Int16Variable02", 1)
	elseif unhorseDir == 1 then
		SetVariable("Int16Variable02", 2)
	end

	FireRideEvent(event, event_under, FALSE)

	return TRUE
end

function RideReActionFunction()
	local isEnableForceRideOff = FALSE

	if env(IsAutomaticTesting) == TRUE then
		if env(InNoRidingArea) == TRUE and env(IsRidingPcMount) == TRUE and env(IsMountInFallLoop) == TRUE then
			isEnableForceRideOff = TRUE
		end
	elseif (env(InNoRidingArea) == TRUE or env(IsMultiplayer) == TRUE or env(GetSpEffectType, 433) == TRUE) and env(IsRidingPcMount)
		== TRUE and env(IsMountInFallLoop) == TRUE then
		isEnableForceRideOff = TRUE
	end

	if isEnableForceRideOff == TRUE then
		ExecRideOff(TRUE, TRUE)
		if env(GetSpEffectID, 19995) == FALSE then
			act(AddSpEffect, 181)
		end
		return TRUE
	end
	if ExecRideDeath() == TRUE then
		return TRUE
	end
	if ExecRideDamage() == TRUE then
		return TRUE
	end
	if ExecRideEventAnim() == TRUE then
		return TRUE
	end
	return FALSE
end

function ExecRideDeath()
	if env(GetDamageSpecialAttribute, 3) == TRUE then
		SetVariable("IndexRideDeath", RIDE_DEATH_TYPE_STONE)
		FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
		return TRUE
	elseif env(GetHP) <= 0 then
		if env(GetDamageSpecialAttribute, 6) == TRUE or env(GetSpecialAttribute) == 25 then
			SetVariable("IndexRideDeath", RIDE_DEATH_TYPE_MAD)
		else
			SetVariable("IndexRideDeath", RIDE_DEATH_TYPE_COMMON)
		end

		FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
		return TRUE
	elseif env(IsMountDead) <= 0 then
		FireRideEvent("W_RideDamage_Fall", "W_RideDeath", FALSE)
		return TRUE
	end
	return FALSE
end

function ExecRideDamage()
	local damage_level = env(GetDamageLevel)
	local damage_type = env(GetReceivedDamageType)
	local is_damaged = env(HasReceivedAnyDamage)
	local damage_angle = env(GetReceivedDamageDirection)
	local damage_level_under = env(GetMountDamageLevel)
	local damage_type_under = env(GetMountRecievedDamageType)
	local is_damaged_under = env(HasMountReceivedAnyDamage)
	local damage_angle_under = env(GetMountRecievedDamageAngle)

	if damage_type == DAMAGE_TYPE_PARRY then
		FireRideEvent("W_RideDamage_Fall", "W_RideRun_End", FALSE)
		return TRUE
	end
	if damage_type == DAMAGE_TYPE_WALL_RIGHT or damage_type == DAMAGE_TYPE_WALL_LEFT then
		if GetVariable("RideAttackHand") == HAND_LEFT then
			SetVariable("GuardDamageIndex", 2)
		else
			SetVariable("GuardDamageIndex", 0)
		end

		ExecEventAllBody("W_RideRepelledWall")
		return TRUE
	elseif damage_type == DAMAGE_TYPE_GUARDED or damage_type == DAMAGE_TYPE_GUARDED_LEFT then
		Replanning()

		if GetVariable("RideAttackHand") == HAND_LEFT then
			SetVariable("GuardDamageIndex", 2)
		else
			SetVariable("GuardDamageIndex", 0)
		end

		if damage_level == DAMAGE_LEVEL_NONE or damage_level == DAMAGE_LEVEL_MINIMUM or damage_level
			== DAMAGE_LEVEL_SMALL then
			SetVariable("DamageDirection", 2)
			act(SetDamageAnimType, DAMAGE_FLAG_SMALL)
			ExecEventAllBody("W_RideRepelledSmall")
			return TRUE
		else
			act(SetDamageAnimType, DAMAGE_FLAG_LARGE)
			SetVariable("DamageDirection", 2)
			ExecEventAllBody("W_RideRepelledLarge")
			return TRUE
		end
	elseif damage_type == DAMAGE_TYPE_GUARD then
		if env(GetSpEffectID, 175) == TRUE then
			return FALSE
		end
		if env(GetSpEffectID, 176) == TRUE then
			return FALSE
		end
		FireRideEvent("W_Ride_SA_Add_Guard", "W_Ride_SA_Add", FALSE)
		SetVariable("Ride_SA_Add_Blend", 1)
		act(ApplyRideBlend, "Ride_SA_Add_Blend", 1)
		return FALSE
	elseif damage_type == DAMAGE_TYPE_GUARDBREAK then
		act(SetDamageAnimType, DAMAGE_FLAG_LARGE)
		SetVariable("DamageDirection", 2)
		ExecEventAllBody("W_RideRepelledLarge")
		return TRUE
	end
	if env(IsMountFalling) == TRUE then
		FireRideEvent("W_RideFall_Start", "W_RideFall_Start", FALSE)
		return TRUE
	end
	if env(GetPoise) <= 0 and (damage_level > DAMAGE_LEVEL_NONE or damage_level_under > DAMAGE_LEVEL_NONE)
		and (is_damaged == TRUE or is_damaged_under == TRUE) then
		FireRideEvent("W_RideDamage_Fall", "W_RideRun_End", FALSE)
		return TRUE
	end
	if env(GetDamageSpecialAttribute, 5) == TRUE then
		FireRideEvent("W_RideDamage_Fall", "W_RideRun_End", FALSE)
		return TRUE
	end
	if env(GetDamageSpecialAttribute, 6) == TRUE then
		FireRideEvent("W_RideDamageMad", "W_RideRun_End", FALSE)
		Replanning()
		return TRUE
	end
	if env(GetSpEffectType, 32) == TRUE then
		FireRideEvent("W_RideDamageBind_Start", "W_RideDeath", FALSE)
		Replanning()
		return TRUE
	end
	if (env(GetSpecialAttribute) == 5 or env(GetMountSpecialAttribute) == 5) and GetVariable("MoveSpeedLevel") > 1.5 then
		SetVariable("DamageDirection", 2)
		act(ApplyRideBlend, "DamageDirection", 2)
		SetVariable("RideDamageDefaultState", 1)
		act(ApplyRideBlend, "RideDamageDefaultState", 1)
		act(ApplyDamageFlag, DAMAGE_FLAG_MIDDLE)
		Replanning()
		FireRideEvent("W_RideDamageMiddle", "W_Ride_DamageMiddle", FALSE)
		return TRUE
	elseif env(GetSpecialAttribute) == 8 or env(GetMountSpecialAttribute) == 8 then
		SetVariable("DamageDirection", 2)
		act(ApplyRideBlend, "DamageDirection", 2)
		SetVariable("RideDamageDefaultState", 1)
		act(ApplyRideBlend, "RideDamageDefaultState", 1)
		act(ApplyDamageFlag, DAMAGE_FLAG_MIDDLE)
		Replanning()
		FireRideEvent("W_RideDamageMiddle", "W_Ride_DamageMiddle", FALSE)
		return TRUE
	end
	if env(GetDamageSpecialAttribute, 2) == TRUE or env(GetDamageSpecialAttribute, 4) == TRUE then
		if damage_level == DAMAGE_LEVEL_NONE then
			damage_level = DAMAGE_LEVEL_SMALL
		elseif damage_level ~= DAMAGE_LEVEL_SMALL and damage_level ~= DAMAGE_LEVEL_MIDDLE and damage_level
			== DAMAGE_LEVEL_MINIMUM then
		end
	end
	if damage_level <= DAMAGE_LEVEL_NONE and damage_level_under <= DAMAGE_LEVEL_NONE
		and (is_damaged == FALSE and is_damaged_under == FALSE or env(IsPartDamageAdditiveBlendInvalid) == TRUE)
		and (damage_type == DAMAGE_TYPE_INVALID or damage_type == DAMAGE_TYPE_WEAK_POINT or damage_type
			== DAMAGE_LEVEL_MINIMUM)
		and (damage_type_under == DAMAGE_TYPE_INVALID or damage_type_under == DAMAGE_TYPE_WEAK_POINT or damage_type_under
			== DAMAGE_LEVEL_MINIMUM) then
		return FALSE
	end

	SetVariable("BlendRideDamageFire", 0)
	act(ApplyRideBlend, "BlendRideDamageFire", 0)
	SetVariable("Ride_SA_Add_Blend", 0)
	act(ApplyRideBlend, "Ride_SA_Add_Blend", 0)

	if env(GetSpecialAttribute) == 5 or env(GetSpecialAttribute) == 8 or env(GetMountSpecialAttribute) == 5
		or env(GetMountSpecialAttribute) == 8 then
		return FALSE
	end
	if env(GetIsWeakPoint) == TRUE then
		SetVariable("DamageDirection", 2)
		act(ApplyRideBlend, "DamageDirection", 2)
		act(ApplyDamageFlag, DAMAGE_FLAG_WEAK)
		FireRideEvent("W_RideDamageWeakTop", "W_Ride_DamageWeakTop", FALSE)
		Replanning()

		return TRUE
	elseif env(GetMountIsWeakPoint) == TRUE then
		SetVariable("DamageDirection", 2)
		act(ApplyRideBlend, "DamageDirection", 2)
		act(ApplyDamageFlag, DAMAGE_FLAG_WEAK)
		FireRideEvent("W_RideDamageWeakUnder", "W_Ride_DamageWeakUnder", FALSE)
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_EXLARGE or damage_level == DAMAGE_LEVEL_SMALL_BLOW or damage_level
		== DAMAGE_LEVEL_UPPER or damage_level == DAMAGE_LEVEL_EX_BLAST or damage_level == DAMAGE_LEVEL_BREATH
		or damage_level_under == DAMAGE_LEVEL_EXLARGE or damage_level_under == DAMAGE_LEVEL_SMALL_BLOW
		or damage_level_under == DAMAGE_LEVEL_UPPER or damage_level_under == DAMAGE_LEVEL_EX_BLAST or damage_level_under
		== DAMAGE_LEVEL_BREATH then
		local damage_angle_real = damage_angle

		if damage_level <= DAMAGE_LEVEL_NONE then
			damage_angle_real = damage_angle_under
		end

		SetVariable("DamageDirection", damage_angle_real)
		act(ApplyRideBlend, "DamageDirection", damage_angle_real)
		act(ApplyDamageFlag, DAMAGE_FLAG_LARGE_BLOW)
		FireRideEvent("W_RideDamageExLarge", "W_Ride_DamageExLarge", FALSE)
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_LARGE or damage_level == DAMAGE_LEVEL_FLING or damage_level_under
		== DAMAGE_LEVEL_LARGE or damage_level_under == DAMAGE_LEVEL_FLING then
		if env(GetSpecialAttribute) == DAMAGE_ELEMENT_FIRE or env(GetMountSpecialAttribute) == DAMAGE_ELEMENT_FIRE then
			SetVariable("BlendRideDamageFire", 1)
			act(ApplyRideBlend, "BlendRideDamageFire", 1)
			act(ApplyRideBlend, "IndexFireRideDamageVariation", 0)
			FireRideEvent("W_RideFireMiddleDamageBlend_Add", "W_Ride_FireMiddleDamageBlend_Add", FALSE)
		end

		SetVariable("DamageDirection", 2)
		act(ApplyRideBlend, "DamageDirection", 2)
		SetVariable("RideDamageDefaultState", 2)
		act(ApplyRideBlend, "RideDamageDefaultState", 2)
		act(ApplyDamageFlag, DAMAGE_FLAG_LARGE)
		FireRideEvent("W_RideDamageLarge", "W_Ride_DamageLarge", FALSE)
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_MIDDLE or damage_level == DAMAGE_LEVEL_PUSH or damage_level_under
		== DAMAGE_LEVEL_MIDDLE or damage_level_under == DAMAGE_LEVEL_PUSH then
		if env(GetSpecialAttribute) == DAMAGE_ELEMENT_FIRE or env(GetMountSpecialAttribute) == DAMAGE_ELEMENT_FIRE then
			SetVariable("BlendRideDamageFire", 1)
			act(ApplyRideBlend, "BlendRideDamageFire", 1)
			act(ApplyRideBlend, "IndexFireRideDamageVariation", 0)
			FireRideEvent("W_RideFireMiddleDamageBlend_Add", "W_Ride_FireMiddleDamageBlend_Add", FALSE)
		end

		SetVariable("DamageDirection", 2)
		act(ApplyRideBlend, "DamageDirection", 2)
		SetVariable("RideDamageDefaultState", 1)
		act(ApplyRideBlend, "RideDamageDefaultState", 1)
		act(ApplyDamageFlag, DAMAGE_FLAG_MEDIUM)
		FireRideEvent("W_RideDamageMiddle", "W_Ride_DamageMiddle", FALSE)
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_SMALL or damage_level_under == DAMAGE_LEVEL_SMALL then
		if env(GetSpecialAttribute) == DAMAGE_ELEMENT_FIRE or env(GetMountSpecialAttribute) == DAMAGE_ELEMENT_FIRE then
			SetVariable("BlendRideDamageFire", 1)
			act(ApplyRideBlend, "BlendRideDamageFire", 1)
			act(ApplyRideBlend, "IndexFireRideDamageVariation", 0)
			FireRideEvent("W_RideFireSmallDamageBlend_Add", "W_Ride_FireSmallDamageBlend_Add", FALSE)
		end

		SetVariable("DamageDirection", 2)
		act(ApplyRideBlend, "DamageDirection", 2)
		SetVariable("RideDamageDefaultState", 0)
		act(ApplyRideBlend, "RideDamageDefaultState", 0)
		act(ApplyDamageFlag, DAMAGE_FLAG_SMALL)
		FireRideEvent("W_RideDamageSmall", "W_Ride_DamageSmall", FALSE)
		Replanning()

		return TRUE
	elseif damage_level == DAMAGE_LEVEL_NONE or damage_level == DAMAGE_LEVEL_MINIMUM or damage_level_under
		== DAMAGE_LEVEL_NONE or damage_level_under == DAMAGE_LEVEL_MINIMUM then
		local index = 0

		SetVariable("IndexRide_SA_Add_Random", index)
		act(ApplyRideBlend, "IndexRide_SA_Add_Random", index)
		act(ApplyDamageFlag, DAMAGE_FLAG_MINIMUM)
		FireRideEvent("W_Ride_SA_Add", "W_Ride_SA_Add", FALSE)
		SetVariable("Ride_SA_Add_Blend", 1)
		act(ApplyRideBlend, "Ride_SA_Add_Blend", 1)
	end
	return FALSE
end

function RideFallCommonFunction()
	local damage_type = env(GetReceivedDamageType)

	if damage_type == DAMAGE_TYPE_DEATH_FALLING and env(GetSpEffectID, 185) == FALSE then
		FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
		return TRUE
	end
	if env(ActionRequest, 6) == TRUE and env(GetSpEffectID, 100902) == TRUE and RIDE_ISENABLE_DOUBLEJUMP == TRUE then
		local height = env(GetMountFallHeight) / 100
		if env(GetStamina) <= 0 or height > DISABLEJUMP_FALLDIST then
			ResetRequest()
		else
			if env(GetSpEffectID, 102360) == FALSE then
				act(ChangeStamina, STAMINA_REDUCE_RIDE_JUMP)
			end

			if GetVariable("MoveSpeedLevel") >= 1.5 then
				FireRideEvent("W_RideJump2_D", "W_RideJump2_D", FALSE)
			elseif GetVariable("MoveSpeedLevel") >= 0.6000000238418579 then
				FireRideEvent("W_RideJump2_F", "W_RideJump2_F", FALSE)
			else
				FireRideEvent("W_RideJump2_N", "W_RideJump2_N", FALSE)
			end
		end

		RIDE_ISENABLE_DOUBLEJUMP = FALSE
		return TRUE
	end
	return FALSE
end

function RideRequestFunction(ride_move_type, enable_turn, lower_only)
	if env(IsOnMount) == FALSE then
		act(Dismount)
		ExecEventAllBody("W_Idle")

		return TRUE
	end
	if enable_turn == TRUE then
		if GetVariable("MoveSpeedLevel") >= 0.8999999761581421 then
			SetVariable("Int16Variable01", 1)
		else
			SetVariable("Int16Variable01", 0)
		end

		local turn_angle = GetVariable("TurnAngle")

		if math.abs(turn_angle) >= 135 and RIDE_TURN_STATE == 0 then
			if turn_angle < 0 then
				FireRideEvent("W_RideTurn_Left180", "W_RideTurn_Left180", FALSE)
			else
				FireRideEvent("W_RideTurn_Right180", "W_RideTurn_Right180", FALSE)
			end
			return TRUE
		end
	end

	if ExecRideStop(ride_move_type, lower_only) == TRUE then
		if lower_only == FALSE then
			return TRUE
		else
			return FALSE
		end
	end

	local move_speed_level = GetVariable("MoveSpeedLevel")
	local move_angle = GetVariable("MoveAngle")
	local next_ride_move_type = RIDE_MOVE_TYPE_IDLE

	-- Out of Stamina: limit move speed
	if env(GetSpEffectID, 100020) == TRUE and move_speed_level > 1 then
		move_speed_level = 1
	end

	if math.abs(move_angle) <= 45 then
		-- Gallop
		if move_speed_level > 1.5 or GetVariable("IsEnableToggleDashTest") >= 1 and GetVariable("ToggleDash") == 1
			and GetVariable("MoveSpeedLevel") >= 0.8999999761581421 then
			next_ride_move_type = RIDE_MOVE_TYPE_GALLOP
			-- Dash
		elseif move_speed_level > 0.6000000238418579 then
			next_ride_move_type = RIDE_MOVE_TYPE_DASH
			-- Idle
		elseif move_speed_level > 0 then
			next_ride_move_type = RIDE_MOVE_TYPE_WALK
		else
			next_ride_move_type = RIDE_MOVE_TYPE_IDLE
		end
	end

	if ride_move_type ~= next_ride_move_type or env(GetMountSpEffectID, 101008) == TRUE then
		if next_ride_move_type == RIDE_MOVE_TYPE_IDLE then
			if GetVariable("IsEnableToggleDashTest") == 4 then
				SetVariable("ToggleDash", 0)
			end

			if env(GetMountSpEffectID, 101005) == FALSE and env(GetMountSpEffectID, 101006) == FALSE
				and env(GetMountSpEffectID, 101007) == FALSE then
				FireRideEvent("W_RideIdle", "W_RideIdle", lower_only)
			else
				return FALSE
			end
		elseif next_ride_move_type == RIDE_MOVE_TYPE_WALK then
			if GetVariable("IsEnableToggleDashTest") == 4 then
				SetVariable("ToggleDash", 0)
			end
			FireRideEvent("W_RideWalk", "W_RideWalk", lower_only)
		elseif next_ride_move_type == RIDE_MOVE_TYPE_DASH then
			if env(GetSpEffectID, 100901) == TRUE
				and (ride_move_type == RIDE_MOVE_TYPE_IDLE or ride_move_type == RIDE_MOVE_TYPE_OTHER) and lower_only
				== TRUE then
				FireRideEvent("W_RideDash", "W_RideRun", lower_only)
			else
				FireRideEvent("W_RideDash", "W_RideDash", lower_only)
			end
		elseif env(GetSpEffectID, 100901) == TRUE
			and (ride_move_type == RIDE_MOVE_TYPE_IDLE or ride_move_type == RIDE_MOVE_TYPE_OTHER) and lower_only == TRUE then
			FireRideEvent("W_RideDash", "W_RideRun", lower_only)
		else
			FireRideEvent("W_RideGallop", "W_RideGallop", lower_only)
		end

		if lower_only == FALSE then
			return TRUE
		end
	end
	return FALSE
end

function ExecRideStop(ride_move_type, lower_only)
	local move_speed_level = GetVariable("MoveSpeedLevel")

	if move_speed_level > 0 then
		return FALSE
	end
	if env(GetMountSpEffectID, 101005) == TRUE or env(GetMountSpEffectID, 101006) == TRUE
		or env(GetMountSpEffectID, 101007) == TRUE then
		return FALSE
	end

	local stop_speed_type = ride_move_type

	if ride_move_type == RIDE_MOVE_TYPE_IDLE or ride_move_type == RIDE_MOVE_TYPE_OTHER then
		if env(GetMountSpEffectID, 101000) == TRUE then
			stop_speed_type = RIDE_MOVE_TYPE_WALK
		elseif env(GetMountSpEffectID, 101001) == TRUE then
			stop_speed_type = RIDE_MOVE_TYPE_DASH
		elseif env(GetMountSpEffectID, 101002) == TRUE then
			stop_speed_type = RIDE_MOVE_TYPE_GALLOP
		end
	end

	if stop_speed_type == RIDE_MOVE_TYPE_IDLE or stop_speed_type == RIDE_MOVE_TYPE_OTHER then
		return FALSE
	end
	if stop_speed_type == RIDE_MOVE_TYPE_WALK then
		FireRideEvent("W_RideWalk_End", "W_RideWalk_End", lower_only)
	elseif stop_speed_type == RIDE_MOVE_TYPE_DASH then
		FireRideEvent("W_RideDash_End", "W_RideDash_End", lower_only)
	else
		FireRideEvent("W_RideGallop_End", "W_RideGallop_End", lower_only)
	end
	return TRUE
end

function ExecRideAttack(r1, r2, l1, l2)
	local attackHand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		attackHand = HAND_LEFT
	end

	local is_arrow = GetEquipType(attackHand, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW,
		WEAPON_CATEGORY_CROSSBOW)
	local is_staff = GetEquipType(attackHand, WEAPON_CATEGORY_STAFF)
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, attackHand)
	local is_weaponStaff = FALSE
	if IsWeaponCatalyst(sp_kind) == TRUE then
		is_weaponStaff = TRUE
	end

	if env(ActionDuration, ACTION_ARM_ACTION) > 0 then
		return FALSE
	end
	if env(GetStamina) < 0 then
		ResetRequest()
		return FALSE
	end
	if env(ActionRequest, 0) == TRUE and is_staff == FALSE or env(ActionRequest, 1) == TRUE and is_staff == TRUE then
		act(ResetInputQueue)
		SetVariable("RideAttackHand", HAND_RIGHT)
		if is_arrow == TRUE then
			if GetEquipType(attackHand, WEAPON_CATEGORY_CROSSBOW) == TRUE and env(GetBoltLoadingState, attackHand)
				== FALSE then
				if attackHand == HAND_LEFT then
					ExecEventAllBody("W_RideAttackCrossbowLeftReload")
				else
					ExecEventAllBody("W_RideAttackCrossbowRightReload")
				end
				return TRUE
			end
			g_ArrowSlot = 0
			act(ChooseBowAndArrowSlot, 0)

			if env(IsOutOfAmmo, attackHand) == TRUE then
				ExecEventAllBody("W_RideNoArrow")
				return TRUE
			end
			ExecEventAllBody("W_RideAttackArrowStart")
			return TRUE
		end
		ExecEventAllBody(r1)
	elseif env(ActionRequest, 1) == TRUE and is_weaponStaff == FALSE then
		act(ResetInputQueue)
		SetVariable("RideAttackHand", HAND_RIGHT)

		if is_arrow == TRUE then
			if GetEquipType(attackHand, WEAPON_CATEGORY_CROSSBOW) == TRUE and env(GetBoltLoadingState, attackHand)
				== FALSE then
				if attackHand == HAND_LEFT then
					ExecEventAllBody("W_RideAttackCrossbowLeftReload")
				else
					ExecEventAllBody("W_RideAttackCrossbowRightReload")
				end
				return TRUE
			end
			g_ArrowSlot = 1
			act(ChooseBowAndArrowSlot, 1)
			if env(IsOutOfAmmo, attackHand) == TRUE then
				ExecEventAllBody("W_RideNoArrow")
				return TRUE
			end
			ExecEventAllBody("W_RideAttackArrowStart")
			return TRUE
		elseif GetEquipType(attackHand, WEAPON_CATEGORY_STAFF) == TRUE then
			return FALSE
		end

		ExecEventAllBody(r2)
	elseif env(ActionRequest, 2) == TRUE or env(ActionRequest, 3) == TRUE and is_staff == TRUE then
		act(ResetInputQueue)
		SetVariable("RideAttackHand", HAND_LEFT)

		if is_arrow == TRUE then
			return FALSE
		end

		ExecEventAllBody(l1)
	elseif env(ActionRequest, 3) == TRUE then
		act(ResetInputQueue)
		SetVariable("RideAttackHand", HAND_LEFT)

		if is_arrow == TRUE then
			return FALSE
		end

		ExecEventAllBody(l2)
	else
		return FALSE
	end

	SetInterruptType(INTERRUPT_FINDATTACK)
	return TRUE
end

function ExecRideItem()
	if c_HasActionRequest == FALSE then
		return FALSE
	end

	local hand = HAND_RIGHT
	local kind = env(GetEquipWeaponCategory, hand)
	if kind == WEAPON_CATEGORY_BACKHAND_SWORD then
		SetVariable("ItemWeaponType", 1)
	elseif kind == WEAPON_CATEGORY_DUELING_SHIELD then
		SetVariable("ItemWeaponType", 2)
	else
		SetVariable("ItemWeaponType", 0)
	end

	if env(ActionRequest, ACTION_ARM_USE_ITEM) == FALSE then
		return FALSE
	end
	if env(IsItemUseMenuOpened) == TRUE then
		return FALSE
	end
	if env(IsItemUseMenuOpening) == TRUE then
		ResetRequest()
		act(OpenMenuWhenUsingItem)
		return TRUE
	end

	act(UseItemDecision)
	local item_type = env(GetItemAnimType)
	local is_combo = env(GetSpEffectID, 100800)

	if is_combo == TRUE and item_type ~= ITEM_NIGHT_BELL then
		return FALSE
	end
	local pre_item_type = GetVariable("PreItemType")
	SetVariable("PreItemType", item_type)

	if item_type == ITEM_DRINK then
		if env(GetStateChangeType, CONDITION_TYPE_NO_EST) == TRUE then
			ExecEventAllBody("W_RideItemDrinkNothing")
		elseif IsNodeActive("RideItemDrinking_CMSG") == TRUE and pre_item_type == ITEM_DRINK then
			ExecEventAllBody("W_RideItemDrinking")
		else
			ExecEventAllBody("W_RideItemDrinkStart")
		end
	elseif item_type == ITEM_DRINK_MP then
		if env(GetStateChangeType, CONDITION_TYPE_NO_EST) == TRUE then
			ExecEventAllBody("W_RideItemDrinkNothing")
		elseif IsNodeActive("RideItemDrinking_CMSG") == TRUE and pre_item_type == ITEM_DRINK_MP then
			ExecEventAllBody("W_RideItemDrinking")
		else
			ExecEventAllBody("W_RideItemDrinkStart")
		end
	elseif item_type == ITEM_SUMMONHORSE then
		ExecRideOff(TRUE, FALSE)
	elseif item_type == ITEM_MEGANE then
		if env(GetStateChangeType, 15) == TRUE then
			ExecEventAllBody("W_RideItemMeganeEnd")
		else
			ExecEventAllBody("W_RideItemMeganeStart")
		end
	elseif item_type == 27 then
		if env(GetSpEffectID, 3245) == TRUE then
			ExecEventAllBody("W_RideItemLanternOff")
		else
			SetVariable("IndexItemUseAnim", item_type)
			ExecEventAllBody("W_RideItemOneShot")
		end
	elseif item_type == ITEM_ELIXIR then
		ExecEventAllBody("W_RideItemElixir")
	elseif item_type == ITEM_QUICK_THROW_KNIFE then
		if IsNodeActive("RideItemQuick1_CMSG") == TRUE or IsNodeActive("RideItemQuick3_CMSG") == TRUE then
			ExecEventAllBody("W_RideItemQuick2")
		elseif IsNodeActive("RideItemQuick2_CMSG") == TRUE then
			ExecEventAllBody("W_RideItemQuick3")
		else
			ExecEventAllBody("W_RideItemQuick1")
		end
	elseif item_type == ITEM_NIGHT_BELL then
		if is_combo == TRUE then
			ExecEventAllBody("W_RideItemCombo")
		else
			SetVariable("IndexItemUseAnim", item_type)
			ExecEventAllBody("W_RideItemOneShot")
		end
	elseif item_type == ITEM_NO_DRINK then
		if IsNodeActive("RideItemDrinking_CMSG") == TRUE then
			ExecEventAllBody("W_RideItemDrinkEmpty")
		else
			ExecEventAllBody("W_RideItemDrinkStart")
		end
	elseif item_type == ITEM_INVALID then
		ExecEventAllBody("W_RideItemInvalid")
	else
		SetVariable("IndexItemUseAnim", item_type)
		ExecEventAllBody("W_RideItemOneShot")
	end

	act(ApplyRideBlend, "Ride_Feed_AddBlend", 0)
	act(SetIsItemAnimationPlaying)
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()

	return TRUE
end

function ExecRideMagic()
	if ExecMagic(QUICKTYPE_NORMAL, ALLBODY, TRUE) == TRUE then
		return TRUE
	else
		return FALSE
	end
end

function ExecRideGesture()
	if c_HasActionRequest == FALSE then
		return FALSE
	end
	if env(ActionRequest, ACTION_ARM_GESTURE) == FALSE then
		return FALSE
	else
		ResetRequest()
		return FALSE
	end

	local request = env(GetGestureRequestNumber)

	if request == INVALID then
		return FALSE
	end

	local isloop = FALSE
	local upper_only = TRUE

	if request == 9 then
	elseif request == 1 then
		upper_only = FALSE
	end

	if isloop == TRUE then
		SetVariable("IndexGesture", request)
		ExecEventAllBody("W_RideGesture")
		return TRUE
	elseif upper_only == FALSE then
		SetVariable("IndexGesture", request)
		act(ApplyRideBlend, "IndexGesture", request)
		FireRideEvent("W_RideGesture", "W_RideGesture")
	else
		SetVariable("IndexGesture", request)
		ExecEventAllBody("W_RideGestureUpper")
		return TRUE
	end
	return FALSE
end

function ExecRideWeaponChange(blend_type)
	local startkind = WEAPON_CHANGE_REQUEST_INVALID
	local endKind = WEAPON_CHANGE_REQUEST_INVALID

	if env(ActionRequest, ACTION_ARM_CHANGE_WEAPON_R) == TRUE then
		startkind = GetWeaponChangeType(HAND_RIGHT)
		endKind = GetWeaponChangeType(HAND_RIGHT)
	elseif env(ActionRequest, ACTION_ARM_CHANGE_WEAPON_L) == TRUE then
		if c_Style == HAND_LEFT_BOTH then
			startkind = GetWeaponChangeType(HAND_LEFT) + 4
			endKind = GetWeaponChangeType(HAND_RIGHT) + 8
		else
			startkind = GetWeaponChangeType(HAND_LEFT)
			endKind = GetWeaponChangeType(HAND_LEFT)
		end
	else
		return FALSE
	end

	if startkind == WEAPON_CHANGE_REQUEST_INVALID then
		return FALSE
	end
	if env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE then
		ResetRequest()
		return FALSE
	end
	SetVariable("WeaponChangeType", startkind)
	SetVariable("RideWeaponChangeEndType", endKind)
	ExecEventAllBody("W_RideWeaponChangeStart")
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()
	return TRUE
end

function ExecRideHandChange(hand, is_force)
	if is_force == FALSE then
		if c_HasActionRequest == FALSE or env(IsPrecisionShoot) == TRUE then
			return FALSE
		end
		if env(IsCOMPlayer) == TRUE then
			if env(ActionRequest, ACTION_ARM_CHANGE_STYLE_R) == TRUE then
			elseif env(ActionRequest, ACTION_ARM_CHANGE_STYLE_L) == TRUE then
				hand = HAND_LEFT
			else
				return FALSE
			end
		elseif env(ActionDuration, ACTION_ARM_ACTION) <= 0 then
			return FALSE
		elseif env(ActionRequest, ACTION_ARM_R1) == TRUE or env(ActionRequest, ACTION_ARM_R2) == TRUE then
			if c_Style == HAND_RIGHT or c_Style == HAND_RIGHT_BOTH then
				hand = HAND_LEFT
			else
				hand = HAND_RIGHT
			end
		elseif env(ActionRequest, ACTION_ARM_L1) == TRUE or env(ActionRequest, ACTION_ARM_L2) == TRUE then
			if c_Style == HAND_RIGHT or c_Style == HAND_RIGHT_BOTH then
				hand = HAND_LEFT
			else
				hand = HAND_RIGHT
			end
		else
			return FALSE
		end
	end

	if env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE then
		ResetRequest()
		return FALSE
	end

	local style = c_Style
	local kind = GetHandChangeType(HAND_RIGHT)
	local leftKind = GetHandChangeType(HAND_LEFT)
	local sp_kind_L = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)
	local sp_kind_R = env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT)

	if style == HAND_RIGHT or style == HAND_RIGHT_BOTH then
		if hand == HAND_RIGHT then
			return FALSE
		else
			if env(IsTwoHandPossible, HAND_LEFT) == FALSE then
				return FALSE
			end
			local firstKind = RIDE_RIGHT_TO_WAIST
			local endKind = RIDE_BOTHLEFT_FROM_WAIST
			if kind == WEAPON_CHANGE_REQUEST_RIGHT_WAIST then
				firstKind = RIDE_RIGHT_TO_WAIST
			elseif kind == WEAPON_CHANGE_REQUEST_RIGHT_BACK then
				firstKind = RIDE_RIGHT_TO_BACK
			elseif kind == WEAPON_CHANGE_REQUEST_RIGHT_SHOULDER then
				firstKind = RIDE_RIGHT_TO_SHOULDER
			else
				firstKind = RIDE_RIGHT_TO_SPEAR
			end

			if leftKind == WEAPON_CHANGE_REQUEST_LEFT_WAIST then
				endKind = RIDE_BOTHLEFT_FROM_WAIST
			elseif leftKind == WEAPON_CHANGE_REQUEST_LEFT_BACK then
				endKind = RIDE_BOTHLEFT_FROM_BACK
			elseif leftKind == WEAPON_CHANGE_REQUEST_LEFT_SHOULDER then
				endKind = RIDE_BOTHLEFT_FROM_SHOULDER
			else
				endKind = RIDE_BOTHLEFT_FROM_SPEAR
			end

			act(DebugLogOutput, "RideHandChange ToBothLeft start=" .. firstKind .. " end" .. endKind)
			SetHandChangeStyle(firstKind, endKind)
			act(Unknown9999, 2)
		end
	elseif style == HAND_LEFT_BOTH then
		local firstKind = RIDE_LEFT_TO_WAIST
		local endKind = RIDE_RIGHT_FROM_LEFTWAIST_FROM_MIDDLE
		if leftKind == WEAPON_CHANGE_REQUEST_LEFT_WAIST then
			firstKind = RIDE_LEFT_TO_WAIST
		elseif leftKind == WEAPON_CHANGE_REQUEST_LEFT_BACK then
			firstKind = RIDE_LEFT_TO_BACK
		elseif leftKind == WEAPON_CHANGE_REQUEST_LEFT_SHOULDER then
			firstKind = RIDE_LEFT_TO_SHOULDER
		else
			firstKind = RIDE_LEFT_TO_SPEAR
		end

		if kind == WEAPON_CHANGE_REQUEST_RIGHT_WAIST then
			endKind = RIDE_RIGHT_FROM_LEFTWAIST_FROM_MIDDLE
		elseif kind == WEAPON_CHANGE_REQUEST_RIGHT_BACK then
			endKind = RIDE_RIGHT_FROM_RIGHTBACK_FROM_MIDDLE
		elseif kind == WEAPON_CHANGE_REQUEST_RIGHT_SHOULDER then
			endKind = RIDE_RIGHT_FROM_RIGHTSHOULDER_FROM_MIDDLE
		else
			endKind = RIDE_RIGHT_FROM_RIGHTSPEAR_FROM_MIDDLE
		end

		SetHandChangeStyle(firstKind, endKind)
		act(Unknown9999, 1)
	end

	ExecEventAllBody("W_RideHandChangeStart")
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	SetAIActionState()

	return TRUE
end

function RideWeaponChangeStart_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideWeaponChangeStart_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)

	if RideReActionFunction() == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		ExecEventAllBody("W_RideWeaponChangeEnd")
	end

	local lower_only = TRUE

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, FALSE, lower_only) == TRUE then
		return
	end
end

function RideWeaponChangeStart_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideWeaponChangeEnd_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideWeaponChangeEnd_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)

	if RideReActionFunction() == TRUE then
		return
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE
	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideWeaponChangeEnd_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideHandChangeStart_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideHandChangeStart_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, FALSE, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventAllBody("W_RideHandChangeEnd")
		return
	end
end

function RideHandChangeStart_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideHandChangeEnd_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideHandChangeEnd_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	if RideReActionFunction() == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideHandChangeEnd_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function IsEnableRideAttackHard2(hand)
	local style = c_Style

	if style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end

	local kind = env(GetEquipWeaponCategory, hand)

	if kind == WEAPON_CATEGORY_RAPIER or kind == WEAPON_CATEGORY_LARGE_RAPIER then
		return TRUE
	else
		return FALSE
	end
end

function RideGesture_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(MovementRequest) == TRUE and GetVariable("MoveSpeedLevel") > 0
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
		return
	end
end

function RideGestureUpper_onUpdate()
	SetAIActionState()

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideMagicLaunch_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(IsAnimEndBySkillCancel) == TRUE or env(IsAnimEnd, 0) == TRUE then
		ExecEventAllBody("W_RideMagicFire")
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideMagicLaunch_Upper_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(IsAnimEndBySkillCancel) == TRUE or env(IsAnimEnd, 0) == TRUE then
		ExecEventAllBody("W_RideMagicFire")
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideMagicFire_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local wep_hand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		wep_hand = HAND_LEFT
	end

	local buttonR = ACTION_ARM_R1
	local buttonL = ACTION_ARM_L1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)

	if IsWeaponCatalyst(sp_kind) == TRUE then
		buttonR = ACTION_ARM_R2
		buttonL = ACTION_ARM_L2
	end

	if env(GetSpEffectID, 100610) == TRUE
		and (env(ActionDuration, buttonR) <= 0 and env(ActionDuration, buttonL) <= 0 or env(IsMagicUseable, wep_hand, 1)
			== FALSE) then
		ExecEventAllBody("W_RideMagicFireCancel")
		return
	end
	if CheckIfHoldMagic() == TRUE and (env(IsAnimEndBySkillCancel) == TRUE or env(IsAnimEnd, 0) == TRUE) then
		if env(ActionDuration, buttonR) > 0 then
			ExecEventAllBody("W_RideMagicLoop")
			return
		else
			ExecEventAllBody("W_RideMagicFireCancel")
			return
		end
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideMagicLoop_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local wep_hand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		wep_hand = HAND_LEFT
	end

	local buttonR = ACTION_ARM_R1
	local buttonL = ACTION_ARM_L1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)

	if IsWeaponCatalyst(sp_kind) == TRUE then
		buttonR = ACTION_ARM_R2
		buttonL = ACTION_ARM_L2
	end

	if env(ActionDuration, buttonR) <= 0 and env(ActionDuration, buttonL) <= 0 and env(ActionDuration, buttonL) <= 0
		or env(IsMagicUseable, wep_hand, 1) == FALSE or env(GetStamina) <= 0 then
		local magic_index = env(GetMagicAnimType)
		if magic_index == MAGIC_REQUEST_EX_LARGE_ARROW then
			ExecEventAllBody("W_RideMagicFireCombo1Cancel")
		else
			ExecEventAllBody("W_RideMagicFireCancel")
		end
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideMagicFireCancel_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideMagicFireCombo1_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local wep_hand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		wep_hand = HAND_LEFT
	end

	local buttonR = ACTION_ARM_R1
	local buttonL = ACTION_ARM_L1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		buttonR = ACTION_ARM_R2
		buttonL = ACTION_ARM_L2
	end

	if env(GetSpEffectID, 100610) == TRUE
		and (env(ActionDuration, buttonR) <= 0 and env(ActionDuration, buttonL) <= 0 or env(IsMagicUseable, wep_hand, 1)
			== FALSE) then
		ExecEventAllBody("W_RideMagicFireCombo1Cancel")
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideMagicFireCombo1Cancel_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideMagicFireCombo2_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local wep_hand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		wep_hand = HAND_LEFT
	end

	local buttonR = ACTION_ARM_R1
	local buttonL = ACTION_ARM_L1
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		buttonR = ACTION_ARM_R2
		buttonL = ACTION_ARM_L2
	end

	if env(GetSpEffectID, 100610) == TRUE
		and (env(ActionDuration, buttonR) <= 0 and env(ActionDuration, buttonL) <= 0 or env(IsMagicUseable, wep_hand, 1)
			== FALSE) then
		ExecEventAllBody("W_RideMagicFireCombo2Cancel")
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideMagicFireCombo2Cancel_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideMagicInvalid_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideItemDrinkStart_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemDrinkStart_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local isEnd = env(IsAnimEnd, 1)

	if env(GetEventEzStateFlag, 0) == TRUE or isEnd == TRUE then
		local item_type = env(GetItemAnimType)
		if item_type ~= ITEM_NO_DRINK then
			ExecEventNoReset("W_RideItemDrinking")
			return
		elseif item_type == ITEM_NO_DRINK and isEnd == TRUE then
			ExecEventNoReset("W_RideItemDrinkEmpty")
			return
		end
	end

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end
	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideItemDrinking_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemDrinking_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideItemDrinkEnd")
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideItemDrinkEnd_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemDrinkEnd_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 1) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideItemDrinkEmpty_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemDrinkEmpty_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemInvalid_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemInvalid_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 1) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end
	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemDrinkNothing_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemDrinkNothing_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemWhistle_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemWhistle_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemElixir_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemElixir_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemHorn_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemHorn_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemQuick1_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemQuick1_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 1) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end
	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemQuick2_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemQuick2_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 1) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemQuick3_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemQuick3_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 1) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemOneShot_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemOneShot_onUpdate()
	if GetVariable("PreItemType") == ITEM_HORSE_FEED then
		IsEnableFeedAddBlend = TRUE
	end

	act(SetIsItemAnimationPlaying)
	SetAIActionState()

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	local item_type = env(GetItemAnimType)

	if item_type == ITEM_DRAGONTHROWSPEAR and env(ActionDuration, ACTION_ARM_USE_ITEM) <= 0
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEvent("W_RideItemDragonThrowSpearCancel")
		return
	end

	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemOneShot_onDeactivate()
	IsEnableFeedAddBlend = FALSE
end

function RideItemDragonThrowSpearCancel_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemDragonThrowSpearCancel_onUpdate()
	act(SetIsItemAnimationPlaying)
	SetAIActionState()

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end

	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemLanternOff_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemLanternOff_onUpdate()
	act(SetIsItemAnimationPlaying)
	SetAIActionState()

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemCombo_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideItemCombo_onUpdate()
	act(SetIsItemAnimationPlaying)
	SetAIActionState()

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideItemMeganeStart_onUpdate()
	act(SetIsItemAnimationPlaying)
	SetAIActionState()

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideItemMeganeLoop_onUpdate()
	SetAIActionState()
	if env(GetStateChangeType, 15) == FALSE then
		act(SetIsItemAnimationPlaying)
	end

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideItemMeganeEnd_onUpdate()
	SetAIActionState()
	act(SetIsItemAnimationPlaying)

	if RideReActionFunction() == TRUE then
		return
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventNoReset("W_RideIdle")
	end
end

function RideAdjust_onUpdate()
	act(SetAllowedThrowDefenseType, 255)

	if env(IsMovingOnMount) == TRUE then
		FireRideEvent("W_RideOn", "W_RideOn", FALSE)
		return TRUE
	elseif env(IsIdleOnMount) == TRUE then
		ExecEventAllBody("W_Idle")
		return TRUE
	end
end

function RideAdjustFromCalling_onUpdate()
	act(SetAllowedThrowDefenseType, 255)

	if env(IsMovingOnMount) == TRUE then
		if GetVariable("RideOnSummonTest") == 1 then
			FireRideEvent("W_RideOn", "W_RideOn", FALSE)
		else
			ExecEventAllBody("W_RideOn")
		end
		return TRUE
	elseif env(IsIdleOnMount) == TRUE then
		ExecEventAllBody("W_Idle")
		return TRUE
	end
end

function RideOn_onUpdate()
	act(ApplyRideBlend, "AddBlend02", 0)
	Ride_HeadDown_Rate = 0
	act(SetAllowedThrowDefenseType, 255)
	SetAIActionState()
	SetVariable("Int16Variable01", 0)
	local lower_only = TRUE

	if env(IsMoveCancelPossible) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
	elseif env(GetEventEzStateFlag, 0) ~= TRUE then
		return
	end

	local move_speed_level = GetVariable("MoveSpeedLevel")
	local move_angle = GetVariable("MoveAngle")
	local next_ride_move_type = RIDE_MOVE_TYPE_IDLE

	if math.abs(move_angle) <= 45 then
		if move_speed_level > 1.5 or GetVariable("IsEnableToggleDashTest") >= 1 and GetVariable("ToggleDash") == 1
			and GetVariable("MoveSpeedLevel") >= 0.8999999761581421 then
			next_ride_move_type = RIDE_MOVE_TYPE_GALLOP
		elseif move_speed_level > 0.6000000238418579 then
			next_ride_move_type = RIDE_MOVE_TYPE_DASH
		elseif move_speed_level > 0 then
			next_ride_move_type = RIDE_MOVE_TYPE_WALK
		else
			next_ride_move_type = RIDE_MOVE_TYPE_IDLE
		end
	end

	if next_ride_move_type == RIDE_MOVE_TYPE_IDLE then
		if lower_only == FALSE then
			FireRideEvent("W_RideIdle", "W_RideIdle", lower_only)
		end
	elseif next_ride_move_type == RIDE_MOVE_TYPE_WALK then
		FireRideEvent("W_RideWalk", "W_RideWalk", lower_only)
	elseif next_ride_move_type == RIDE_MOVE_TYPE_DASH then
		FireRideEvent("W_RideDash", "W_RideDash", lower_only)
	else
		FireRideEvent("W_RideGallop", "W_RideGallop", lower_only)
	end
end

function RideOnDash_onUpdate()
	act(SetAllowedThrowDefenseType, 255)
	SetAIActionState()
	SetVariable("Int16Variable01", 0)
	local lower_only = TRUE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
	elseif env(GetEventEzStateFlag, 0) ~= TRUE then
		return
	end

	local move_speed_level = GetVariable("MoveSpeedLevel")
	local move_angle = GetVariable("MoveAngle")
	local next_ride_move_type = RIDE_MOVE_TYPE_IDLE

	if math.abs(move_angle) <= 45 then
		if move_speed_level > 1.5 or GetVariable("IsEnableToggleDashTest") >= 1 and GetVariable("ToggleDash") == 1
			and GetVariable("MoveSpeedLevel") >= 0.8999999761581421 then
			next_ride_move_type = RIDE_MOVE_TYPE_GALLOP
		elseif move_speed_level > 0.6000000238418579 then
			next_ride_move_type = RIDE_MOVE_TYPE_DASH
		elseif move_speed_level > 0 then
			next_ride_move_type = RIDE_MOVE_TYPE_WALK
		else
			next_ride_move_type = RIDE_MOVE_TYPE_IDLE
		end
	end

	if next_ride_move_type == RIDE_MOVE_TYPE_IDLE then
		if lower_only == FALSE then
			FireRideEvent("W_RideIdle", "W_RideIdle", lower_only)
		end
	elseif next_ride_move_type == RIDE_MOVE_TYPE_WALK then
		FireRideEvent("W_RideWalk", "W_RideWalk", lower_only)
	elseif next_ride_move_type == RIDE_MOVE_TYPE_DASH then
		FireRideEvent("W_RideDash", "W_RideDash", lower_only)
	else
		FireRideEvent("W_RideGallop", "W_RideGallop", lower_only)
	end
end

function RideOff_onUpdate()
	act(SetAllowedThrowDefenseType, 0)
	act(SetAllowedThrowAttackType, 1)
	SetAIActionState()
	SetVariable("Int16Variable01", 0)

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", QUICKTYPE_NORMAL) == TRUE then
		act(Dismount)
		return
	end
	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		act(Dismount)
		ExecEventAllBody("W_Idle")
		return TRUE
	end
end

function RideIdle_onActivate()
	act(Wait)
end

function RideIdle_onUpdate()
	act(Wait)
	SetVariable("Int16Variable01", 0)
	SetEnableAimMode()

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if RideRequestFunction(RIDE_MOVE_TYPE_IDLE, TRUE, FALSE) == TRUE then
		return
	end
	if GetVariable("IsEnableToggleDashTest") >= 1 then
		SetVariable("ToggleDash", 0)
	end
end

function RideWalk_onUpdate()
	act(Wait)
	SetEnableAimMode()

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if RideRequestFunction(RIDE_MOVE_TYPE_WALK, TRUE, FALSE) == TRUE then
		return
	end
	if GetVariable("IsEnableToggleDashTest") >= 1 then
		SetVariable("ToggleDash", 0)
	end
end

function RideWalk_End_onUpdate()
	act(Wait)
	SetEnableAimMode()

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_IDLE, TRUE, FALSE) == TRUE then
		return
	end
end

function RideDash_onUpdate()
	act(Wait)
	SetEnableAimMode()

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if RideRequestFunction(RIDE_MOVE_TYPE_DASH, TRUE, FALSE) == TRUE then
		return
	end
	if GetVariable("IsEnableToggleDashTest") >= 1 then
		SetVariable("ToggleDash", 0)
	end
end

-- Initial Movement after "O" Press (approx 6 seconds)
function RideDashAccelerate_onUpdate()
	act(Wait)
	SetEnableAimMode()

	if env(GetStamina) <= 0 then
		act(AddSpEffect, 100020)
	end

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if ExecRideStop(RIDE_MOVE_TYPE_OTHER, FALSE) == TRUE then
		return
	end
	if (env(IsMoveCancelPossible) == TRUE or env(IsAnimEnd, 0) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

-- Initial Movement after secondary "O" Press during Dash (approx 6 seconds)
function RideDashAccelerateContinue_onUpdate()
	act(Wait)
	SetEnableAimMode()

	if env(GetStamina) <= 0 then
		act(AddSpEffect, 100020)
	end

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if ExecRideStop(RIDE_MOVE_TYPE_OTHER, FALSE) == TRUE then
		return
	end
	if (env(IsMoveCancelPossible) == TRUE or env(IsAnimEnd, 0) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function RideMoveStaminaConsume()
	if env(IsOnMount) == FALSE then
		return
	end
	if env(GetStamina) <= 0 then
		act(AddSpEffect, 100020)
	end

	-- Gallop
	if env(GetMountSpEffectID, 101002) == TRUE then
		act(SetStaminaRecoveryDisabled)
		local dT = GetDeltaTime()
		dash_dt_sum = dash_dt_sum + dT

		if dash_dt_sum > 0.06499999761581421 then
			dash_dt_sum = 0
			if env(GetSpEffectID, 102360) == FALSE then
				act(ChangeStamina, -1)
			end
		end
	end
end

function RideDash_End_onUpdate()
	act(Wait)
	SetEnableAimMode()

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_IDLE, TRUE, FALSE) == TRUE then
		return
	end
end

-- Sustained Movement after "O" Press
function RideGallop_onUpdate()
	act(Wait)
	SetEnableAimMode()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if RideRequestFunction(RIDE_MOVE_TYPE_GALLOP, TRUE, FALSE) == TRUE then
		return
	end
	if GetVariable("IsEnableToggleDashTest") >= 1 then
	end
end

function RideGallop_End_onUpdate()
	act(Wait)
	SetEnableAimMode()

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_IDLE, TRUE, FALSE) == TRUE then
		return
	end
end

function RideDamage_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if (env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function RideDamage_M_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if (env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function RideDamage_H_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if (env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function RideRepelledWall_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideRepelledSmall_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideRepelledLarge_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideDamageSmall_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if (env(MovementRequest) == TRUE or env(IsAnimEnd, 1) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function RideDamageMiddle_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if (env(MovementRequest) == TRUE or env(IsAnimEnd, 1) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function RideDamageLarge_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if (env(MovementRequest) == TRUE or env(IsAnimEnd, 1) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function RideDamageExLarge_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if (env(MovementRequest) == TRUE or env(IsAnimEnd, 1) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function RideDamageWeakTop_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if (env(MovementRequest) == TRUE or env(IsAnimEnd, 1) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function RideDamageWeakUnder_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if (env(MovementRequest) == TRUE or env(IsAnimEnd, 1) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function Ride_SA_Add_Default_onUpdate()
	SetVariable("Ride_SA_Add_Blend", 0)
	act(ApplyRideBlend, "BlendRidden_SA_Add", 0)
end

function RideFireDamageBlend_Default_onUpdate()
	SetVariable("BlendRideDamageFire", 0)
	act(ApplyRideBlend, "BlendRiddenDamageFire", 0)
end

function RideDamage_Fall_onUpdate()
	act(SetAllowedThrowDefenseType, 0)
	act(SetAllowedThrowAttackType, 1)
	SetAIActionState()
	SetVariable("Int16Variable01", 0)
	act(Dismount)

	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return TRUE
	end
	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		ExecEventAllBody("W_Idle")
		return
	end
end

function RideDamage_Fall_AbyssalForest_onUpdate()
	act(SetAllowedThrowDefenseType, 0)
	act(SetAllowedThrowAttackType, 1)
	SetAIActionState()
	SetVariable("Int16Variable01", 0)

	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return TRUE
	end

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		ExecEventAllBody("W_Idle")
		return
	end
end

function RideDamage_Fall_AbyssalForest_onDeactivate()
	act(Dismount)
end

function RideDamageMad_onUpdate()
	act(SetAllowedThrowDefenseType, 0)
	act(SetAllowedThrowAttackType, 1)
	SetAIActionState()
	SetVariable("Int16Variable01", 0)

	if env(GetSpecialAttribute) == 25 and 0 >= env(GetHP) and env(IsOnMount) == TRUE then
		SetVariable("IndexRideDeath", RIDE_DEATH_TYPE_MAD)
		FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
		return
	end

	act(Dismount)

	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return TRUE
	end
	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		ExecEventAllBody("W_Idle")
		return
	end
end

function RideDamageBind_Start_onUpdate()
	act(SetIsMagicInUse, 0)
	act(SetAllowedThrowDefenseType, 0)
	act(SetAllowedThrowAttackType, 1)
	SetAIActionState()
	SetVariable("Int16Variable01", 0)
	act(Dismount)

	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return TRUE
	end
	if env(IsAnimEnd, 0) == TRUE then
		ExecEventAllBody("W_RideDamageBind_Loop")
		return
	end
end

function RideDamageBind_Loop_onUpdate()
	act(SetIsMagicInUse, 0)
	act(SetAllowedThrowDefenseType, 0)
	act(SetAllowedThrowAttackType, 1)
	SetAIActionState()
	SetVariable("Int16Variable01", 0)
	act(Dismount)
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return TRUE
	end
	if env(GetSpEffectType, 32) == FALSE then
		ExecEventAllBody("W_RideDamageBind_End")
	end
end

function RideDamageBind_End_onUpdate()
	act(SetIsMagicInUse, 0)
	act(SetAllowedThrowDefenseType, 0)
	act(SetAllowedThrowAttackType, 1)
	SetAIActionState()
	SetVariable("Int16Variable01", 0)
	act(Dismount)
	if DamageCommonFunction(FALSE, ESTEP_NONE, FALL_TYPE_FORCE) == TRUE then
		return TRUE
	end
	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		act(SetDamageAnimType, DAMAGE_FLAG_SMALL)
		ExecEventAllBody("W_Idle")
		return
	end
end

function RideDeath_Idle_onActivate()
	act(SetDeathStay, TRUE)
end

function RideDeath_Idle_onDeactivate()
	act(SetDeathStay, FALSE)
end

function RideAttackCommonFunction(r1, r2, l1, l2)
	if RideCommonFunction(r1, r2, l1, l2) == TRUE then
		return TRUE
	end
	if c_Style == HAND_LEFT_BOTH then
		SetAttackHand(HAND_LEFT)
		SetGuardHand(HAND_LEFT)
	else
		SetAttackHand(HAND_RIGHT)
		SetGuardHand(HAND_RIGHT)
	end
	return FALSE
end

Ride_HighJump_Height = 0
Ride_HeadDown_Rate = 0
Ride_Feed_Rate = 0
IsEnableFeedAddBlend = FALSE

function RideCommonFunction(r1, r2, l1, l2)
	Ride_HeadDown_Rate = EaseInOutVal(g_TimeActEditor_07, Ride_HeadDown_Rate, 0.800000011920929, 1.5,
		"EaseInOutStartVal1", "EaseInOutTargetVal1", "EaseInOutTimer1")
	act(ApplyRideBlend, "AddBlend02", Ride_HeadDown_Rate)

	if RideReActionFunction() == TRUE then
		return TRUE
	end
	if ExecRideDashAccelerate() == TRUE then
		return TRUE
	end
	if ExecRideWeaponChange() == TRUE then
		return TRUE
	end
	if ExecRideOff(FALSE, FALSE) == TRUE then
		return TRUE
	end

	local attackHand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		attackHand = HAND_LEFT
	end

	local isShield = GetEquipType(attackHand, WEAPON_CATEGORY_LARGE_SHIELD, WEAPON_CATEGORY_SMALL_SHIELD,
		WEAPON_CATEGORY_MIDDLE_SHIELD)

	if env(ActionRequest, 6) == TRUE
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) ~= 1 and env(GetSpEffectID, 100280) == FALSE or isShield == TRUE) then
		if env(GetStamina) <= 0 then
			ResetRequest()
		else
			local highJumpHeight = env(GetSpiritspringJumpHeight)

			-- Normal Spiritspring Jump
			if highJumpHeight > 0 then
				act(DebugLogOutput, "RideJumpHigh Height=" .. highJumpHeight .. "cm")
				Ride_HighJump_Height = highJumpHeight + 700
				FireRideEvent("W_RideJumpHigh", "W_RideJumpHigh", FALSE)
				return TRUE
			end

			-- Normal Jump
			if env(GetSpEffectID, 102360) == FALSE then
				act(ChangeStamina, STAMINA_REDUCE_RIDE_JUMP)
			end

			if 1.5 <= GetVariable("MoveSpeedLevel") then
				FireRideEvent("W_RideJump_D", "W_RideJump_D", FALSE)
			elseif GetVariable("MoveSpeedLevel") >= 0.6000000238418579 then
				FireRideEvent("W_RideJump_F", "W_RideJump_F", FALSE)
			else
				FireRideEvent("W_RideJump_N", "W_RideJump_N", FALSE)
			end
			return TRUE
		end
	end

	if ExecRideHandChange(HAND_RIGHT, FALSE) == TRUE then
		return TRUE
	end
	if ExecRideMagic() == TRUE then
		return TRUE
	end
	if ExecRideAttack(r1, r2, l1, l2) == TRUE then
		return TRUE
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end
	if ExecRideGesture() == TRUE then
		return TRUE
	end
	return FALSE
end

function ExecRideDashAccelerate()
	if env(GetStamina) <= 0 or env(GetSpEffectID, 100020) == TRUE then
		ResetRequest()
		return FALSE
	end

	local testControl = 3

	if testControl == 2 or testControl == 12 then
		SetVariable("IsEnableToggleDashTest", 0)

		if env(ActionRequest, ACTION_ARM_ROLLING) == TRUE and env(GetStamina) <= 0 then
			ResetRequest()
		end

		local evasionRequest = GetEvasionRequest()
		if evasionRequest == ATTACK_REQUEST_ROLLING then
			if env(GetSpEffectID, 102360) == FALSE then
				act(ChangeStamina, STAMINA_REDUCE_RIDE_DASH)
			end
			if IsNodeActive("RideDashAccelerate CMSG") == TRUE or IsNodeActive("RideDashAccelerateContinue CMSG") == TRUE then
				FireRideEvent("W_RideDashAccelerateContinue", "W_RideDashAccelerateContinue", FALSE)
			else
				FireRideEvent("W_RideDashAccelerate", "W_RideDashAccelerate", FALSE)
			end
			return TRUE
		end
	elseif testControl == 3 or testControl == 13 then
		SetVariable("IsEnableToggleDashTest", 4)
		local evasionRequest = env(ActionRequest, ACTION_ARM_SP_MOVE)

		if evasionRequest == TRUE and env(GetStamina) <= 0 then
			ResetRequest()
		end
		if env(GetSpEffectID, 100903) == TRUE then
			return FALSE
		end
		-- "O" Pressed
		if evasionRequest == TRUE then
			if env(GetSpEffectID, 102360) == FALSE then
				act(ChangeStamina, STAMINA_REDUCE_RIDE_DASH)
			end

			SetVariable("ToggleDash", 1)

			if IsNodeActive("RideDashAccelerate CMSG") == TRUE or IsNodeActive("RideDashAccelerateContinue CMSG") == TRUE then
				FireRideEvent("W_RideDashAccelerateContinue", "W_RideDashAccelerateContinue", FALSE)
			else
				FireRideEvent("W_RideDashAccelerate", "W_RideDashAccelerate", FALSE)
			end
			return TRUE
		end
	else
		SetVariable("IsEnableToggleDashTest", 0)
		if RideDashAccelerateTest == 0 and env(ActionDuration, ACTION_ARM_SP_MOVE) > 0 then
			act(DebugLogOutput, "RideDashAccel")
		end

		local evasionRequest = env(ActionDuration, ACTION_ARM_SP_MOVE)

		if (env(IsStayState) == TRUE or env(IsGeneralAnimCancelPossible) == TRUE) and evasionRequest > 0 and 0
			>= RideDashAccelerateTest and env(GetStamina) > 0 then
			if env(GetSpEffectID, 102360) == FALSE then
				act(ChangeStamina, STAMINA_REDUCE_RIDE_DASH)
			end
			if IsNodeActive("RideDashAccelerate CMSG") == TRUE or IsNodeActive("RideDashAccelerateContinue CMSG") == TRUE then
				FireRideEvent("W_RideDashAccelerateContinue", "W_RideDashAccelerateContinue", FALSE)
			else
				FireRideEvent("W_RideDashAccelerate", "W_RideDashAccelerate", FALSE)
			end
			return TRUE
		end

		RideDashAccelerateTest = env(ActionDuration, ACTION_ARM_SP_MOVE)

		if IsNodeActive("RideDashAccelerate CMSG") == FALSE and IsNodeActive("RideDashAccelerateContinue CMSG") == FALSE then
			if env(ActionRequest, ACTION_ARM_ROLLING) == TRUE and env(GetStamina) <= 0 then
				ResetRequest()
			end

			local evasionRequest = GetEvasionRequest()

			if evasionRequest == ATTACK_REQUEST_ROLLING and env(GetStamina) > 0 then
				if env(GetSpEffectID, 102360) == FALSE then
					act(ChangeStamina, STAMINA_REDUCE_RIDE_DASH)
				end

				if IsNodeActive("RideDashAccelerate CMSG") == TRUE or IsNodeActive("RideDashAccelerateContinue CMSG")
					== TRUE then
					FireRideEvent("W_RideDashAccelerateContinue", "W_RideDashAccelerateContinue", FALSE)
				else
					FireRideEvent("W_RideDashAccelerate", "W_RideDashAccelerate", FALSE)
				end
				return TRUE
			end
		end
	end
	return FALSE
end

function RideAttack_BackKick_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideAttack_BackKick_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)

	if RideAttackCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(MovementRequest) == TRUE and GetVariable("MoveSpeedLevel") > 0
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
		return
	end
end

function RideAttack_BackKick_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_R_Top_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideAttack_R_Top_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)

	if RideAttackCommonFunction("W_RideAttack_R_Top02", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideAttack_R_Top_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_R_Top02_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideAttack_R_Top02_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)

	if RideAttackCommonFunction("W_RideAttack_R_Top03", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideAttack_R_Top02_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_R_Top03_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideAttack_R_Top03_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)

	if RideAttackCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideAttack_R_Top03_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_R_Hard1_Start_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
	SetVariable("RideAttack_JumpCondition", 0)
end

function RideAttack_R_Hard1_Start_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	local r2 = "W_RideAttack_R_Hard1_Start"

	if IsEnableRideAttackHard2(HAND_RIGHT) == TRUE and env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT) ~= 241 then
		r2 = "W_RideAttack_R_Hard2_Start"
	end

	if RideAttackCommonFunction("W_RideAttack_R_Top", r2, "W_RideAttack_L_Top", "W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end

	local attackHand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		attackHand = HAND_LEFT
	end

	local isShield = GetEquipType(attackHand, WEAPON_CATEGORY_LARGE_SHIELD, WEAPON_CATEGORY_SMALL_SHIELD,
		WEAPON_CATEGORY_MIDDLE_SHIELD)

	if env(ActionRequest, 6) == TRUE
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) and isShield == FALSE then
		local jumpEvent = "W_RideJump_N"
		if GetVariable("MoveSpeedLevel") >= 1.5 then
			jumpEvent = "W_RideJump_D"
		elseif GetVariable("MoveSpeedLevel") >= 0.6000000238418579 then
			jumpEvent = "W_RideJump_F"
		end
		if env(GetSpEffectID, 102360) == FALSE then
			act(ChangeStamina, STAMINA_REDUCE_RIDE_JUMP)
		end
		SetVariable("RideJumpAttack_Land", 0)
		FireRideEvent("W_RideAttack_Jump_R_Hard1", jumpEvent, FALSE)
		return TRUE
	end
	if env(ActionDuration, ACTION_ARM_R2) <= 0
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_RideAttack_R_Hard1_End")
		return
	end
end

function RideAttack_R_Hard1_Start_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_R_Hard1_End_onActivate()
	act(ResetInputQueue)
end

function RideAttack_R_Hard1_End_onUpdate()
	act(DisallowAdditiveTurning, TRUE)
	local r2 = "W_RideAttack_R_Hard1_Start"

	if IsEnableRideAttackHard2(HAND_RIGHT) == TRUE and env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT) ~= 241 then
		r2 = "W_RideAttack_R_Hard2_Start"
	end

	if RideAttackCommonFunction("W_RideAttack_R_Top", r2, "W_RideAttack_L_Top", "W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if env(GetSpEffectID, 131) == FALSE
		and (GetVariable("RideAttack_JumpCondition") == 0 or env(IsMoveCancelPossible) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideAttack_R_Hard1_End_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_R_Hard2_Start_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
	SetVariable("RideAttack_JumpCondition", 0)
end

function RideAttack_R_Hard2_Start_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)

	if RideAttackCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end

	local attackHand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		attackHand = HAND_LEFT
	end

	local isShield = GetEquipType(attackHand, WEAPON_CATEGORY_LARGE_SHIELD, WEAPON_CATEGORY_SMALL_SHIELD,
		WEAPON_CATEGORY_MIDDLE_SHIELD)

	if env(ActionRequest, 6) == TRUE
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) and isShield == FALSE then
		local jumpEvent = "W_RideJump_N"
		if GetVariable("MoveSpeedLevel") >= 1.5 then
			jumpEvent = "W_RideJump_D"
		elseif GetVariable("MoveSpeedLevel") >= 0.6000000238418579 then
			jumpEvent = "W_RideJump_F"
		end
		if env(GetSpEffectID, 102360) == FALSE then
			act(ChangeStamina, STAMINA_REDUCE_RIDE_JUMP)
		end
		SetVariable("RideJumpAttack_Land", 0)
		FireRideEvent("W_RideAttack_Jump_R_Hard2", jumpEvent, FALSE)
		return TRUE
	end
	if env(ActionDuration, ACTION_ARM_R2) <= 0
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_RideAttack_R_Hard2_End")
		return
	end
end

function RideAttack_R_Hard2_Start_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_R_Hard2_End_onActivate()
	act(ResetInputQueue)
end

function RideAttack_R_Hard2_End_onUpdate()
	act(DisallowAdditiveTurning, TRUE)

	if RideAttackCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if env(GetSpEffectID, 131) == FALSE and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideAttack_R_Hard2_End_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_L_Hard1_Start_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
	SetVariable("RideAttack_JumpCondition", 0)
end

function RideAttack_L_Hard1_Start_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	local l2 = "W_RideAttack_L_Hard1_Start"

	if IsEnableRideAttackHard2(HAND_RIGHT) == TRUE and env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT) ~= 241 then
		l2 = "W_RideAttack_L_Hard2_Start"
	end

	if RideAttackCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top", l2) == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end

	local attackHand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		attackHand = HAND_LEFT
	end

	local isShield = GetEquipType(attackHand, WEAPON_CATEGORY_LARGE_SHIELD, WEAPON_CATEGORY_SMALL_SHIELD,
		WEAPON_CATEGORY_MIDDLE_SHIELD)

	if env(ActionRequest, 6) == TRUE
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) and isShield == FALSE then
		local jumpEvent = "W_RideJump_N"
		if GetVariable("MoveSpeedLevel") >= 1.5 then
			jumpEvent = "W_RideJump_D"
		elseif GetVariable("MoveSpeedLevel") >= 0.6000000238418579 then
			jumpEvent = "W_RideJump_F"
		end
		if env(GetSpEffectID, 102360) == FALSE then
			act(ChangeStamina, STAMINA_REDUCE_RIDE_JUMP)
		end
		SetVariable("RideJumpAttack_Land", 0)
		FireRideEvent("W_RideAttack_Jump_L_Hard1", jumpEvent, FALSE)
		return TRUE
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_RideAttack_L_Hard1_End")
		return
	end
end

function RideAttack_L_Hard1_Start_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_L_Hard1_End_onActivate()
	act(ResetInputQueue)
end

function RideAttack_L_Hard1_End_onUpdate()
	act(DisallowAdditiveTurning, TRUE)
	local l2 = "W_RideAttack_L_Hard1_Start"

	if IsEnableRideAttackHard2(HAND_RIGHT) == TRUE and env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT) ~= 241 then
		l2 = "W_RideAttack_L_Hard2_Start"
	end

	if RideAttackCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top", l2) == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if env(GetSpEffectID, 131) == FALSE and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideAttack_L_Hard1_End_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_L_Hard2_Start_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
	SetVariable("RideAttack_JumpCondition", 0)
end

function RideAttack_L_Hard2_Start_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)

	if RideAttackCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end

	local attackHand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		attackHand = HAND_LEFT
	end

	local isShield = GetEquipType(attackHand, WEAPON_CATEGORY_LARGE_SHIELD, WEAPON_CATEGORY_SMALL_SHIELD,
		WEAPON_CATEGORY_MIDDLE_SHIELD)

	if env(ActionRequest, 6) == TRUE
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) and isShield == FALSE then
		local jumpEvent = "W_RideJump_N"
		if GetVariable("MoveSpeedLevel") >= 1.5 then
			jumpEvent = "W_RideJump_D"
		elseif GetVariable("MoveSpeedLevel") >= 0.6000000238418579 then
			jumpEvent = "W_RideJump_F"
		end

		if env(GetSpEffectID, 102360) == FALSE then
			act(ChangeStamina, STAMINA_REDUCE_RIDE_JUMP)
		end

		SetVariable("RideJumpAttack_Land", 0)
		FireRideEvent("W_RideAttack_Jump_L_Hard2", jumpEvent, FALSE)
		return TRUE
	end
	if env(ActionDuration, ACTION_ARM_L2) <= 0
		and (env(GetGeneralTAEFlag, TAE_FLAG_CHARGING) == 1 or env(GetSpEffectID, 100280) == TRUE) then
		ExecEventAllBody("W_RideAttack_L_Hard2_End")
		return
	end
end

function RideAttack_L_Hard2_Start_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_L_Hard2_End_onActivate()
	act(ResetInputQueue)
end

function RideAttack_L_Hard2_End_onUpdate()
	act(DisallowAdditiveTurning, TRUE)

	if RideAttackCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if env(GetSpEffectID, 131) == FALSE and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideAttack_L_Hard2_End_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_L_Top_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideAttack_L_Top_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	local r1 = "W_RideAttack_R_Top"

	if RideAttackCommonFunction(r1, "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top02", "W_RideAttack_L_Hard1_Start")
		== TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideAttack_L_Top_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_L_Top02_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideAttack_L_Top02_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	local r1 = "W_RideAttack_R_Top"

	if RideAttackCommonFunction(r1, "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top03", "W_RideAttack_L_Hard1_Start")
		== TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideAttack_L_Top02_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttack_L_Top03_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
	act(ResetInputQueue)
end

function RideAttack_L_Top03_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	local r1 = "W_RideAttack_R_Top"

	if RideAttackCommonFunction(r1, "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top", "W_RideAttack_L_Hard1_Start")
		== TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideAttack_L_Top03_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttackArrowStart_onUpdate()
	SetAIActionState()
	act(SetIsPreciseShootingPossible)
	act(DisallowAdditiveTurning, TRUE)

	if RideAttackCommonFunction() == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventAllBody("W_RideAttackArrowLoop")
				return
			else
				local fireEvent = "W_RideAttackArrowFire"

				if c_Style == HAND_LEFT_BOTH and GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW) == TRUE then
					fireEvent = "W_RideAttackCrossbowLeftFire"
				end

				ExecEventAllBody(fireEvent)
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventAllBody("W_RideAttackArrowLoop")
			return
		else
			local fireEvent = "W_RideAttackArrowFire"

			if c_Style == HAND_LEFT_BOTH and GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW) == TRUE then
				fireEvent = "W_RideAttackCrossbowLeftFire"
			end

			ExecEventAllBody(fireEvent)
			return
		end
	end
end

function RideAttackArrowStartContinue_onUpdate()
	SetAIActionState()
	act(SetIsPreciseShootingPossible)
	act(DisallowAdditiveTurning, TRUE)

	if RideAttackCommonFunction() == TRUE then
		return
	end
	if RideReActionFunction() == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				hkbFireEvent("W_RideAttackArrowLoop")
				return
			else
				hkbFireEvent("W_RideAttackArrowFire")
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			hkbFireEvent("W_RideAttackArrowLoop")
			return
		else
			hkbFireEvent("W_RideAttackArrowFire")
			return
		end
	end
	if ExecRideItem() == TRUE then
		return TRUE
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
end

function RideAttackArrowLoop_onUpdate()
	SetAIActionState()
	act(SetIsPreciseShootingPossible)
	act(DisallowAdditiveTurning, TRUE)

	if RideAttackCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if g_ArrowSlot == 0 then
		if env(ActionDuration, ACTION_ARM_R1) <= 0 then
			local fireEvent = "W_RideAttackArrowFire"

			if c_Style == HAND_LEFT_BOTH and GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW) == TRUE then
				fireEvent = "W_RideAttackCrossbowLeftFire"
			end

			ExecEventAllBody(fireEvent)
			return
		end
	elseif env(ActionDuration, ACTION_ARM_R2) <= 0 then
		local fireEvent = "W_RideAttackArrowFire"

		if c_Style == HAND_LEFT_BOTH and GetEquipType(HAND_LEFT, WEAPON_CATEGORY_CROSSBOW) == TRUE then
			fireEvent = "W_RideAttackCrossbowLeftFire"
		end

		ExecEventAllBody(fireEvent)
		return
	end
end

function RideAttackArrowFire_onUpdate()
	SetAIActionState()
	act(SetIsPreciseShootingPossible)
	act(DisallowAdditiveTurning, TRUE)
	local arrowHand = 1

	if c_Style == HAND_LEFT_BOTH then
		arrowHand = 0
	end

	local is_crossbow = GetEquipType(arrowHand, WEAPON_CATEGORY_CROSSBOW)

	if env(ActionRequest, 0) == TRUE and is_crossbow == FALSE then
		act(ResetInputQueue)
		g_ArrowSlot = 0
		act(ChooseBowAndArrowSlot, 0)
		if env(IsOutOfAmmo, arrowHand) == TRUE then
			ExecEventAllBody("W_RideNoArrow")
			return TRUE
		end
		ExecEventAllBody("W_RideAttackArrowStartContinue")
		return TRUE
	elseif env(ActionRequest, 1) == TRUE and env(ActionDuration, 1) > 0 and is_crossbow == FALSE then
		act(ResetInputQueue)
		g_ArrowSlot = 1
		act(ChooseBowAndArrowSlot, 1)

		if env(IsOutOfAmmo, arrowHand) == TRUE then
			ExecEventAllBody("W_RideNoArrow")
			return TRUE
		end
		ExecEventAllBody("W_RideAttackArrowStartContinue")
		return TRUE
	end
	if RideAttackCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		hkbFireEvent("W_RideIdle")
	end
end

function RideAttackArrowFire_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideAttackCrossbowLeftFire_onUpdate()
	SetAIActionState()
	act(SetIsPreciseShootingPossible)
	act(DisallowAdditiveTurning, TRUE)
	local arrowHand = 1

	if c_Style == HAND_LEFT_BOTH then
		arrowHand = 0
	end

	local is_crossbow = GetEquipType(arrowHand, WEAPON_CATEGORY_CROSSBOW)

	if env(ActionRequest, 0) == TRUE and is_crossbow == FALSE then
		act(ResetInputQueue)
		g_ArrowSlot = 0
		act(ChooseBowAndArrowSlot, 0)
		if env(IsOutOfAmmo, arrowHand) == TRUE then
			ExecEventAllBody("W_RideNoArrow")
			return TRUE
		end
		ExecEventAllBody("W_RideAttackArrowStartContinue")
		return TRUE
	elseif env(ActionRequest, 1) == TRUE and env(ActionDuration, 1) > 0 and is_crossbow == FALSE then
		act(ResetInputQueue)
		g_ArrowSlot = 1
		act(ChooseBowAndArrowSlot, 1)
		if env(IsOutOfAmmo, arrowHand) == TRUE then
			ExecEventAllBody("W_RideNoArrow")
			return TRUE
		end
		ExecEventAllBody("W_RideAttackArrowStartContinue")
		return TRUE
	end
	if RideAttackCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		hkbFireEvent("W_RideIdle")
	end
end

function RideAttackCrossbowLeftFire_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function RideNoArrow_onUpdate()
	SetAIActionState()
	act(SetIsPreciseShootingPossible)

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		hkbFireEvent("W_RideIdle")
	end
end

function RideAttackCrossbowRightReload_onUpdate()
	SetAIActionState()
	act(SetIsPreciseShootingPossible)

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		hkbFireEvent("W_RideIdle")
	end
end

function RideAttackCrossbowLeftReload_onUpdate()
	SetAIActionState()
	act(SetIsPreciseShootingPossible)

	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end

	local lower_only = TRUE
	local enable_turn = FALSE

	if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		lower_only = FALSE
		enable_turn = TRUE
	end

	if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, enable_turn, lower_only) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		hkbFireEvent("W_RideIdle")
	end
end

function RideJumpCommonFunction(jump_type, lower_only, isSecond, isHighJump)
	act(DisallowAdditiveTurning, TRUE)
	SetVariable("Int16Variable01", 1)
	local damage_type = env(GetReceivedDamageType)

	if damage_type == DAMAGE_TYPE_DEATH_FALLING and isHighJump == FALSE and env(GetSpEffectID, 185) == FALSE then
		FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
		return TRUE
	end

	local height = env(GetMountFallHeight) / 100

	if env(IsMountTrulyLanding) == TRUE and IsLandDead(height) == TRUE and isHighJump == FALSE
		and env(GetSpEffectID, 185) == FALSE then
		act(DebugLogOutput, height)
		FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
		return
	end
	if RideReActionFunction() == TRUE then
		return TRUE
	end
	if env(ActionRequest, 6) == TRUE and env(GetSpEffectID, 100902) == TRUE and RIDE_ISENABLE_DOUBLEJUMP == TRUE then
		if env(GetStamina) <= 0 or height > DISABLEJUMP_FALLDIST then
			ResetRequest()
		else
			if env(GetSpEffectID, 102360) == FALSE then
				act(ChangeStamina, STAMINA_REDUCE_RIDE_JUMP)
			end

			if GetVariable("MoveSpeedLevel") >= 1.5 then
				FireRideEvent("W_RideJump2_D", "W_RideJump2_D", FALSE)
			elseif GetVariable("MoveSpeedLevel") >= 0.6000000238418579 then
				FireRideEvent("W_RideJump2_F", "W_RideJump2_F", FALSE)
			else
				FireRideEvent("W_RideJump2_N", "W_RideJump2_N", FALSE)
			end

			RIDE_ISENABLE_DOUBLEJUMP = FALSE
			return TRUE
		end
	end

	if env(IsMountTrulyLanding) == TRUE and env(GetMountSpEffectID, 98) == TRUE and env(GetMountSpEffectID, 140) == FALSE then
		if GetVariable("MoveSpeedLevel") > 1.5 then
			FireRideEvent("W_RideJump_Land_To_Gallop", "W_RideJump_Land_To_Gallop", lower_only)
			return TRUE
		elseif GetVariable("MoveSpeedLevel") > 0.6000000238418579 then
			FireRideEvent("W_RideJump_Land_To_Dash", "W_RideJump_Land_To_Dash", lower_only)
			return TRUE
		end

		local landEvent = "W_RideJump_Land_N"

		if jump_type == 3 then
			landEvent = "W_RideJump_Land_D"
		elseif jump_type == 2 then
			landEvent = "W_RideJump_Land_F"
		end

		act(DebugLogOutput, landEvent)
		FireRideEvent(landEvent, landEvent, lower_only)
		return TRUE
	end

	local enable_jumpAttack = TRUE
	local attackHand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		attackHand = HAND_LEFT
	end

	if GetEquipType(attackHand, WEAPON_CATEGORY_ARROW, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_CROSSBOW) == TRUE then
		enable_jumpAttack = FALSE
	end

	local is_staff = GetEquipType(attackHand, WEAPON_CATEGORY_STAFF)

	if enable_jumpAttack == TRUE then
		if env(ActionRequest, ACTION_ARM_R1) == TRUE and is_staff == FALSE or env(ActionRequest, ACTION_ARM_R2) == TRUE
			and is_staff == TRUE then
			SetVariable("RideJumpAttack_Land", 0)
			SetVariable("IndexRideJumpType", jump_type)
			ExecEventAllBody("W_RideAttack_Jump_R")
			RideJumpLoop_IsSecond = isSecond
			return TRUE
		elseif env(ActionRequest, ACTION_ARM_L1) == TRUE and is_staff == FALSE or env(ActionRequest, ACTION_ARM_L2)
			== TRUE and is_staff == TRUE then
			SetVariable("RideJumpAttack_Land", 0)
			SetVariable("IndexRideJumpType", jump_type)
			ExecEventAllBody("W_RideAttack_Jump_L")
			RideJumpLoop_IsSecond = isSecond
			return TRUE
		end
	end

	if env(IsAnimEnd, 0) == TRUE and lower_only == FALSE then
		SetVariable("IndexRideJumpType", jump_type)
		if isHighJump == TRUE then
			ExecEventNoReset("W_RideJumpHigh_FallLoop")
		elseif isSecond == TRUE then
			ExecEventNoReset("W_RideJump2_Loop")
		else
			ExecEventNoReset("W_RideJump_Loop")
		end
		return TRUE
	end
	return FALSE
end

function RideJump_N_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump_N_onUpdate()
	if RideJumpCommonFunction(0, FALSE, FALSE, FALSE) == TRUE then
		return
	end
end

function RideJump_F_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump_F_onUpdate()
	if RideJumpCommonFunction(2, FALSE, FALSE, FALSE) == TRUE then
		return
	end
end

function RideJump_D_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump_D_onUpdate()
	if RideJumpCommonFunction(3, FALSE, FALSE, FALSE) == TRUE then
		return
	end
end

function RideJump_Loop_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump_Loop_onUpdate()
	if env(GetSpEffectID, 19935) == TRUE then
		if env(IsHamariFallDeath, 20) == TRUE and env(GetSpEffectID, 185) == FALSE then
			FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
			return
		end
	elseif env(IsHamariFallDeath, 12) == TRUE and env(GetSpEffectID, 185) == FALSE then
		FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
		return
	end
	if env(GetSpiritspringJumpHeight) > 0 or env(GetSpEffectID, 183) == TRUE then
		act(AddSpEffect, 186)
	end
	if RideJumpCommonFunction(GetVariable("IndexRideJumpType"), FALSE, FALSE, FALSE) == TRUE then
		return
	end
end

function RideJump2_N_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump2_N_onUpdate()
	if RideJumpCommonFunction(0, FALSE, TRUE, FALSE) == TRUE then
		return
	end
end

function RideJump2_F_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump2_F_onUpdate()
	if RideJumpCommonFunction(2, FALSE, TRUE, FALSE) == TRUE then
		return
	end
end

function RideJump2_D_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump2_D_onUpdate()
	if RideJumpCommonFunction(3, FALSE, TRUE) == TRUE then
		return
	end
end

function RideJump2_Loop_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump2_Loop_onUpdate()
	if env(GetSpEffectID, 19935) == TRUE then
		if env(IsHamariFallDeath, 20) == TRUE then
			FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
			return
		end
	elseif env(IsHamariFallDeath, 12) == TRUE then
		FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
		return
	end
	if env(GetSpiritspringJumpHeight) > 0 or env(GetSpEffectID, 183) == TRUE then
		act(AddSpEffect, 186)
	end
	if RideJumpCommonFunction(GetVariable("IndexRideJumpType"), FALSE, TRUE, FALSE) == TRUE then
		return
	end
end

function RideJump_Land_N_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump_Land_N_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE then
		local moveType = RIDE_MOVE_TYPE_IDLE
		if env(IsAnimEnd, 0) == TRUE then
			moveType = RIDE_MOVE_TYPE_OTHER
		end
		if RideRequestFunction(moveType, TRUE, FALSE) == TRUE then
			return
		end
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
	end
end

function RideJump_Land_F_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump_Land_F_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE or env(IsAnimEnd, 0) == TRUE then
		local moveType = RIDE_MOVE_TYPE_IDLE
		if env(IsAnimEnd, 0) == TRUE then
			moveType = RIDE_MOVE_TYPE_OTHER
		end
		if RideRequestFunction(moveType, TRUE, FALSE) == TRUE then
			return
		end
	end
end

function RideJump_Land_D_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump_Land_D_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE or env(IsAnimEnd, 0) == TRUE then
		local moveType = RIDE_MOVE_TYPE_IDLE
		if env(IsAnimEnd, 0) == TRUE then
			moveType = RIDE_MOVE_TYPE_OTHER
		end
		if RideRequestFunction(moveType, TRUE, FALSE) == TRUE then
			return
		end
	end
end

function RideJump_Land_To_Dash_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump_Land_To_Dash_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if ExecRideStop(RIDE_MOVE_TYPE_OTHER, FALSE) == TRUE then
		return
	end
	if (env(IsMoveCancelPossible) == TRUE or env(IsAnimEnd, 0) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function RideJump_Land_To_Gallop_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump_Land_To_Gallop_onUpdate()
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if ExecRideStop(RIDE_MOVE_TYPE_OTHER, FALSE) == TRUE then
		return
	end
	if (env(IsMoveCancelPossible) == TRUE or env(IsAnimEnd, 0) == TRUE)
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
end

function RideJumpHigh_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJumpHigh_onUpdate()
	act(AddSpEffect, 185)
	if env(ActionRequest, 6) == TRUE then
		FireRideEvent("W_RideJumpHigh2", "W_RideJumpHigh2", FALSE)
		RIDE_ISENABLE_DOUBLEJUMP = FALSE
		return
	end
	if env(IsAnimEnd, 0) == TRUE or env(GetEventEzStateFlag, 0) == TRUE then
		rideJumpHighLoop_StopTime = 0
		lastFallHeight = 0
		rideJumpHighLoop_IsStop = FALSE
		FireRideEvent("W_RideJumpHighLoop", "W_RideJumpHighLoop", FALSE)
		return
	end
	if RideJumpCommonFunction(0, FALSE, FALSE, TRUE) == TRUE then
		return
	end
end

function RideJumpHighLoop_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJumpHighLoop_onUpdate()
	act(AddSpEffect, 185)
	local fallHeight = env(GetMountFallHeight)
	local dT = env(ObtainedDT) / 1000
	local upSpeed = (fallHeight - lastFallHeight) / dT
	if upSpeed < 50 then
		rideJumpHighLoop_IsStop = TRUE
		rideJumpHighLoop_StopTime = rideJumpHighLoop_StopTime + dT
		act(DebugLogOutput,
			"RideJumpHigh current=" .. fallHeight .. "cm target=" .. Ride_HighJump_Height .. "cm upSpeed=" .. upSpeed
				.. "cm stopTime=" .. rideJumpHighLoop_StopTime)
		if rideJumpHighLoop_StopTime > 5 then
			act(DebugLogOutput, "RideJumpHigh Force end")
			FireRideEvent("W_RideJumpHighEnd", "W_RideJumpHighEnd", FALSE)
			return
		end
	else
		rideJumpHighLoop_IsStop = FALSE
		rideJumpHighLoop_StopTime = 0
		act(DebugLogOutput,
			"RideJumpHigh current=" .. fallHeight .. "cm target=" .. Ride_HighJump_Height .. "cm upSpeed=" .. upSpeed)
	end
	if -fallHeight > Ride_HighJump_Height then
		FireRideEvent("W_RideJumpHighEnd", "W_RideJumpHighEnd", FALSE)
		return
	end
	lastFallHeight = fallHeight
	if RideJumpCommonFunction(0, FALSE, FALSE, TRUE) == TRUE then
		return
	end
end

function RideJumpHighEnd_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJumpHighEnd_onUpdate()
	act(AddSpEffect, 185)
	if env(ActionRequest, 6) == TRUE then
		FireRideEvent("W_RideJumpHigh2", "W_RideJumpHigh2", FALSE)
		RIDE_ISENABLE_DOUBLEJUMP = FALSE
		return
	end
	if RideJumpCommonFunction(0, FALSE, FALSE, TRUE) == TRUE then
		return
	end
end

function RideJumpHigh2_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJumpHigh2_onUpdate()
	act(AddSpEffect, 185)
	if RideJumpCommonFunction(0, FALSE, FALSE, TRUE) == TRUE then
		return
	end
end

function RideJumpHigh_FallLoop_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJumpHigh_FallLoop_onUpdate()
	act(AddSpEffect, 185)
	if RideJumpCommonFunction(GetVariable("IndexRideJumpType"), FALSE, FALSE, TRUE) == TRUE then
		return
	end
end

function RideJump_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideJump_onUpdate()
	SetAIActionState()
	if GetVariable("IsEnableToggleDashTest") == 2 or GetVariable("IsEnableToggleDashTest") == 4 then
		SetVariable("ToggleDash", 0)
	end
	act(DisallowAdditiveTurning, TRUE)
	SetVariable("Int16Variable01", 1)
	if RideReActionFunction() == TRUE then
		SetVariable("Int16Variable05", 0)
		return
	end
	if env(IsMountInFallLoop) == FALSE then
		if env(ActionRequest, ACTION_ARM_R1) == TRUE and env(GetMountSpEffectID, 98) == TRUE then
			act(ResetInputQueue)
			SetVariable("RideJumpAttack_Land", 0)
			ExecEventAllBody("W_RideAttack_Jump_R")
			return
		elseif env(ActionRequest, ACTION_ARM_R2) == TRUE and 0 < env(ActionDuration, 1) and env(GetMountSpEffectID, 98)
			== FALSE then
			act(ResetInputQueue)
			SetVariable("Int16Variable05", 0)
			hkbFireEvent("W_RideAttack_R_Hard1_Start")
			return
		elseif env(ActionRequest, ACTION_ARM_L1) == TRUE and env(GetMountSpEffectID, 98) == TRUE then
			act(ResetInputQueue)
			SetVariable("RideJumpAttack_Land", 0)
			ExecEventAllBody("W_RideAttack_Jump_L")
			return
		elseif env(ActionRequest, ACTION_ARM_L2) == TRUE and 0 < env(ActionDuration, 3) then
			act(ResetInputQueue)
			SetVariable("Int16Variable05", 0)
			hkbFireEvent("W_RideAttack_L_Hard1_Start")
			return
		end
	elseif RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(MovementRequest) == TRUE and GetVariable("MoveSpeedLevel") > 0 and env(IsMountFalling) == FALSE
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		SetVariable("Int16Variable05", 0)
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
		SetVariable("Int16Variable05", 0)
		return
	end
end

function RideJumpAttackCommonFunction()
	if env(GetSpEffectID, 19935) == TRUE then
		if env(IsHamariFallDeath, 20) == TRUE and env(GetSpEffectID, 185) == FALSE then
			FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
			return
		end
	elseif env(IsHamariFallDeath, 12) == TRUE and env(GetSpEffectID, 185) == FALSE then
		FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
		return
	end
end

function RideAttack_Jump_R_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideAttack_Jump_R_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	SetVariable("Int16Variable01", 1)
	RideJumpAttackCommonFunction()

	if GetVariable("RideJumpAttack_Land") == 1 then
		if RideCommonFunction("W_RideAttack_R_Top02", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
			"W_RideAttack_L_Hard1_Start") == TRUE then
			return
		end
		if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
			if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
				return
			end
		else
			if ExecRideStop(RIDE_MOVE_TYPE_OTHER, TRUE) == TRUE then
				return
			end
			if (env(GetMountSpEffectID, 101100) == TRUE or env(GetMountSpEffectID, 101006) == TRUE
				or env(GetMountSpEffectID, 101005) == TRUE) and GetVariable("MoveSpeedLevel") > 0
				and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, FALSE, TRUE) == TRUE then
				return
			end
		end
	elseif env(GetMountSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE and env(GetMountSpEffectID, 140) == FALSE then
		SetVariable("RideJumpAttack_Land", 1)
		RideJumpCommonFunction(GetVariable("IndexRideJumpType"), TRUE, FALSE, FALSE)
	elseif env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		if RideJumpLoop_IsSecond == TRUE then
			FireRideEvent("W_RideJump2_Loop", "W_RideJump2_Loop", FALSE)
		else
			FireRideEvent("W_RideJump_Loop", "W_RideJump_Loop", FALSE)
		end
		return
	end
end

function RideAttack_Jump_R_Hard1_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideAttack_Jump_R_Hard1_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	SetVariable("Int16Variable01", 1)

	if GetVariable("RideJumpAttack_Land") == 1 then
		local r2 = "W_RideAttack_R_Hard1_Start"
		if IsEnableRideAttackHard2(HAND_RIGHT) == TRUE and env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT) ~= 241 then
			r2 = "W_RideAttack_R_Hard2_Start"
		end
		if RideCommonFunction("W_RideAttack_R_Top", r2, "W_RideAttack_L_Top", "W_RideAttack_L_Hard1_Start") == TRUE then
			return
		end
		if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
			if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
				return
			end
		else
			if ExecRideStop(RIDE_MOVE_TYPE_OTHER, TRUE) == TRUE then
				return
			end
			if (env(GetMountSpEffectID, 101100) == TRUE or env(GetMountSpEffectID, 101006) == TRUE
				or env(GetMountSpEffectID, 101005) == TRUE) and GetVariable("MoveSpeedLevel") > 0
				and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, FALSE, TRUE) == TRUE then
				return
			end
		end
	elseif env(GetMountSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE and env(GetMountSpEffectID, 140) == FALSE then
		SetVariable("RideJumpAttack_Land", 1)
		RideJumpCommonFunction(GetVariable("IndexRideJumpType"), TRUE, FALSE, FALSE)
	elseif env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideJump_Loop", "W_RideJump_Loop", FALSE)
		return
	end
end

function RideAttack_Jump_R_Hard2_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideAttack_Jump_R_Hard2_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	SetVariable("Int16Variable01", 1)

	if GetVariable("RideJumpAttack_Land") == 1 then
		if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
			"W_RideAttack_L_Hard1_Start") == TRUE then
			return
		end
		if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
			if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
				return
			end
		else
			if ExecRideStop(RIDE_MOVE_TYPE_OTHER, TRUE) == TRUE then
				return
			end
			if (env(GetMountSpEffectID, 101100) == TRUE or env(GetMountSpEffectID, 101006) == TRUE
				or env(GetMountSpEffectID, 101005) == TRUE) and GetVariable("MoveSpeedLevel") > 0
				and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, FALSE, TRUE) == TRUE then
				return
			end
		end
	elseif env(GetMountSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE and env(GetMountSpEffectID, 140) == FALSE then
		SetVariable("RideJumpAttack_Land", 1)
		RideJumpCommonFunction(GetVariable("IndexRideJumpType"), TRUE, FALSE, FALSE)
	elseif env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideJump_Loop", "W_RideJump_Loop", FALSE)
		return
	end
end

function RideAttack_Jump_L_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideAttack_Jump_L_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	SetVariable("Int16Variable01", 1)
	RideJumpAttackCommonFunction()

	if GetVariable("RideJumpAttack_Land") == 1 then
		if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top02",
			"W_RideAttack_L_Hard1_Start") == TRUE then
			return
		end
		if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
			if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
				return
			end
		else
			if ExecRideStop(RIDE_MOVE_TYPE_OTHER, TRUE) == TRUE then
				return
			end
			if (env(GetMountSpEffectID, 101100) == TRUE or env(GetMountSpEffectID, 101006) == TRUE
				or env(GetMountSpEffectID, 101005) == TRUE) and GetVariable("MoveSpeedLevel") > 0
				and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, FALSE, TRUE) == TRUE then
				return
			end
		end
	elseif env(GetMountSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE and env(GetMountSpEffectID, 140) == FALSE then
		SetVariable("RideJumpAttack_Land", 1)
		RideJumpCommonFunction(GetVariable("IndexRideJumpType"), TRUE, FALSE, FALSE)
	elseif env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideJump_Loop", "W_RideJump_Loop", FALSE)
		return
	end
end

function RideAttack_Jump_L_Hard1_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideAttack_Jump_L_Hard1_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	SetVariable("Int16Variable01", 1)

	if GetVariable("RideJumpAttack_Land") == 1 then
		local l2 = "W_RideAttack_L_Hard1_Start"
		if IsEnableRideAttackHard2(HAND_RIGHT) == TRUE and env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT) ~= 241 then
			l2 = "W_RideAttack_L_Hard2_Start"
		end
		if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top", l2) == TRUE then
			return
		end
		if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
			if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
				return
			end
		else
			if ExecRideStop(RIDE_MOVE_TYPE_OTHER, TRUE) == TRUE then
				return
			end
			if (env(GetMountSpEffectID, 101100) == TRUE or env(GetMountSpEffectID, 101006) == TRUE
				or env(GetMountSpEffectID, 101005) == TRUE) and GetVariable("MoveSpeedLevel") > 0
				and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, FALSE, TRUE) == TRUE then
				return
			end
		end
	elseif env(GetMountSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE and env(GetMountSpEffectID, 140) == FALSE then
		SetVariable("RideJumpAttack_Land", 1)
		RideJumpCommonFunction(GetVariable("IndexRideJumpType"), TRUE, FALSE, FALSE)
	elseif env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideJump_Loop", "W_RideJump_Loop", FALSE)
		return
	end
end

function RideAttack_Jump_L_Hard2_onActivate()
	SetAIActionState()
	act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
end

function RideAttack_Jump_L_Hard2_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)
	SetVariable("Int16Variable01", 1)

	if GetVariable("RideJumpAttack_Land") == 1 then
		if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
			"W_RideAttack_L_Hard1_Start") == TRUE then
			return
		end
		if env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
			if RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
				return
			end
		else
			if ExecRideStop(RIDE_MOVE_TYPE_OTHER, TRUE) == TRUE then
				return
			end
			if (env(GetMountSpEffectID, 101100) == TRUE or env(GetMountSpEffectID, 101006) == TRUE
				or env(GetMountSpEffectID, 101005) == TRUE) and GetVariable("MoveSpeedLevel") > 0
				and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, FALSE, TRUE) == TRUE then
				return
			end
		end
	elseif env(GetMountSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE and env(GetMountSpEffectID, 140) == FALSE then
		SetVariable("RideJumpAttack_Land", 1)
		RideJumpCommonFunction(GetVariable("IndexRideJumpType"), TRUE, FALSE, FALSE)
	elseif env(MovementRequest) == TRUE or env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideJump_Loop", "W_RideJump_Loop", FALSE)
		return
	end
end

function RideTurn_Left180_onUpdate()
	RIDE_TURN_STATE = 1
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(MovementRequest) == TRUE and GetVariable("MoveSpeedLevel") > 0
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
		return
	end
end

function RideTurn_Left180_onDeactivate()
	RIDE_TURN_STATE = 0
end

function RideTurn_Right180_onUpdate()
	RIDE_TURN_STATE = 1
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(MovementRequest) == TRUE and GetVariable("MoveSpeedLevel") > 0
		and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
		return
	end
end

function RideTurn_Right180_onDeactivate()
	RIDE_TURN_STATE = 0
end

function RideTurn_Left90_onUpdate()
	RIDE_TURN_STATE = 1
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(MovementRequest) == TRUE and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
		return
	end
end

function RideTurn_Left90_onDeactivate()
	RIDE_TURN_STATE = 0
end

function RideTurn_Right90_onUpdate()
	RIDE_TURN_STATE = 1
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(MovementRequest) == TRUE and RideRequestFunction(RIDE_MOVE_TYPE_OTHER, TRUE, FALSE) == TRUE then
		return
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
		return
	end
end

function RideTurn_Right90_onDeactivate()
	RIDE_TURN_STATE = 0
end

function RideFall_Start_onUpdate()
	if RideFallCommonFunction() == TRUE then
		return
	end
	if env(IsMountInFallLoop) == TRUE then
		local height = env(GetMountFallHeight)
		if IsLandDead(height / 100) == TRUE then
			FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
			return
		end
		if height < 900 and height >= 200 then
			if GetVariable("MoveSpeedLevel") > 1.5 then
				FireRideEvent("W_RideJump_Land_To_Gallop", "W_RideJump_Land_To_Gallop", lower_only)
				return
			elseif GetVariable("MoveSpeedLevel") > 0.6000000238418579 then
				FireRideEvent("W_RideJump_Land_To_Dash", "W_RideJump_Land_To_Dash", lower_only)
				return
			else
				FireRideEvent("W_RideFall_Land", "W_RideFall_Land", FALSE)
				return
			end
		elseif height >= 200 then
			FireRideEvent("W_RideFall_Land", "W_RideFall_Land", FALSE)
			return
		elseif GetVariable("MoveSpeedLevel") > 1.5 or GetVariable("IsEnableToggleDashTest") >= 1
			and GetVariable("ToggleDash") == 1 and GetVariable("MoveSpeedLevel") >= 0.8999999761581421 then
			FireRideEvent("W_RideGallop", "W_RideGallop", FALSE)
			return
		elseif GetVariable("MoveSpeedLevel") >= 0.6000000238418579 then
			FireRideEvent("W_RideDash", "W_RideDash", FALSE)
			return
		elseif GetVariable("MoveSpeedLevel") > 0 then
			FireRideEvent("W_RideWalk", "W_RideWalk", FALSE)
			return
		else
			FireRideEvent("W_RideIdle", "W_RideIdle", FALSE)
			return
		end
	end
	if env(IsAnimEnd, 0) == TRUE then
		FireRideEvent("W_RideFall_Loop", "W_RideFall_Loop", FALSE)
		return
	end
end

function RideFall_Loop_onUpdate()
	if RideFallCommonFunction() == TRUE then
		return
	end
	if env(GetSpiritspringJumpHeight) > 0 or env(GetSpEffectID, 183) == TRUE then
		act(AddSpEffect, 186)
	end

	if env(GetSpEffectID, 19935) == TRUE then
		if env(IsHamariFallDeath, 20) == TRUE and env(GetSpEffectID, 185) == FALSE then
			FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
			return
		end
	elseif env(IsHamariFallDeath, 12) == TRUE and env(GetSpEffectID, 185) == FALSE then
		FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
		return
	end
	if env(IsMountInFallLoop) == TRUE then
		local height = env(GetMountFallHeight)
		if IsLandDead(height / 100) == TRUE and env(GetSpEffectID, 185) == FALSE then
			FireRideEvent("W_RideDeath", "W_RideDeath", FALSE)
			return
		end
		if height < 900 then
			if GetVariable("MoveSpeedLevel") > 1.5 then
				FireRideEvent("W_RideJump_Land_To_Gallop", "W_RideJump_Land_To_Gallop", lower_only)
				return
			elseif GetVariable("MoveSpeedLevel") > 0.6000000238418579 then
				FireRideEvent("W_RideJump_Land_To_Dash", "W_RideJump_Land_To_Dash", lower_only)
				return
			end
		end
		FireRideEvent("W_RideFall_Land", "W_RideFall_Land", FALSE)
		return
	end
end

function RideFall_Land_onUpdate()
	if RideFallCommonFunction() == TRUE then
		return
	end
	if RideCommonFunction("W_RideAttack_R_Top", "W_RideAttack_R_Hard1_Start", "W_RideAttack_L_Top",
		"W_RideAttack_L_Hard1_Start") == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE or env(IsAnimEnd, 0) == TRUE then
		local moveType = RIDE_MOVE_TYPE_IDLE
		if env(IsAnimEnd, 0) == TRUE then
			moveType = RIDE_MOVE_TYPE_OTHER
		end
		if RideRequestFunction(moveType, TRUE, FALSE) == TRUE then
			return
		end
	end
end

function Jump_Activate()
	Jump_InitWeaponRef = FALSE
	Jump_LeftWeaponRef = FALSE
	ActivateRightArmAdd(START_FRAME_A02)
	ResetDamageCount()
end

function Jump_Update()
	UpdateRightArmAdd()
	if Jump_LeftWeaponRef == FALSE
		and (IsNodeActive("Jump_N Selector_Magic_Left") == TRUE or IsNodeActive("Jump_F Selector_Magic_Left") == TRUE
			or IsNodeActive("Jump_D Selector_Magic_Left") == TRUE or IsNodeActive("Jump_Loop_Magic_Left_CMSG") == TRUE
			or IsNodeActive("Jump_Land_Common_Magic_Left_Swing_Selector") == TRUE
			or IsNodeActive("JumpMagic_Start_Falling_ConditionSelector_Left") == TRUE
			or IsNodeActive("JumpMagic_Start_Falling_F_ConditionSelector_Left") == TRUE
			or IsNodeActive("JumpMagic_Start_Falling_D_ConditionSelector_Left") == TRUE
			or IsNodeActive("JumpMagic_Start_Falling_D_ConditionSelector_Left") == TRUE) then
		SetAttackHand(HAND_LEFT)
		SetGuardHand(HAND_LEFT)
		Jump_InitWeaponRef = TRUE
		Jump_LeftWeaponRef = TRUE
	end

	if Jump_InitWeaponRef == FALSE then
		local hand = HAND_RIGHT

		if c_Style == HAND_LEFT_BOTH then
			hand = HAND_LEFT
		end

		SetAttackHand(hand)
		SetGuardHand(hand)
		Jump_InitWeaponRef = TRUE
		act(SetThrowPossibilityState_Defender, 400000)
	end
end

function JumpAttackRight_Activate()
	SetAttackHand(HAND_RIGHT)
	SetGuardHand(HAND_LEFT)
end

function JumpAttackLeft_Activate()
	SetAttackHand(HAND_LEFT)
	SetGuardHand(HAND_LEFT)
end

function JumpAttackBoth_Activate()
	local hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end
	SetAttackHand(hand)
	SetGuardHand(hand)
end

-- Called from:
-- JumpAttack_Start_Falling_onUpdate
-- JumpAttack_Start_Falling_F_onUpdate
-- JumpAttack_Start_Falling_D_onUpdate
-- JumpCommonFunction
-- Jump_Loop_onUpdate
function Act_Jump()

	-- CUSTOM: Begin.
	if Game_IsPlayer() == TRUE then
		local JumpCancel_Bonus = 0
		if DMN_JumpCancel_Mode == GC_MODES.JUMP_CANCEL_INFINITE then
			JumpCancel_Bonus = 3
		end

		Movement_AdjustMultiplier(DMN_JumpHeight_Level + JumpCancel_Bonus)
	end
	-- CUSTOM: End.

	SetEnableAimMode()

	if env(GetSpEffectID, 32) == FALSE then
		SetThrowAtkInvalid()
	end

	local damage_type = env(GetReceivedDamageType)

	if damage_type == DAMAGE_TYPE_DEATH_FALLING then
		ExecEventAllBody("W_FallDeath")
		return TRUE
	elseif env(GetHP) <= 0
		and (env(GetSpecialAttribute) == DAMAGE_ELEMENT_POISON or env(GetSpecialAttribute) == DAMAGE_ELEMENT_BLIGHT) then
		SetVariable("IndexDeath", DEATH_TYPE_POISON)
		ExecEventAllBody("W_DeathStart")
		return TRUE
	end

	local height = env(GetFallHeight) / 100

	if env(IsTruelyLanding) == TRUE and IsLandDead(height) == TRUE then
		if height > 8 then
			SetVariable("IndexDeath", DEATH_TYPE_LAND)
		else
			SetVariable("IndexDeath", DEATH_TYPE_LAND_LOW)
		end

		ExecEventAllBody("W_DeathStart")
		return TRUE
	end
	if ExecDamage(FALSE, FALSE) == TRUE then
		return TRUE
	end
end

function ExecArrowBothJumpLandAttack()
	local is_both_arrow = FALSE
	local is_both_large_arrow = FALSE
	local is_both_ballista = FALSE
	local arrowHand = 0
	local fireEvent = Event_AttackArrowRightFireMove
	local loopEvent = Event_AttackArrowRightLoop

	if c_Style == HAND_RIGHT_BOTH then
		is_both_large_arrow = GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_LARGE_ARROW)
		is_both_ballista = GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_BALLISTA)
		arrowHand = 1

		if is_both_ballista == TRUE then
			fireEvent = Event_AttackCrossbowBothRightFire
			loopEvent = Event_AttackCrossbowBothRightLoop
		end
	elseif c_Style == HAND_LEFT_BOTH then
		is_both_large_arrow = GetEquipType(HAND_LEFT, WEAPON_CATEGORY_LARGE_ARROW, WEAPON_CATEGORY_BALLISTA)
		is_both_ballista = GetEquipType(HAND_LEFT, WEAPON_CATEGORY_BALLISTA)
		arrowHand = 0

		if is_both_ballista == TRUE then
			fireEvent = Event_AttackCrossbowBothRightFire
			loopEvent = Event_AttackCrossbowBothRightLoop
		else
			fireEvent = Event_AttackArrowLeftFireMove
			loopEvent = Event_AttackArrowLeftLoop
		end
	end

	if is_both_large_arrow == FALSE and is_both_ballista == FALSE then
		return FALSE
	end
	if g_ArrowSlot == 0 then
		act(ChooseBowAndArrowSlot, 0)
		if env(IsOutOfAmmo, arrowHand) == TRUE then
			if is_both_ballista == TRUE then
				ExecEventHalfBlend(Event_AttackCrossbowBothRightEmpty, ALLBODY)
			else
				ExecEventAllBody("W_NoArrow")
			end
			return TRUE
		end
		if 0 < env(ActionDuration, ACTION_ARM_R1) then
			ExecEventHalfBlend(loopEvent, ALLBODY)
			return TRUE
		elseif 1 <= GetVariable("JumpAttack_HandCondition") then
			ExecEventHalfBlend(fireEvent, ALLBODY)
			return TRUE
		end
	else
		act(ChooseBowAndArrowSlot, 1)

		if env(IsOutOfAmmo, arrowHand) == TRUE then
			if is_both_ballista == TRUE then
				ExecEventHalfBlend(Event_AttackCrossbowBothRightEmpty, ALLBODY)
			else
				ExecEventAllBody("W_NoArrow")
			end
			return TRUE
		end
		if 0 < env(ActionDuration, ACTION_ARM_R2) then
			ExecEventHalfBlend(loopEvent, ALLBODY)
			return TRUE
		elseif 1 <= GetVariable("JumpAttack_HandCondition") then
			ExecEventHalfBlend(fireEvent, ALLBODY)
			return TRUE
		end
	end
	return FALSE
end

function JumpAttack_Start_Falling_onActivate()
	act(ResetInputQueue)
	act(AIJumpState)
	SetAIActionState()
end

function JumpAttack_Start_Falling_onUpdate()
	act(AIJumpState)
	SetAIActionState()

	if Act_Jump() == TRUE then
		return
	end
	if GetVariable("JumpAttackFormRequest") == 0 then
		SetVariable("JumpAttackForm", 1)
	elseif GetVariable("JumpAttackFormRequest") == 1 then
		SetVariable("JumpAttackForm", 2)
	elseif GetVariable("JumpAttackFormRequest") == 2 then
		SetVariable("JumpAttackForm", 3)
	end

	if env(GetSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE and env(GetSpEffectID, 140) == FALSE
		and GetVariable("JumpAttack_Land") == 0 then
		local height = env(GetFallHeight) / 100
		local landIndex = GetLandIndex(height, FALSE)
		if landIndex == LAND_HEAVY then
			SetVariable("JumpAttack_Land", 2)
		else
			SetVariable("JumpAttack_Land", 1)
		end
		return
	end
	if env(GetSpEffectID, 146) == TRUE then
		if GetVariable("JumpAttack_Land") == 2 then
			SetVariable("SwingPose", 5)
		else
			SetVariable("SwingPose", 4)
		end
		hkbFireEvent("W_Jump_Land_N")
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE and ExecArrowBothJumpLandAttack() == TRUE then
		return
	end
	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLight2", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLightStep", "W_AttackBothHeavy1Start", QUICKTYPE_ROLLING) == TRUE then
		return
	end
end

function JumpAttack_Start_Falling_F_onActivate()
	act(ResetInputQueue)
	act(AIJumpState)
	SetAIActionState()
end

function JumpAttack_Start_Falling_F_onUpdate()
	act(AIJumpState)
	SetAIActionState()

	if Act_Jump() == TRUE then
		return
	end
	if GetVariable("JumpAttackFormRequest") == 0 then
		SetVariable("JumpAttackForm", 1)
	elseif GetVariable("JumpAttackFormRequest") == 1 then
		SetVariable("JumpAttackForm", 2)
	elseif GetVariable("JumpAttackFormRequest") == 2 then
		SetVariable("JumpAttackForm", 3)
	end

	if GetVariable("JumpAttackForm") >= 0 then
	end

	if env(GetSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE and env(GetSpEffectID, 140) == FALSE then
		SetVariable("JumpAttack_Land", 1)
		return
	end
	if env(GetSpEffectID, 146) == TRUE then
		SetVariable("SwingPose", 4)
		hkbFireEvent("W_Jump_Land_F")
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE and ExecArrowBothJumpLandAttack() == TRUE then
		return
	end
	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLight2", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLightStep", "W_AttackBothHeavy1Start", QUICKTYPE_ROLLING) == TRUE then
		return
	end
end

function JumpAttack_Start_Falling_D_onActivate()
	act(ResetInputQueue)
	act(AIJumpState)
	SetAIActionState()
end

function JumpAttack_Start_Falling_D_onUpdate()
	act(AIJumpState)
	SetAIActionState()

	if Act_Jump() == TRUE then
		return
	end
	if GetVariable("JumpAttackFormRequest") == 0 then
		SetVariable("JumpAttackForm", 1)
	elseif GetVariable("JumpAttackFormRequest") == 1 then
		SetVariable("JumpAttackForm", 2)
	elseif GetVariable("JumpAttackFormRequest") == 2 then
		SetVariable("JumpAttackForm", 3)
	end

	if GetVariable("JumpAttackForm") >= 0 then
	end

	if env(GetSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE and env(GetSpEffectID, 140) == FALSE then
		SetVariable("JumpAttack_Land", 1)
		return
	end
	if env(GetSpEffectID, 146) == TRUE then
		SetVariable("SwingPose", 4)
		hkbFireEvent("W_Jump_Land_D")
		return
	end
	if env(GetEventEzStateFlag, 0) == TRUE and ExecArrowBothJumpLandAttack() == TRUE then
		return
	end
	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLight2", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLightStep", "W_AttackBothHeavy1Start", QUICKTYPE_ROLLING) == TRUE then
		return
	end
end

function JumpCommonFunction(jump_type)
	act(AIJumpState)

	if GetVariable("JumpAttackForm") == 0 then
		act(NotifyAIOfBehaviourState, IDX_AINOTE_STATETYPE, IDX_AINOTE_STATETYPE_JUMP_NONATTACK)
	elseif env(GetSpEffectID, 102050) == TRUE then
		act(LockonFixedAngleCancel)
	end

	act(DisallowAdditiveTurning, TRUE)
	local height = env(GetFallHeight) / 100
	local equip_arm_no = 1

	if c_Style == HAND_LEFT_BOTH then
		equip_arm_no = 0
	end

	-- Jump
	if Act_Jump() == TRUE then
		return TRUE
	end
	-- Jump Fall
	if env(GetSpEffectID, 145) == FALSE and GetVariable("JumpAttack_Land") == 0 then
		hkbFireEvent("W_Jump_Loop")
		return TRUE
	end

	local arrowHand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		arrowHand = HAND_LEFT
	end

	local is_arrow = GetEquipType(arrowHand, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW,
		WEAPON_CATEGORY_LARGE_ARROW, WEAPON_CATEGORY_CROSSBOW, WEAPON_CATEGORY_BALLISTA)

	if GetVariable("JumpAttackForm") == 0 and is_arrow == TRUE then
		if env(ActionRequest, ACTION_ARM_R1) == TRUE then
			act(ChooseBowAndArrowSlot, 0)
			g_ArrowSlot = 0
		elseif env(ActionRequest, ACTION_ARM_R2) == TRUE then
			act(ChooseBowAndArrowSlot, 1)
			g_ArrowSlot = 1
		end
	end

	local is_staff = GetEquipType(equip_arm_no, WEAPON_CATEGORY_STAFF)
	local wep_hand = HAND_RIGHT

	if c_Style == HAND_LEFT_BOTH then
		wep_hand = HAND_LEFT
	end

	local isWeaponStaff = FALSE
	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)

	if IsWeaponCatalyst(sp_kind) == TRUE then
		isWeaponStaff = TRUE
	end

	-- Magic
	if ExecJumpMagic(jump_type) == TRUE then
		-- Catalyst: R1
	elseif is_staff == TRUE and env(ActionRequest, ACTION_ARM_R1) == TRUE then
		-- Weapon Catalyst: R2
	elseif isWeaponStaff == TRUE and env(ActionRequest, ACTION_ARM_R2) == TRUE then
		-- Bow
	elseif is_arrow == TRUE and (c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH) and env(IsOutOfAmmo, arrowHand)
		== TRUE then
		-- Crossbow
	elseif GetEquipType(arrowHand, WEAPON_CATEGORY_CROSSBOW) == TRUE
		and (env(GetBoltLoadingState, arrowHand) == FALSE or env(IsOutOfAmmo, arrowHand) == TRUE) then
		-- Jump Attack
	elseif env(GetSpEffectID, 140) == TRUE and GetVariable("JumpAttackForm") == 0 then
		if env(ActionRequest, ACTION_ARM_R1) == TRUE or is_arrow == TRUE and env(ActionRequest, ACTION_ARM_R2) == TRUE then

			-- CUSTOM: Begin.
			if Game_IsPlayer() == TRUE then
				if Game_IsDualWielding() == TRUE then
					ExecEventSync("Event_JumpNormalAttack_Add")
					SetVariable("JumpAttackFormRequest", 2)
					SetVariable("JumpAttackForm", 3)
					SetInterruptType(INTERRUPT_FINDATTACK)
					act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
					SetAIActionState()

					return TRUE
				end
			end
			-- CUSTOM: End.

			ExecEventSync("Event_JumpNormalAttack_Add")
			SetVariable("JumpAttackFormRequest", 0)
			SetVariable("JumpAttackForm", 1)
			SetInterruptType(INTERRUPT_FINDATTACK)
			act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
			SetAIActionState()

			return TRUE
		elseif env(ActionRequest, ACTION_ARM_R2) == TRUE then
			ExecEventSync("Event_JumpNormalAttack_Add")
			SetVariable("JumpAttackFormRequest", 1)
			SetVariable("JumpAttackForm", 2)
			SetInterruptType(INTERRUPT_FINDATTACK)
			act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
			SetAIActionState()

			return TRUE
		elseif env(ActionRequest, ACTION_ARM_L1) == TRUE and IsEnableDualWielding() == HAND_RIGHT then
			ExecEventSync("Event_JumpNormalAttack_Add")
			SetVariable("JumpAttackFormRequest", 2)
			SetVariable("JumpAttackForm", 3)
			SetInterruptType(INTERRUPT_FINDATTACK)
			act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
			SetAIActionState()

			return TRUE
		end
		if env(GetSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE and env(GetSpEffectID, 140) == FALSE then
			if jump_type == 0 then
				SetVariable("JumpAttack_Land", 1)
				SetVariable("JumpMotion_Override", 0)
				if GetVariable("JumpMotion_Override") < 0.009999999776482582 then
					SetVariable("JumpUseMotion_Bool", 1)
				end
			elseif jump_type >= 1 then
				ExecEventAllBody("W_Jump_Attack_Land_F")
			end

			return TRUE
		end
	elseif env(GetSpEffectID, 140) == FALSE and GetVariable("JumpAttack_Land") == 0 and GetVariable("JumpAttackForm")
		== 0 then
		SetVariable("JumpAttack_Land", 0)

		if env(ActionRequest, ACTION_ARM_R1) == TRUE or is_arrow == TRUE and env(ActionRequest, ACTION_ARM_R2) == TRUE then

			-- CUSTOM: Begin.
			if Game_IsPlayer() == TRUE then
				if Game_IsDualWielding() == TRUE then
					SetInterruptType(INTERRUPT_FINDATTACK)
					act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
					SetAIActionState()
					SetVariable("JumpAttackFormRequest", 2)
					if jump_type == 0 then
						ExecEventNoReset("W_JumpAttack_Start_Falling")
					elseif jump_type == 1 then
						ExecEventNoReset("W_JumpAttack_Start_Falling_F")
					elseif jump_type == 2 then
						ExecEventNoReset("W_JumpAttack_Start_Falling_D")
					end

					return TRUE
				end
			end
			-- CUSTOM: End.

			SetVariable("JumpAttackFormRequest", 0)
			SetInterruptType(INTERRUPT_FINDATTACK)
			act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
			SetAIActionState()

			if jump_type == 0 then
				ExecEventNoReset("W_JumpAttack_Start_Falling")
			elseif jump_type == 1 then
				ExecEventNoReset("W_JumpAttack_Start_Falling_F")
			elseif jump_type == 2 then
				ExecEventNoReset("W_JumpAttack_Start_Falling_D")
			end

			return TRUE
		elseif env(ActionRequest, ACTION_ARM_R2) == TRUE then
			SetVariable("JumpAttackFormRequest", 1)
			SetInterruptType(INTERRUPT_FINDATTACK)
			act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
			SetAIActionState()
			if jump_type == 0 then
				ExecEventNoReset("W_JumpAttack_Start_Falling")
			elseif jump_type == 1 then
				ExecEventNoReset("W_JumpAttack_Start_Falling_F")
			elseif jump_type == 2 then
				ExecEventNoReset("W_JumpAttack_Start_Falling_D")
			end

			return TRUE
		elseif env(ActionRequest, ACTION_ARM_L1) == TRUE and IsEnableDualWielding() == HAND_RIGHT then
			SetInterruptType(INTERRUPT_FINDATTACK)
			act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
			SetAIActionState()
			SetVariable("JumpAttackFormRequest", 2)
			if jump_type == 0 then
				ExecEventNoReset("W_JumpAttack_Start_Falling")
			elseif jump_type == 1 then
				ExecEventNoReset("W_JumpAttack_Start_Falling_F")
			elseif jump_type == 2 then
				ExecEventNoReset("W_JumpAttack_Start_Falling_D")
			end

			return TRUE
		end
	end
	-- Landing
	if env(GetSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE and env(GetSpEffectID, 140) == FALSE
		and env(IsAIJumping) == FALSE then
		local landIndex = GetLandIndex(height, FALSE)
		SetVariable("LandIndex", landIndex)

		if GetVariable("JumpAttackForm") == 0 then
			local JumpMoveLevel = 0

			if GetVariable("MoveSpeedLevel") > 1.100000023841858 then
				JumpMoveLevel = 2
			elseif GetVariable("MoveSpeedLevel") > 0.6000000238418579 then
				JumpMoveLevel = 1
			end

			-- Ironjar Aromatic
			if TRUE == env(GetSpEffectID, 503520) then
				JumpMoveLevel = 0
				-- Unknown
			elseif TRUE == env(GetSpEffectID, 5520) then
				JumpMoveLevel = 0
				-- Slug: Slow
			elseif TRUE == env(GetSpEffectID, 425) then
				JumpMoveLevel = 0
				-- Sanguine Noble: Slow
			elseif TRUE == env(GetSpEffectID, 4101) then
				JumpMoveLevel = 0
				-- Sanguine Noble: Slow
			elseif TRUE == env(GetSpEffectID, 4100) then
				JumpMoveLevel = 0
			elseif env(GetSpEffectID, 19670) == TRUE then
				JumpMoveLevel = 0
			end

			if JumpMoveLevel == 2 then
				hkbFireEvent("W_Jump_Land_To_Dash")
			elseif JumpMoveLevel == 1 then
				SetVariable("JumpLandMoveDirection", GetVariable("MoveDirection"))
				hkbFireEvent("W_Jump_Land_To_Run")
			elseif jump_type == 0 then
				ExecEventNoReset("W_Jump_Land_N")
			elseif jump_type == 1 then
				ExecEventNoReset("W_Jump_Land_F")
			elseif jump_type == 2 then
				ExecEventNoReset("W_Jump_Land_D")
			end

			return TRUE
		else
			if jump_type == 0 then
				SetVariable("JumpAttack_Land", 1)
				SetVariable("JumpMotion_Override", 0)

				if GetVariable("JumpMotion_Override") < 0.009999999776482582 then
					SetVariable("JumpUseMotion_Bool", 1)
				end
			elseif jump_type >= 1 then
				ExecEventAllBody("W_Jump_Attack_Land_F")
			end
			return TRUE
		end
		-- 146 "[HKS] Swing Window"
	elseif env(GetSpEffectID, 146) == TRUE and GetVariable("JumpAttackForm") ~= 0 then
		SetVariable("SwingPose", 4)

		if jump_type == 0 then
			ExecEventNoReset("W_Jump_Land_N")
		elseif jump_type == 1 then
			ExecEventNoReset("W_Jump_Land_F")
		elseif jump_type == 2 then
			ExecEventNoReset("W_Jump_Land_D")
		end

		return TRUE
	elseif env(GetEventEzStateFlag, 0) == TRUE and GetVariable("JumpAttackForm") ~= 0 and ExecArrowBothJumpLandAttack()
		== TRUE then
		return TRUE
	end
	return FALSE
end

function ExecJumpMagic(jump_type)
	if c_HasActionRequest == FALSE then
		return FALSE
	end

	local wep_hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		wep_hand = HAND_LEFT
	end

	local buttonR = ACTION_ARM_MAGIC_R
	local buttonL = ACTION_ARM_MAGIC_L

	local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, wep_hand)
	if IsWeaponCatalyst(sp_kind) == TRUE then
		buttonR = ACTION_ARM_MAGIC_R2
	end

	local sp_kind_L = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)
	if c_Style == HAND_RIGHT and IsWeaponCatalyst(sp_kind_L) == TRUE then
		buttonL = ACTION_ARM_MAGIC_L2
	end

	if env(ActionRequest, buttonR) == FALSE and env(ActionRequest, buttonL) == FALSE then
		return FALSE
	end
	if env(GetStamina) <= 0 then
		ResetRequest()
		return FALSE
	end
	if GetVariable("JumpAttackForm") >= 1 or IS_ATTACKED_JUMPMAGIC == TRUE then
		ResetRequest()
		return FALSE
	end
	if env(IsMagicUseMenuOpened) == TRUE then
		return FALSE
	end

	local style = c_Style
	local magic_hand = HAND_RIGHT
	local wep_hand = HAND_RIGHT
	local delayActRequestNo = -1
	local is_samagic = FALSE

	if env(ActionRequest, buttonR) == TRUE then
		delayActRequestNo = ACTION_ARM_MAGIC_R

		if style == HAND_LEFT_BOTH then
			if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_STAFF) == FALSE and IsWeaponCatalyst(sp_kind) == FALSE then
				return FALSE
			end

			wep_hand = HAND_LEFT
		else
			if GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_STAFF) == FALSE and IsWeaponCatalyst(sp_kind) == FALSE then
				return FALSE
			end

			wep_hand = HAND_RIGHT
		end
	elseif env(ActionRequest, buttonL) == TRUE then
		delayActRequestNo = ACTION_ARM_MAGIC_L
		if style == HAND_RIGHT_BOTH or style == HAND_LEFT_BOTH then
			return FALSE
		end
		if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_STAFF) == FALSE and IsWeaponCatalyst(sp_kind_L) == FALSE then
			return FALSE
		end

		wep_hand = HAND_LEFT
		magic_hand = HAND_LEFT
		act(DebugLogOutput, "MagicLeft")
	else
		return FALSE
	end

	act(DecideMagicUse)
	act(NotifyAIMagicCast)

	if IsJumpMagic() == FALSE and IsQuickMagic() == FALSE then
		ResetRequest()
		return FALSE
	end
	if env(IsMagicUseable, wep_hand, 0) == FALSE then
		ResetRequest()
		return FALSE
	end

	local magic_index = env(GetMagicAnimType)

	if magic_index == 254 or magic_index == 255 then
		ResetRequest()
		return FALSE
	end

	local is_atk_auto_aim = FALSE

	if magic_index == MAGIC_REQUEST_WHIP or magic_index == MAGIC_REQUEST_SLASH or magic_index == MAGIC_REQUEST_QUICKSLASH
		or magic_index == MAGIC_REQUEST_FLAME_GRAB or magic_index == MAGIC_REQUEST_CRUSH or magic_index
		== MAGIC_REQUEST_CHOP or magic_index == MAGIC_REQUEST_SCYTHE then
		is_atk_auto_aim = TRUE
	end

	if IsJumpMagic() == TRUE then
		if magic_hand == HAND_RIGHT then
			ExecEventHalfBlend(Event_MagicFireRightJump, ALLBODY)
		else
			ExecEventHalfBlend(Event_MagicFireLeftJump, ALLBODY)
		end

		IS_ATTACKED_JUMPMAGIC = TRUE
		act(SetIsMagicInUse, TRUE)
		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()

		return TRUE
	elseif env(GetSpEffectID, 140) == TRUE and GetVariable("JumpAttackForm") == 0 then
		ExecEventSync("Event_JumpNormalAttack_Add")
		SetVariable("JumpAttackFormRequest", 3)
		SetVariable("JumpAttackForm", 4)

		if wep_hand == HAND_LEFT and c_Style == HAND_RIGHT then
			SetVariable("JumpAttack_HandCondition", 2)
		else
			SetVariable("JumpAttack_HandCondition", 0)
		end

		act(SetIsMagicInUse, TRUE)
		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()

		return TRUE
	elseif env(GetSpEffectID, 140) == FALSE and GetVariable("JumpAttack_Land") == 0 and GetVariable("JumpAttackForm")
		== 0 then
		SetVariable("JumpAttack_Land", 0)
		SetVariable("JumpAttackFormRequest", 3)
		SetVariable("JumpAttackForm", 4)

		if wep_hand == HAND_LEFT and c_Style == HAND_RIGHT then
			SetVariable("JumpAttack_HandCondition", 2)
		else
			SetVariable("JumpAttack_HandCondition", 0)
		end

		if jump_type == 0 then
			ExecEventNoReset("W_JumpAttack_Start_Falling")
		elseif jump_type == 1 then
			ExecEventNoReset("W_JumpAttack_Start_Falling_F")
		elseif jump_type == 2 then
			ExecEventNoReset("W_JumpAttack_Start_Falling_D")
		end

		act(SetIsMagicInUse, TRUE)
		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()

		return TRUE
	end
end

function ExecFallMagic()
	if c_HasActionRequest == FALSE then
		return FALSE
	end
	if env(ActionRequest, ACTION_ARM_MAGIC_R) == FALSE and env(ActionRequest, ACTION_ARM_MAGIC_L) == FALSE
		and env(ActionRequest, ACTION_ARM_MAGIC_R2) == FALSE and env(ActionRequest, ACTION_ARM_MAGIC_L2) == FALSE then
		return FALSE
	end
	if env(GetStamina) <= 0 then
		ResetRequest()
		return FALSE
	end
	if GetVariable("JumpAttackForm") >= 1 or IS_ATTACKED_JUMPMAGIC == TRUE then
		ResetRequest()
		return FALSE
	end
	if env(IsMagicUseMenuOpened) == TRUE then
		return FALSE
	end

	local style = c_Style
	local magic_hand = HAND_RIGHT
	local wep_hand = HAND_RIGHT
	local delayActRequestNo = -1
	local is_samagic = FALSE

	if env(ActionRequest, ACTION_ARM_MAGIC_R) == TRUE then
		delayActRequestNo = ACTION_ARM_MAGIC_R
		if style == HAND_LEFT_BOTH then
			if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_STAFF) == FALSE then
				return FALSE
			end

			wep_hand = HAND_LEFT
		else
			if GetEquipType(HAND_RIGHT, WEAPON_CATEGORY_STAFF) == FALSE then
				return FALSE
			end

			wep_hand = HAND_RIGHT
		end
	elseif env(ActionRequest, ACTION_ARM_MAGIC_L) == TRUE then
		delayActRequestNo = ACTION_ARM_MAGIC_L
		if style == HAND_RIGHT_BOTH or style == HAND_LEFT_BOTH then
			return FALSE
		end
		if GetEquipType(HAND_LEFT, WEAPON_CATEGORY_STAFF) == FALSE then
			return FALSE
		end

		wep_hand = HAND_LEFT
		magic_hand = HAND_LEFT
		act(DebugLogOutput, "MagicLeft")
	elseif env(ActionRequest, ACTION_ARM_MAGIC_R2) == TRUE then
		delayActRequestNo = ACTION_ARM_MAGIC_R2

		if style == HAND_LEFT_BOTH then
			local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)

			if IsWeaponCatalyst(sp_kind) == FALSE then
				return FALSE
			end

			wep_hand = HAND_LEFT
		else
			local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_RIGHT)

			if IsWeaponCatalyst(sp_kind) == FALSE then
				return FALSE
			end

			wep_hand = HAND_RIGHT
		end
	elseif env(ActionRequest, ACTION_ARM_MAGIC_L2) == TRUE then
		delayActRequestNo = ACTION_ARM_MAGIC_L2

		if style == HAND_RIGHT_BOTH or style == HAND_LEFT_BOTH then
			return FALSE
		end

		local sp_kind = env(GetEquipWeaponSpecialCategoryNumber, HAND_LEFT)

		if IsWeaponCatalyst(sp_kind) == FALSE then
			return FALSE
		end

		wep_hand = HAND_LEFT
		magic_hand = HAND_LEFT
		act(DebugLogOutput, "MagicLeft")
	else
		return FALSE
	end

	act(DecideMagicUse)
	act(NotifyAIMagicCast)

	if IsJumpMagic() == FALSE and IsQuickMagic() == FALSE then
		ResetRequest()
		return FALSE
	end
	if env(IsMagicUseable, wep_hand, 0) == FALSE then
		ResetRequest()
		return FALSE
	end

	local magic_index = env(GetMagicAnimType)

	if magic_index == 254 or magic_index == 255 then
		ResetRequest()
		return FALSE
	end

	local is_atk_auto_aim = FALSE

	if magic_index == MAGIC_REQUEST_WHIP or magic_index == MAGIC_REQUEST_SLASH or magic_index == MAGIC_REQUEST_QUICKSLASH
		or magic_index == MAGIC_REQUEST_FLAME_GRAB or magic_index == MAGIC_REQUEST_CRUSH or magic_index
		== MAGIC_REQUEST_CHOP or magic_index == MAGIC_REQUEST_SCYTHE then
		is_atk_auto_aim = TRUE
	end

	if IsJumpMagic() == TRUE then
		if magic_hand == HAND_RIGHT then
			ExecEventHalfBlend(Event_MagicFireRightJump, ALLBODY)
		else
			ExecEventHalfBlend(Event_MagicFireLeftJump, ALLBODY)
		end

		IS_ATTACKED_JUMPMAGIC = TRUE
		act(SetIsMagicInUse, TRUE)
		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()

		return TRUE
	else

		SetVariable("JumpAttack_Land", 0)
		SetVariable("JumpAttackFormRequest", 3)
		SetVariable("JumpAttackForm", 4)

		if wep_hand == HAND_LEFT and c_Style == HAND_RIGHT then
			SetVariable("JumpAttack_HandCondition", 2)
		else
			SetVariable("JumpAttack_HandCondition", 0)
		end

		ExecEventNoReset("W_JumpAttack_Start_Falling")
		act(SetIsMagicInUse, TRUE)
		act(SetNpcAIAttackRequestIDAfterBlend, env(GetNpcAIAttackRequestID))
		SetAIActionState()

		return TRUE
	end
end

function Jump_Overweight_onActivate()
	SetAIActionState()
end

function Jump_Overweight_onUpdate()
	SetAIActionState()

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", QUICKTYPE_ROLLING) == TRUE then
		return
	end
end

function Jump_Overweight_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function Jump_N_onActivate()
	act(AIJumpState)
	SetAIActionState()
end

function Jump_N_onUpdate()
	SetAIActionState()
	JUMP_STATE_1 = 1
	JUMP_STATE_2 = 0
	JUMP_STATE_3 = 0

	if GetVariable("JumpReachSelector") == 0 and 0 < GetVariable("MoveSpeedLevel") then
		SetVariable("JumpReachSelector", 1)

		if GetVariable("IsLockon") == true then
			local jumpangle = GetVariable("MoveAngle")
			if jumpangle > -45 and jumpangle < 45 then
				SetVariable("JumpDirection", 0)
			elseif jumpangle >= 45 and jumpangle <= 135 then
				SetVariable("JumpDirection", 3)
			elseif jumpangle >= -135 and jumpangle <= -45 then
				SetVariable("JumpDirection", 2)
			else
				SetVariable("JumpDirection", 1)
			end
		else
			SetVariable("JumpDirection", 0)
		end
	end

	if JumpCommonFunction(0) == TRUE then
		return
	end
end

function Jump_N_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function Jump_F_onActivate()
	act(AIJumpState)
	SetAIActionState()
end

function Jump_F_onUpdate()
	SetAIActionState()
	JUMP_STATE_1 = 0
	JUMP_STATE_2 = 1
	JUMP_STATE_3 = 0

	local rolling_angle = GetVariable("JumpAngle")
	local addratio = 0.4000000059604645
	local endratio = 1
	endratio = 1 + addratio * math.abs(math.sin(math.rad(2 * rolling_angle)))
	endratio = math.abs(endratio)
	act(SetMovementScaleMult, endratio)

	if JumpCommonFunction(1) == TRUE then
		return
	end
end

function Jump_F_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function Jump_D_onActivate()
	act(AIJumpState)
	SetAIActionState()
end

function Jump_D_onUpdate()
	SetAIActionState()
	JUMP_STATE_1 = 0
	JUMP_STATE_2 = 0
	JUMP_STATE_3 = 1

	if GetVariable("JumpAttackForm") == 0 then
		act(LockonFixedAngleCancel)
	end

	if JumpCommonFunction(2) == TRUE then
		return
	end
end

function Jump_D_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function Jump_RideOff_onActivate()
	act(AIJumpState)
	SetAIActionState()
end

function Jump_RideOff_onUpdate()
	SetAIActionState()
	JUMP_STATE_1 = 0
	JUMP_STATE_2 = 0
	JUMP_STATE_3 = 1

	if GetVariable("JumpAttackForm") == 0 then
		act(LockonFixedAngleCancel)
	end

	if JumpCommonFunction(2) == TRUE then
		act(Dismount)
		return
	end
end

function Jump_RideOff_onDeactivate()
	act(Dismount)
	act(DisallowAdditiveTurning, FALSE)
end

function Jump_Loop_onActivate()
	SetAIActionState()
end

function Jump_Loop_onUpdate()
	SetAIActionState()
	act(DisallowAdditiveTurning, TRUE)

	if env(GetSpEffectID, 19935) == TRUE then
		if env(IsHamariFallDeath, 20) == TRUE then
			ExecEvent("W_FallDeath")
			return
		end
	elseif env(IsHamariFallDeath, 12) == TRUE then
		ExecEvent("W_FallDeath")
		return
	end

	local height = env(GetFallHeight) / 100

	if not (height >= 60) or env(GetStateChangeType, 266) == TRUE then
	else
		ExecEventAllBody("W_FallDeath")
		return TRUE
	end
	if Act_Jump() == TRUE then
		return
	end

	local equip_arm_no = 1

	if c_Style == HAND_LEFT_BOTH then
		equip_arm_no = 0
	end

	local arrowHand = 1

	if c_Style == HAND_LEFT_BOTH then
		arrowHand = 0
	end

	local is_arrow = GetEquipType(arrowHand, WEAPON_CATEGORY_SMALL_ARROW, WEAPON_CATEGORY_ARROW,
		WEAPON_CATEGORY_LARGE_ARROW, WEAPON_CATEGORY_CROSSBOW, WEAPON_CATEGORY_BALLISTA)

	if is_arrow == TRUE then
		if env(ActionRequest, 0) == TRUE then
			act(ChooseBowAndArrowSlot, 0)
			g_ArrowSlot = 0
		elseif env(ActionRequest, 1) == TRUE then
			act(ChooseBowAndArrowSlot, 1)
			g_ArrowSlot = 1
		end
	end

	if ExecJumpMagic(0) == TRUE then
	elseif env(GetEquipWeaponCategory, equip_arm_no) == WEAPON_CATEGORY_STAFF and env(ActionRequest, 0) == TRUE then
	elseif is_arrow == TRUE
		and (c_Style == HAND_RIGHT_BOTH or c_Style == HAND_LEFT_BOTH or GetEquipType(arrowHand, WEAPON_CATEGORY_CROSSBOW)
			== TRUE) and env(IsOutOfAmmo, arrowHand) == TRUE then
	elseif GetEquipType(arrowHand, WEAPON_CATEGORY_CROSSBOW) == TRUE and env(GetBoltLoadingState, arrowHand) == FALSE then
	elseif env(ActionRequest, ACTION_ARM_R1) == TRUE and GetVariable("JumpAttackForm") == 0 then
		SetVariable("JumpAttackForm", 1)
		SetVariable("JumpAttackFormRequest", 0)
		hkbFireEvent("W_JumpAttack_Start_Falling")
		return
	elseif env(ActionRequest, ACTION_ARM_R2) == TRUE and GetVariable("JumpAttackForm") == 0 then
		if is_arrow == TRUE then
			SetVariable("JumpAttackForm", 1)
			SetVariable("JumpAttackFormRequest", 0)
			hkbFireEvent("W_JumpAttack_Start_Falling")
			return
		end
		SetVariable("JumpAttackForm", 2)
		SetVariable("JumpAttackFormRequest", 1)
		hkbFireEvent("W_JumpAttack_Start_Falling")
		return
	elseif env(ActionRequest, ACTION_ARM_L1) == TRUE and IsEnableDualWielding() == HAND_RIGHT then
		SetVariable("JumpAttackForm", 3)
		SetVariable("JumpAttackFormRequest", 2)
		hkbFireEvent("W_JumpAttack_Start_Falling")
		return
	end

	if 1 <= GetVariable("JumpAttackForm") then
		act(ResetInputQueue)
	end

	local landIndex = GetLandIndex(height, FALSE)

	if env(GetSpEffectID, 141) == TRUE then
		SetVariable("SwingPose", 0)
	elseif env(GetSpEffectID, 142) == TRUE then
		SetVariable("SwingPose", 0)
	elseif env(GetSpEffectID, 143) == TRUE then
		SetVariable("SwingPose", 0)
	elseif env(GetSpEffectID, 144) == TRUE then
		if landIndex == LAND_HEAVY then
			SetVariable("SwingPose", 3)
		else
			SetVariable("SwingPose", 2)
		end
	elseif env(GetSpEffectID, 145) == TRUE then
		SetVariable("SwingPose", 4)
	elseif landIndex == LAND_HEAVY then
		SetVariable("SwingPose", 3)
	else
		SetVariable("SwingPose", 2)
	end

	if env(GetSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE then
		SetVariable("LandIndex", landIndex)
		local JumpMoveLevel = 0

		if landIndex == 0 and GetVariable("JumpAttackForm") == 0 then
			if GetVariable("MoveSpeedLevel") > 1.100000023841858 then
				JumpMoveLevel = 2
			elseif GetVariable("MoveSpeedLevel") > 0.6000000238418579 then
				JumpMoveLevel = 1
			end
		end

		if env(GetSpEffectID, 503520) == TRUE then
			JumpMoveLevel = 0
		elseif env(GetSpEffectID, 5520) == TRUE then
			JumpMoveLevel = 0
		elseif env(GetSpEffectID, 425) == TRUE then
			JumpMoveLevel = 0
		elseif env(GetSpEffectID, 4101) == TRUE then
			JumpMoveLevel = 0
		elseif env(GetSpEffectID, 4100) == TRUE then
			JumpMoveLevel = 0
		elseif env(GetSpEffectID, 19670) == TRUE then
			JumpMoveLevel = 0
		end

		if JumpMoveLevel == 2 then
			ExecEventNoReset("W_Jump_Land_To_Dash")
			return
		elseif JumpMoveLevel == 1 then
			SetVariable("JumpLandMoveDirection", GetVariable("MoveDirection"))
			ExecEventNoReset("W_Jump_Land_To_Run")
			return
		end

		if landIndex > 0 then
			ResetRequest()
		end

		if JUMP_STATE_1 == 1 then
			ExecEventNoReset("W_Jump_Land_N")
		elseif JUMP_STATE_2 == 1 then
			ExecEventNoReset("W_Jump_Land_F")
		elseif JUMP_STATE_3 == 1 then
			ExecEventNoReset("W_Jump_Land_D")
		else
			ExecEventNoReset("W_Jump_Land_N")
		end
		return
	end
end

function Jump_Loop_onDeactivate()
	act(DisallowAdditiveTurning, FALSE)
end

function Jump_LandAttack_Normal_onActivate()
	act(ResetInputQueue)
	SetAIActionState()
end

function Jump_LandAttack_Normal_onUpdate()
	SetAIActionState()

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLight2", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight2", "W_AttackBothHeavy1Start", QUICKTYPE_ROLLING) == TRUE then
		return
	end
end

function Jump_LandAttack_Normal_onDeactivate()
	SetVariable("JumpAttackForm", 0)
	SetVariable("SwingPose", 0)
end

function Jump_LandAttack_Hard_onActivate()
	act(ResetInputQueue)
	SetAIActionState()
end

function Jump_LandAttack_Hard_onUpdate()
	SetAIActionState()

	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLight2", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight2", "W_AttackBothHeavy1Start", QUICKTYPE_ROLLING) == TRUE then
		return
	end
end

function Jump_LandAttack_Hard_onDeactivate()
	SetVariable("JumpAttackForm", 0)
	SetVariable("SwingPose", 0)
end

function JumpLandCommonFunction()
	SetEnableAimMode()

	if env(GetSpEffectID, 141) == TRUE then
		if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_Jump_LandAttack_Normal", "W_Jump_LandAttack_Hard",
			"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_Jump_LandAttack_Normal", "W_Jump_LandAttack_Hard",
			QUICKTYPE_ROLLING) == TRUE then
			return TRUE
		end
	elseif GetVariable("JumpAttackForm") == 1 or GetVariable("JumpAttackForm") == 2 or GetVariable("JumpAttackForm") == 3 then
		if env(GetEventEzStateFlag, 0) == TRUE and ExecArrowBothJumpLandAttack() == TRUE then
			return TRUE
		end

		local r1 = "W_AttackRightLightSubStart"
		local b1 = "W_AttackBothLightSubStart"

		if g_ComboReset == TRUE then
			r1 = "W_AttackRightLight1"
			b1 = "W_AttackBothLight1"
		end

		if EvasionCommonFunction(FALL_TYPE_DEFAULT, r1, "W_AttackRightHeavy1Start", "W_AttackLeftLight2",
			"W_AttackLeftHeavy1", b1, "W_AttackBothHeavy1Start", QUICKTYPE_ROLLING) == TRUE then
			return TRUE
		end
	elseif EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLight1", "W_AttackRightHeavy1Start",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", QUICKTYPE_ROLLING)
		== TRUE then
		return TRUE
	end
	return FALSE
end

function Jump_Land_N_onUpdate()
	if JumpLandCommonFunction() == TRUE then
		return
	end
end

function Jump_Land_N_onDeactivate()
	SetVariable("JumpAttack_Land", 0)
end

function Jump_Land_F_onUpdate()
	if JumpLandCommonFunction() == TRUE then
		return
	end
end

function Jump_Land_D_onUpdate()
	if JumpLandCommonFunction() == TRUE then
		return
	end
end

function Jump_Attack_Land_F_onUpdate()
	if JumpLandCommonFunction() == TRUE then
		return
	end
	if env(GetSpEffectID, 146) == TRUE then
		SetVariable("SwingPose", 4)
		hkbFireEvent("W_Jump_Land_N")
		return
	end
end

function Jump_Land_To_Run_onUpdate()
	act(SwitchMotion, TRUE)
	SetEnableAimMode()
	SetVariable("JumpLandMoveDirection", GetVariable("MoveDirection"))
	SetVariable("MoveSpeedLevelReal", 1)

	if ExecStop() == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE and MoveStart(ALLBODY, Event_MoveLong, FALSE) == TRUE then
		return
	end
	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", QUICKTYPE_NORMAL) == TRUE then
		return
	end
end

function Jump_Land_To_Dash_onUpdate()
	act(LockonFixedAngleCancel)
	SetEnableAimMode()
	SetVariable("MoveSpeedLevelReal", 2)

	if ExecStop() == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE and MoveStart(ALLBODY, Event_MoveLong, FALSE) == TRUE then
		return
	end
	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLightDash", "W_AttackRightHeavyDash",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothDash", "W_AttackBothHeavyDash", QUICKTYPE_NORMAL)
		== TRUE then
		return
	end
end

function JumpDamage_Start_onActivate()
	act(ResetInputQueue)
end

function JumpDamage_Start_onUpdate()
	JUMP_STATE_1 = 1
	JUMP_STATE_2 = 0
	JUMP_STATE_3 = 0
	act(DenyEventAnimPlaybackRequest)
	local height = env(GetFallHeight) / 100
	local damage_type = env(GetReceivedDamageType)

	if env(GetSpEffectID, 19935) == TRUE then
		if env(IsHamariFallDeath, 20) == TRUE then
			ExecEventAllBody("W_FallDeath")
			return
		end
	elseif env(IsHamariFallDeath, 12) == TRUE then
		ExecEventAllBody("W_FallDeath")
		return
	end

	if env(GetSpEffectID, 98) == TRUE and env(IsTruelyLanding) == TRUE then
		hkbFireEvent("W_JumpDamage_Land")
		return
	end
end

function JumpDamage_Land_onActivate()
	act(ResetInputQueue)
end

function JumpDamage_Land_onUpdate()
	act(DenyEventAnimPlaybackRequest)
	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLight1", "W_AttackRightHeavy1Start", "W_AttackLeftLight1",
		"W_AttackLeftHeavy1", "W_AttackBothLight1", "W_AttackBothHeavy1Start", QUICKTYPE_ROLLING) == TRUE then
		return
	end
end

function SetStealthState(state)
	SetVariable("StealthState", state)
end

function Stealth_Deactivate()
	SetStealthState(STEALTH_NONE)
end

function StealthActionCommonFunction(fall_type, r1, r2, l1, l2, b1, b2, quick_type)
	SetAIActionState()
	SetEnableAimMode()
	if ExecPassiveAction(FALSE, fall_type, FALSE) == TRUE then
		return TRUE
	end
	if ExecJump() == TRUE then
		return TRUE
	end
	if ExecHandChange(HAND_RIGHT, FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecGuardOnCancelTiming(FALSE, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecWeaponChange(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecEvasion(FALSE, ESTEP_NONE, FALSE) == TRUE then
		return TRUE
	end
	if ExecItem(quick_type, ALLBODY) == TRUE then
		return TRUE
	end
	if ExecMagic(quick_type, ALLBODY, FALSE) == TRUE then
		return TRUE
	end
	if ExecArtsStanceOnCancelTiming(ALLBODY) == TRUE then
		return TRUE
	end
	if ExecAttack(r1, r2, l1, l2, b1, b2, FALSE, ALLBODY, FALSE, FALSE, FALSE) == TRUE then
		return TRUE
	end
	if MoveStartonCancelTiming(Event_MoveLong, FALSE) == TRUE then
		return TRUE
	end
	return FALSE
end

function StealthAttackArrow_Activate()
	local hand = HAND_RIGHT
	if c_Style == HAND_LEFT_BOTH then
		hand = HAND_LEFT
	end
	SetAttackHand(hand)
end

function StealthAttackArrowStart_Upper_onActivate()
	act(ResetInputQueue)
end

function StealthAttackArrowStart_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventHalfBlend(Event_StealthAttackArrowLoop, blend_type)
				return
			else
				ExecEventAllBody("W_StealthAttackArrowShot")
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventHalfBlend(Event_StealthAttackArrowLoop, blend_type)
			return
		else
			ExecEventAllBody("W_StealthAttackArrowShot")
			return
		end
	end
	if ArrowLowerCommonFunction(Event_StealthAttackArrowStart, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthAttackArrowStartContinue_Upper_onActivate()
	act(ResetInputQueue)
end

function StealthAttackArrowStartContinue_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		if g_ArrowSlot == 0 then
			if env(ActionDuration, ACTION_ARM_R1) > 0 then
				ExecEventHalfBlend(Event_StealthAttackArrowLoop, blend_type)
				return
			else
				ExecEventAllBody("W_StealthAttackArrowShot")
				return
			end
		elseif env(ActionDuration, ACTION_ARM_R2) > 0 then
			ExecEventHalfBlend(Event_StealthAttackArrowLoop, blend_type)
			return
		else
			ExecEventAllBody("W_StealthAttackArrowShot")
			return
		end
	end
	if ArrowLowerCommonFunction(Event_StealthAttackArrowStartContinue, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthAttackArrowLoop_Upper_onUpdate()
	act(SetIsPreciseShootingPossible)
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if g_ArrowSlot == 0 then
		if 0 >= env(ActionDuration, ACTION_ARM_R1) then
			ExecEventAllBody("W_StealthAttackArrowShot")
			return
		end
	elseif 0 >= env(ActionDuration, ACTION_ARM_R2) then
		ExecEventAllBody("W_StealthAttackArrowShot")
		return
	end
	if ArrowLowerCommonFunction(Event_StealthAttackArrowLoop, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthAttackArrowShot_onUpdate()
	act(SetIsPreciseShootingPossible)
	SetStealthState(STEALTH_ATTACK_ARROWSHOT)
	if ArrowCommonFunction(blend_type, FALSE, TURN_TYPE_STANCE) == TRUE then
		return
	end
	if env(GetStamina) > 0 then
		local request = GetAttackRequest(FALSE)
		local hand = HAND_RIGHT
		local IsContinue = FALSE
		if request == ATTACK_REQUEST_ARROW_FIRE_RIGHT or request == ATTACK_REQUEST_ARROW_FIRE_RIGHT2 then
			IsContinue = TRUE
		elseif request == ATTACK_REQUEST_ARROW_FIRE_LEFT or request == ATTACK_REQUEST_ARROW_FIRE_LEFT2 then
			IsContinue = TRUE
			hand = HAND_LEFT
		end
		if IsContinue == TRUE then
			if env(GetEquipWeaponCategory, hand) ~= WEAPON_CATEGORY_LARGE_ARROW then
				if env(IsOutOfAmmo, hand) == TRUE then
					ExecEventAllBody("W_NoArrow")
					return
				else
					SetVariable("NoAmmo", 0)
					ExecEventHalfBlend(Event_StealthAttackArrowStartContinue, ALLBODY)
					return
				end
			elseif env(IsOutOfAmmo, hand) == TRUE then
				ExecEventAllBody("W_NoArrow")
				return
			else
				ExecEventHalfBlend(Event_StealthAttackArrowStartContinue, ALLBODY)
				return
			end
		end
	end
	if env(IsMoveCancelPossible) == TRUE then
		if 0 < GetVariable("MoveSpeedLevel") then
			MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
			return
		else
			hkbFireEvent("W_Stealth_Idle")
			return
		end
	end
end

function StealthItemOneShot_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if StealthItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthItemOneShot, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthItemOneShot_SelfTrans_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if StealthItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthItemOneShot, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthItemDrinkStart_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if StealthItemCommonFunction(blend_type) == TRUE then
		return
	end
	local isEnd = env(IsAnimEnd, 1)
	if env(GetEventEzStateFlag, 0) == TRUE or isEnd == TRUE then
		local item_type = env(GetItemAnimType)
		if item_type ~= ITEM_NO_DRINK then
			ExecEventHalfBlendNoReset(Event_StealthItemDrinking, blend_type)
			return
		elseif item_type == ITEM_NO_DRINK and isEnd == TRUE then
			ExecEventHalfBlendNoReset(Event_StealthItemDrinkEmpty, blend_type)
			return
		end
	end
	if HalfBlendLowerCommonFunction(Event_StealthItemOneShot, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthItemDrinking_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if StealthItemCommonFunction(blend_type) == TRUE then
		return
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventHalfBlendNoReset(Event_StealthItemDrinkEnd, blend_type)
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthItemOneShot, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthItemDrinkEnd_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if StealthItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthItemOneShot, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthItemDrinkEmpty_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if StealthItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthItemOneShot, lower_state, FALSE) == TRUE then
		return
	end
end

function StealthItemDrinkNothing_Upper_onUpdate()
	local blend_type, lower_state = GetHalfBlendInfo()
	if lower_state == LOWER_IDLE then
		act(LockonSystemUnableToTurnAngle, 45, 45)
	elseif lower_state == LOWER_TURN then
		SetVariable("TurnType", TURN_TYPE_STANCE)
	end
	if StealthItemCommonFunction(blend_type) == TRUE then
		return
	end
	if HalfBlendUpperCommonFunction(lower_state) == TRUE then
		return
	end
	if HalfBlendLowerCommonFunction(Event_StealthItemOneShot, lower_state, FALSE) == TRUE then
		return
	end
end

function Stealth_to_Stealth_Idle_onUpdate()
	act(SwitchMotion, TRUE)
	act(SetAllowedThrowAttackType, THROW_STATE_STEALTH)
	SetEnableAimMode()
	SetStealthState(STEALTH_TO_STEALTHIDLE)
	SpeedUpdate()
	StealthTransitionIndexUpdate()
	if GetVariable("MoveSpeedIndex") == 2 then
		act(LockonFixedAngleCancel)
	end
	if env(IsMoveCancelPossible) == TRUE and GetVariable("MoveSpeedLevel") > 0 then
		MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
		return
	end
	if StealthActionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLightStealth", "W_AttackRightHeavy1Start",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothLightStealth", "W_AttackBothHeavy1Start",
		QUICKTYPE_ROLLING) == TRUE then
		return
	end
end

function Stealth_to_Idle_onUpdate()
	act(SwitchMotion, TRUE)
	act(SetAllowedThrowAttackType, THROW_STATE_STEALTH)
	SetEnableAimMode()
	SetStealthState(STEALTH_TO_IDLE)
	SpeedUpdate()
	StealthTransitionIndexUpdate()
	if GetVariable("MoveSpeedIndex") == 2 then
		act(LockonFixedAngleCancel)
	end
	if env(IsMoveCancelPossible) == TRUE and GetVariable("MoveSpeedLevel") > 0 then
		MoveStart(ALLBODY, Event_Move, FALSE)
		return
	else
	end
	if StealthActionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLightStealth", "W_AttackRightHeavy1Start",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothLightStealth", "W_AttackBothHeavy1Start",
		QUICKTYPE_ROLLING) == TRUE then
		return
	end
end

function Stealth_Idle_onUpdate()
	act(Wait)
	act(SetAllowedThrowAttackType, THROW_STATE_STEALTH)
	SetEnableAimMode()
	SetStealthState(STEALTH_IDLE)
	if IdleCommonFunction() == TRUE then
		return
	end
	if ExecArtsStance(ALLBODY) == TRUE then
		return
	end
	if ExecGuard(Event_GuardStart, ALLBODY) == TRUE then
		return
	end
end

function Stealth_Move_onActivate()
	act(SwitchMotion, TRUE)
end

function Stealth_Move_onUpdate()
	act(SwitchMotion, TRUE)
	local move_speed = GetVariable("MoveSpeedIndex")
	if move_speed == 2 then
		SetThrowAtkInvalid()
	end
	if g_TimeActEditor_08 >= 1 then
		act(Set4DirectionMovementThreshold, GetVariable("MagicRightWalkAngle_FrontLeft"),
			GetVariable("MagicRightWalkAngle_FrontRight"), GetVariable("MagicRightWalkAngle_BackLeft"),
			GetVariable("MagicRightWalkAngle_BackRight"))
	elseif 1 <= g_TimeActEditor_09 then
		act(Set4DirectionMovementThreshold, GetVariable("MagicLeftWalkAngle_FrontLeft"),
			GetVariable("MagicLeftWalkAngle_FrontRight"), GetVariable("MagicLeftWalkAngle_BackLeft"),
			GetVariable("MagicLeftWalkAngle_BackRight"))
	elseif hkbGetVariable("MoveType") < 0.5 then
		act(Set4DirectionMovementThreshold, 60, 45, 60, 60)
	elseif hkbGetVariable("StanceMoveType") == 0 then
		act(Set4DirectionMovementThreshold, 70, 40, 60, 20)
	else
		act(Set4DirectionMovementThreshold, 40, 70, 60, 20)
	end
	SpeedUpdate()

	if env(IsCOMPlayer) == TRUE then
		local npc_turn_speed = 240
		if move_speed == 2 then
			npc_turn_speed = 180
		else
			local dir = GetVariable("MoveDirection")
			if dir == 0 then
				npc_turn_speed = 90
			end
		end
		SetTurnSpeed(npc_turn_speed)
	end

	if hkbGetVariable("MoveDirection") == 3 or hkbGetVariable("MoveDirection") == 2 then
		act(SetMovementScaleMult, 0.9599999785423279)
	elseif hkbGetVariable("MoveDirection") == 1 then
		act(SetMovementScaleMult, 0.9599999785423279)
	elseif hkbGetVariable("MoveDirection") == 0 then
		act(SetMovementScaleMult, 0.9800000190734863)
	end
end

function Stealth_Move_Upper_onUpdate()
	act(SetAllowedThrowAttackType, THROW_STATE_STEALTH)
	SetWeightIndex()
	if MoveCommonFunction(UPPER) == TRUE then
		return
	end
end

function StealthStopCommonFunction(is_dash_stop)
	act(Wait)
	act(SwitchMotion, TRUE)
	act(SetAllowedThrowAttackType, THROW_STATE_STEALTH)
	SetEnableAimMode()
	SetStealthState(STEALTH_STOP)
	if StopCommonFunction(is_dash_stop) == TRUE then
		return TRUE
	end
	if env(IsAnimEnd, 1) == TRUE then
		ExecEventAllBody("W_Stealth_Idle")
		return TRUE
	end
	return FALSE
end

function StealthDashStop_onUpdate()
	if StealthStopCommonFunction(TRUE) == TRUE then
		return
	end
end

function StealthRunStopFront_onUpdate()
	if StealthStopCommonFunction(FALSE) == TRUE then
		return
	end
end

function StealthRunStopBack_onUpdate()
	if StealthStopCommonFunction(FALSE) == TRUE then
		return
	end
end

function StealthRunStopLeft_onUpdate()
	if StealthStopCommonFunction(FALSE) == TRUE then
		return
	end
end

function StealthRunStopRight_onUpdate()
	if StealthStopCommonFunction(FALSE) == TRUE then
		return
	end
end

function Stealth_Rolling_onUpdate()
	act(SetAllowedThrowAttackType, THROW_STATE_STEALTH)
	SetWeightIndex()
	SetStealthState(STEALTH_ROLLING)
	if env(IsAnimEnd, 1) == TRUE then
		hkbFireEvent("W_Stealth_Idle")
		return
	end
	if env(IsMoveCancelPossible) == TRUE and MoveStart(ALLBODY, Event_Stealth_Move, FALSE) == TRUE then
		return
	end
	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLightStep", "W_AttackRightHeavy1Start",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothLightStep", "W_AttackBothHeavy1Start",
		QUICKTYPE_ROLLING) == TRUE then
		return
	end
	SetRollingTurnCondition(FALSE)
end

function Stealth_RollingSelftrans_onUpdate()
	act(SetAllowedThrowAttackType, THROW_STATE_STEALTH)
	SetWeightIndex()
	SetStealthState(STEALTH_ROLLING_SELFTRANS)
	if env(IsAnimEnd, 1) == TRUE and MoveStart(ALLBODY, Event_Stealth_Move, FALSE) == TRUE then
		return
	end
	if env(IsMoveCancelPossible) == TRUE and GetVariable("MoveSpeedLevel") <= 0 then
		MoveStart(ALLBODY, Event_Stealth_Move, FALSE)
		return
	end
	if EvasionCommonFunction(FALL_TYPE_DEFAULT, "W_AttackRightLightStep", "W_AttackRightHeavy1Start",
		"W_AttackLeftLight1", "W_AttackLeftHeavy1", "W_AttackBothLightStep", "W_AttackBothHeavy1Start",
		QUICKTYPE_ROLLING) == TRUE then
		return
	end
	SetRollingTurnCondition(TRUE)
end

function AddBlendSpeak_onUpdate()
	if env(IsAnimEnd, 2) == TRUE then
		SetVariable("AddBlendSpeakIndex", math.random(0, 2))
		act(DebugLogOutput, "AddBlendSpeak_end")
		ExecEventAllBody("W_AddBlendSpeak")
	end
end

------------------------------------------
-- Core: Includes from common_define
------------------------------------------
-- ivi: Constants for distinction of regular numbers to what exactly these mean.
SWORD_ART_DIFF_CAT_DEFAULT = 0
SWORD_ART_DIFF_CAT_LARGE_WEAPON = 2
SWORD_ART_DIFF_CAT_POLEARM = 3
SWORD_ART_DIFF_CAT_LARGE_WEAPON_SMALL_SHIELD = 4
SWORD_ART_DIFF_CAT_POLEARM_SMALL_SHIELD = 5
SWORD_ART_DIFF_CAT_LARGE_WEAPON_LARGE_SHIELD = 8
SWORD_ART_DIFF_CAT_POLEARM_LARGE_SHIELD = 9

-- Stores possible override animations that exist for Sword Arts.
-- Key: Sword Art ID (TAE ID minus 600)
-- Possible values:
--
-- 0: Idle (Default or Large Rapier)
-- 2: Idle (Great Weapon)
-- 3: Idle (Polearm)
-- 4: Idle (Great Weapon) + Small Shield
-- 5: Idle (Polearm) + Small Shield
-- 8: Idle (Great Weapon) + Large Shield
-- 9: Idle (Polearm) + Large Shield
-- 20-59: Weapon Category
SwordArtsCategory = {
	[0] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[1] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM, WEAPON_CATEGORY_FIST, WEAPON_CATEGORY_DUELING_SHIELD},
	[2] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_DUELING_SHIELD},
	[3] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM,
		   WEAPON_CATEGORY_TWINBLADE, WEAPON_CATEGORY_BACKHAND_SWORD},
	[4] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM},
	[5] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_DUELING_SHIELD},
	[6] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[7] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM},
	[8] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM, WEAPON_CATEGORY_DUELING_SHIELD},
	[9] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM, WEAPON_CATEGORY_DUELING_SHIELD},
	[10] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[11] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[12] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM},
	[13] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[14] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[15] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[16] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[17] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[18] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_POLEARM},
	[19] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_BACKHAND_SWORD},
	[20] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[21] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[22] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_POLEARM, WEAPON_CATEGORY_TWINBLADE},
	[23] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_POLEARM, WEAPON_CATEGORY_TWINBLADE},
	[24] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM,
			WEAPON_CATEGORY_TWINBLADE, WEAPON_CATEGORY_BACKHAND_SWORD},
	[25] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[50] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_DUELING_SHIELD},
	[51] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[52] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_TWINBLADE},
	[53] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_DUELING_SHIELD},
	[54] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, WEAPON_CATEGORY_TWINBLADE},
	[55] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[56] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[57] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON},
	[58] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_BACKHAND_SWORD, WEAPON_CATEGORY_DUELING_SHIELD},
	[59] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[61] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[62] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[63] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_BACKHAND_SWORD},
	[64] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_FIST, WEAPON_CATEGORY_MARTIAL_ARTS, WEAPON_CATEGORY_DUELING_SHIELD, WEAPON_CATEGORY_BEAST_CLAW},
	[65] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_POLEARM},
	[66] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[67] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[68] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[69] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[70] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[71] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[72] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_BACKHAND_SWORD},
	[73] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[74] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[75] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[76] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[90] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_LARGE_SHIELD, WEAPON_CATEGORY_SMALL_SHIELD, WEAPON_CATEGORY_DUELING_SHIELD},
	[91] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM,
			SWORD_ART_DIFF_CAT_LARGE_WEAPON_SMALL_SHIELD, SWORD_ART_DIFF_CAT_POLEARM_SMALL_SHIELD,
			SWORD_ART_DIFF_CAT_LARGE_WEAPON_LARGE_SHIELD, SWORD_ART_DIFF_CAT_POLEARM_LARGE_SHIELD,
			WEAPON_CATEGORY_LARGE_SHIELD, WEAPON_CATEGORY_SMALL_SHIELD, WEAPON_CATEGORY_DUELING_SHIELD},
	[92] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_SHORT_SWORD, WEAPON_CATEGORY_CURVEDSWORD,
			WEAPON_CATEGORY_SMALL_SHIELD, WEAPON_CATEGORY_THROW_DAGGER},
	[93] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM},
	[94] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[95] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[96] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[97] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[98] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_LARGE_SHIELD, WEAPON_CATEGORY_SMALL_SHIELD, WEAPON_CATEGORY_DUELING_SHIELD},
	[99] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[100] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[101] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[102] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[103] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[105] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_LARGE_ARROW},
	[106] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[108] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[110] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[107] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[109] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[111] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[112] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[113] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[114] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_DUELING_SHIELD},
	[115] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[116] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[117] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[118] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[130] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[131] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[132] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[133] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_DUELING_SHIELD},
	[134] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[135] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_DUELING_SHIELD},
	[136] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[137] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_BACKHAND_SWORD, WEAPON_CATEGORY_LARGE_KATANA},
	[140] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[141] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[142] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_DUELING_SHIELD},
	[143] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[144] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[150] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, WEAPON_CATEGORY_FIST, WEAPON_CATEGORY_MARTIAL_ARTS, WEAPON_CATEGORY_PERFUME_BOTTLE, WEAPON_CATEGORY_DUELING_SHIELD, WEAPON_CATEGORY_BEAST_CLAW},
	[151] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_DUELING_SHIELD},
	[152] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_DUELING_SHIELD},
	[155] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[156] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[157] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[160] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[165] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[166] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[167] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[168] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[196] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM},
	[256] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_TWINBLADE},
	[257] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[258] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[260] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[261] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[262] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[263] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[264] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[265] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[269] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[273] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[274] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[276] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[277] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[278] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[279] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[280] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[281] = {SWORD_ART_DIFF_CAT_DEFAULT, WEAPON_CATEGORY_DUELING_SHIELD},
	[282] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[283] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[284] = {SWORD_ART_DIFF_CAT_DEFAULT, SWORD_ART_DIFF_CAT_LARGE_WEAPON, SWORD_ART_DIFF_CAT_POLEARM},
	[285] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[286] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[305] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[357] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[340] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[341] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[342] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[343] = {SWORD_ART_DIFF_CAT_DEFAULT},
	[399] = {SWORD_ART_DIFF_CAT_DEFAULT}
}

-- Determines which override of a Sword Art animation to play, based on the size or type of the weapon.
-- The return of this function is processed to a different ID by the cases that use it.
--
-- artID: Weapon Arts ID (TAE id minus 600)
--      swordArtsTypeNew in SwordArtsParam
-- idleCat: Stay Anim Category (Idle animation index for weapon)
--      wepmotionOneHandId and wepmotionBothHandId in EquipParamWeapon
-- wepCat: Weapon Animation Category (TAE ID for weapon type)
--      wepmotionCategory in EquipParamWeapon
--
-- Possible returns:
--
-- 0: Idle (Default or Large Rapier)
-- 2: Idle (Great Weapon)
-- 3: Idle (Polearm)
-- 4: Idle (Great Weapon) + Small Shield
-- 5: Idle (Polearm) + Small Shield
-- 8: Idle (Great Weapon) + Large Shield
-- 9: Idle (Polearm) + Large Shield
-- 20-59: Weapon Category
function GetSwordArtsDiffCategory(artID, idleCat, wepCat)
	-- If TAE ID above 770 (except 796), no overrides, only a single default animation. Also DLC stuff
	if 170 <= artID and artID < 255 and artID ~= 196 or artID >= 300 and artID ~= 305 and artID ~= 357 and artID ~= 399 or artID == 275 or artID == 272 then
		return SWORD_ART_DIFF_CAT_DEFAULT
	end
	-- For TAE ID 769 (Radahn's Rain), return 45 (Greatbow)
	if artID == 169 then
		return WEAPON_CATEGORY_LARGE_ARROW
	end

	-- Allows some weapon categories to query for whether the Sword Art permits a cousin category.
	-- Only used to allow Claws to use Fist Sword Arts.
	local wep_cat1 = wepCat
	if wepCat == WEAPON_CATEGORY_CLAW then
		wep_cat1 = WEAPON_CATEGORY_FIST
	elseif wep_cat1 == WEAPON_CATEGORY_LIGHT_LARGE_SWORD then
		return 0
	end

	-- Idle animation TAEs. Two-hand is ignored.
	local idle_cat0 = idleCat
	if idle_cat0 >= 10 then
		idle_cat0 = idle_cat0 - 10
	end

	-- Override for heavy thrusting swords (usually 3)
	if wepCat == WEAPON_CATEGORY_LARGE_RAPIER then
		idle_cat0 = SWORD_ART_DIFF_CAT_DEFAULT
	end

	if (artID == 90 or artID == 98 or artID == 151 or artID == 152) and env(GetEquipWeaponCategory, c_SwordArtsHand) == WEAPON_CATEGORY_DUELING_SHIELD and (c_Style == HAND_LEFT or c_Style == HAND_RIGHT) then
		return 0
	end

	-- ivi: CASE 0: Not in table
	if SwordArtsCategory[artID] == nil then
		return SWORD_ART_DIFF_CAT_DEFAULT
	end

	-- CASE 1: Shields
	if c_SwordArtsHand == HAND_LEFT and c_Style ~= HAND_LEFT_BOTH then
		local shield_cat = -1
		if idle_cat0 == 2 and wepCat == WEAPON_CATEGORY_SMALL_SHIELD then
			shield_cat = SWORD_ART_DIFF_CAT_LARGE_WEAPON_SMALL_SHIELD
		elseif idle_cat0 == 3 and wepCat == WEAPON_CATEGORY_SMALL_SHIELD then
			shield_cat = SWORD_ART_DIFF_CAT_POLEARM_SMALL_SHIELD
		elseif idle_cat0 == 2 and wepCat == WEAPON_CATEGORY_LARGE_SHIELD then
			shield_cat = SWORD_ART_DIFF_CAT_LARGE_WEAPON_LARGE_SHIELD
		elseif idle_cat0 == 3 and wepCat == WEAPON_CATEGORY_LARGE_SHIELD then
			shield_cat = SWORD_ART_DIFF_CAT_POLEARM_LARGE_SHIELD
		end
		if shield_cat ~= -1 then
			-- Only check if shields
			for i = 1, #SwordArtsCategory[artID], 1 do
				if SwordArtsCategory[artID][i] == shield_cat then
					env(DebugLogOutput, "GetSwordArtsDiffCategory shield_cat:" .. shield_cat)
					return shield_cat
				end
			end
		end
	end

	-- CASE 2: Weapon Categories
	for j = 1, #SwordArtsCategory[artID], 1 do
		if SwordArtsCategory[artID][j] == wepCat then
			env(DebugLogOutput, "GetSwordArtsDiffCategory wepCat0:" .. wepCat)
			return wepCat
		end
	end

	-- ivi: Additional check to avoid unnecessary second loop
	if wep_cat1 ~= nil then
		-- CASE 3: Auxiliary weapon category (Some weapon categories count the same as others)
		for j = 1, #SwordArtsCategory[artID], 1 do
			if SwordArtsCategory[artID][j] == wep_cat1 then
				env(DebugLogOutput, "GetSwordArtsDiffCategory wepCat1:" .. wep_cat1)
				return wep_cat1
			end
		end
	end

	-- Shield Arts (90 is Shield Bash, 99 is Thops Barrier)
	if artID >= 90 and artID <= 99 and (c_SwordArtsHand ~= HAND_LEFT or c_Style == HAND_LEFT_BOTH) then
		return SWORD_ART_DIFF_CAT_DEFAULT
	end

	-- CASE 4: Idle categories
	for j = 1, #SwordArtsCategory[artID], 1 do
		if SwordArtsCategory[artID][j] == idle_cat0 then
			env(DebugLogOutput, "GetSwordArtsDiffCategory idle_cat0:" .. idle_cat0)
			return idle_cat0
		end
	end

	return SWORD_ART_DIFF_CAT_DEFAULT
end

-- Table storing information about weapon arts.
-- Concerns playing a "weapon retrieval" animation after
-- the sword art was executed.
--
-- Table key: Sword Art ID (TAE ID minus 600)
-- Value 1: Right hand, weapon art cast from right hand
-- Value 2: Right hand, weapon art cast from left hand
-- Value 3: Left hand
--
-- TRUE: Weapon was sheathed during animation, play retrieval animation.
-- FALSE: Weapon was used to perform the sword art, no retrieval animation.
SwordArtPutOppositeWeapon = {
	[0] = {TRUE, FALSE, TRUE},
	[1] = {TRUE, FALSE, TRUE},
	[2] = {TRUE, FALSE, TRUE},
	[3] = {TRUE, FALSE, TRUE},
	-- 4 (Not present)
	[5] = {TRUE, FALSE, TRUE},
	[6] = {TRUE, FALSE, TRUE},
	[7] = {TRUE, FALSE, TRUE},
	[8] = {FALSE, FALSE, TRUE},
	[9] = {FALSE, FALSE, TRUE},
	[10] = {TRUE, FALSE, TRUE},
	[11] = {TRUE, FALSE, TRUE},
	[12] = {TRUE, FALSE, TRUE},
	[13] = {TRUE, FALSE, TRUE},
	[14] = {TRUE, FALSE, TRUE},
	[15] = {TRUE, FALSE, TRUE},
	[16] = {TRUE, FALSE, TRUE},
	[17] = {FALSE, FALSE, FALSE},
	[18] = {TRUE, FALSE, TRUE},
	[19] = {TRUE, FALSE, TRUE},
	[20] = {TRUE, FALSE, TRUE},
	-- 21 (Present)
	[22] = {TRUE, FALSE, TRUE},
	[23] = {TRUE, FALSE, TRUE},
	[24] = {FALSE, FALSE, TRUE},
	[25] = {TRUE, FALSE, TRUE},
	-- 26-49 (Not present)
	[50] = {FALSE, FALSE, TRUE},
	[51] = {TRUE, FALSE, TRUE},
	[52] = {TRUE, FALSE, TRUE},
	[53] = {FALSE, FALSE, TRUE},
	[54] = {TRUE, FALSE, TRUE},
	[55] = {TRUE, FALSE, FALSE},
	[56] = {TRUE, FALSE, TRUE},
	[57] = {TRUE, FALSE, TRUE},
	[58] = {TRUE, FALSE, TRUE},
	[59] = {TRUE, FALSE, TRUE},
	[61] = {TRUE, FALSE, TRUE},
	[62] = {TRUE, FALSE, FALSE},
	[63] = {TRUE, FALSE, TRUE},
	[64] = {FALSE, FALSE, TRUE},
	[65] = {TRUE, FALSE, TRUE},
	[66] = {TRUE, FALSE, TRUE},
	[67] = {TRUE, FALSE, TRUE},
	[68] = {TRUE, FALSE, TRUE},
	[69] = {TRUE, FALSE, TRUE},
	[70] = {TRUE, FALSE, TRUE},
	[71] = {TRUE, FALSE, TRUE},
	[72] = {TRUE, FALSE, TRUE},
	[73] = {TRUE, FALSE, TRUE},
	[74] = {FALSE, FALSE, TRUE},
	[75] = {TRUE, FALSE, TRUE},
	[76] = {TRUE, FALSE, TRUE},
	-- 77-89 (Not present)
	[90] = {TRUE, FALSE, TRUE},
	[91] = {FALSE, FALSE, FALSE},
	[92] = {FALSE, FALSE, TRUE},
	[93] = {FALSE, FALSE, TRUE},
	[94] = {FALSE, FALSE, TRUE},
	[95] = {FALSE, FALSE, TRUE},
	[96] = {FALSE, FALSE, TRUE},
	[97] = {FALSE, FALSE, TRUE},
	[98] = {TRUE, TRUE, TRUE},
	[99] = {FALSE, FALSE, FALSE},
	[100] = {FALSE, FALSE, FALSE},
	[101] = {FALSE, FALSE, FALSE},
	[102] = {FALSE, FALSE, FALSE},
	[103] = {FALSE, FALSE, FALSE},
	-- 104 (Not present)
	[105] = {FALSE, FALSE, FALSE},
	[106] = {FALSE, FALSE, FALSE},
	-- 107 (Not Present)
	[108] = {FALSE, FALSE, FALSE},
	-- 109 (Not present)
	[110] = {FALSE, FALSE, TRUE},
	[111] = {FALSE, FALSE, TRUE},
	[112] = {FALSE, FALSE, TRUE},
	[113] = {FALSE, FALSE, TRUE},
	[114] = {TRUE, FALSE, TRUE},
	[115] = {FALSE, FALSE, TRUE},
	[116] = {FALSE, FALSE, TRUE},
	[117] = {TRUE, FALSE, TRUE},
	[118] = {TRUE, FALSE, TRUE},
	-- 119-129 (Not present)
	[130] = {FALSE, FALSE, TRUE},
	[131] = {FALSE, FALSE, TRUE},
	[132] = {TRUE, FALSE, TRUE},
	[133] = {FALSE, FALSE, TRUE},
	[134] = {TRUE, FALSE, TRUE},
	[135] = {TRUE, FALSE, TRUE},
	[136] = {TRUE, FALSE, TRUE},
	[137] = {FALSE, FALSE, TRUE},
	[140] = {FALSE, FALSE, TRUE},
	[141] = {FALSE, FALSE, TRUE},
	[142] = {FALSE, FALSE, TRUE},
	[143] = {FALSE, FALSE, TRUE},
	[144] = {TRUE, FALSE, TRUE},
	[150] = {TRUE, FALSE, TRUE},
	[151] = {FALSE, FALSE, TRUE},
	[152] = {TRUE, TRUE, TRUE},
	[155] = {FALSE, FALSE, TRUE},
	[156] = {FALSE, FALSE, TRUE},
	[157] = {FALSE, FALSE, TRUE},
	[160] = {FALSE, FALSE, TRUE},
	[165] = {TRUE, FALSE, TRUE},
	[166] = {TRUE, FALSE, TRUE},
	[167] = {TRUE, FALSE, TRUE},
	[168] = {TRUE, FALSE, TRUE},
	[169] = {FALSE, FALSE, FALSE},
	[170] = {TRUE, FALSE, TRUE},
	[171] = {FALSE, FALSE, TRUE},
	[172] = {TRUE, FALSE, FALSE},
	[173] = {TRUE, FALSE, TRUE},
	[174] = {FALSE, FALSE, TRUE},
	[175] = {TRUE, FALSE, TRUE},
	[176] = {TRUE, FALSE, TRUE},
	[177] = {TRUE, FALSE, TRUE},
	[178] = {TRUE, FALSE, TRUE},
	[179] = {TRUE, FALSE, TRUE},
	-- 180
	-- 181
	[182] = {FALSE, FALSE, TRUE},
	[183] = {TRUE, FALSE, TRUE},
	[184] = {TRUE, FALSE, TRUE},
	[185] = {TRUE, FALSE, TRUE},
	[186] = {TRUE, FALSE, TRUE},
	[187] = {FALSE, FALSE, TRUE},
	[188] = {TRUE, FALSE, TRUE},
	[189] = {TRUE, FALSE, TRUE},
	[190] = {FALSE, FALSE, FALSE},
	[191] = {TRUE, FALSE, FALSE},
	[192] = {TRUE, FALSE, TRUE},
	[193] = {FALSE, FALSE, TRUE},
	[194] = {FALSE, FALSE, TRUE},
	[195] = {FALSE, TRUE, FALSE},
	[196] = {FALSE, FALSE, FALSE},
	[197] = {FALSE, FALSE, FALSE},
	[198] = {FALSE, FALSE, TRUE},
	[199] = {TRUE, FALSE, TRUE},
	[200] = {TRUE, FALSE, TRUE},
	[201] = {TRUE, TRUE, FALSE},
	[202] = {TRUE, TRUE, FALSE},
	[203] = {TRUE, FALSE, TRUE},
	[204] = {TRUE, FALSE, TRUE},
	[205] = {TRUE, FALSE, TRUE},
	[206] = {FALSE, FALSE, TRUE},
	[207] = {TRUE, FALSE, TRUE},
	[208] = {TRUE, FALSE, TRUE},
	[209] = {TRUE, FALSE, TRUE},
	[210] = {FALSE, FALSE, TRUE},
	[211] = {FALSE, FALSE, FALSE},
	[212] = {FALSE, FALSE, TRUE},
	[213] = {TRUE, FALSE, TRUE},
	[214] = {TRUE, FALSE, TRUE},
	[215] = {TRUE, FALSE, TRUE},
	[216] = {FALSE, FALSE, TRUE},
	[217] = {FALSE, FALSE, TRUE},
	[218] = {TRUE, FALSE, TRUE},
	[219] = {TRUE, FALSE, FALSE},
	[220] = {FALSE, FALSE, TRUE},
	[221] = {FALSE, FALSE, TRUE},
	[222] = {TRUE, FALSE, TRUE},
	[223] = {TRUE, FALSE, TRUE},
	[224] = {TRUE, FALSE, TRUE},
	[225] = {TRUE, FALSE, TRUE},
	[226] = {TRUE, FALSE, TRUE},
	[227] = {TRUE, FALSE, TRUE},
	[228] = {TRUE, FALSE, TRUE},
	[229] = {TRUE, FALSE, TRUE},
	[230] = {FALSE, FALSE, TRUE},
	[231] = {TRUE, FALSE, TRUE},
	[232] = {TRUE, FALSE, FALSE},
	[233] = {TRUE, FALSE, TRUE},
	[234] = {TRUE, FALSE, TRUE},
	[235] = {TRUE, FALSE, TRUE},
	[236] = {TRUE, FALSE, TRUE},
	[237] = {TRUE, FALSE, TRUE},
	[238] = {TRUE, FALSE, TRUE},
	[239] = {TRUE, FALSE, TRUE},
	[240] = {TRUE, FALSE, TRUE},
	[241] = {TRUE, FALSE, TRUE},
	[242] = {TRUE, FALSE, TRUE},
	[243] = {TRUE, FALSE, TRUE},
	[244] = {TRUE, FALSE, TRUE},
	[245] = {FALSE, FALSE, TRUE},
	[246] = {TRUE, FALSE, TRUE},
	[247] = {FALSE, FALSE, FALSE},
	[248] = {TRUE, FALSE, FALSE},
	[249] = {TRUE, FALSE, FALSE},
	[250] = {TRUE, FALSE, TRUE},
	[251] = {TRUE, FALSE, TRUE},
	[252] = {TRUE, FALSE, FALSE},
	[253] = {TRUE, FALSE, TRUE},
	[254] = {TRUE, FALSE, TRUE},
	[255] = {FALSE, FALSE, TRUE},
	[256] = {FALSE, FALSE, TRUE},
	[257] = {FALSE, FALSE, TRUE},
	[258] = {TRUE, FALSE, FALSE},
	[259] = {FALSE, FALSE, TRUE},
	[260] = {TRUE, FALSE, TRUE},
	[261] = {FALSE, FALSE, TRUE},
	[262] = {FALSE, FALSE, TRUE},
	[263] = {TRUE, FALSE, TRUE},
	[264] = {FALSE, FALSE, TRUE},
	[265] = {FALSE, FALSE, TRUE},
	[266] = {FALSE, FALSE, TRUE},
	[267] = {FALSE, FALSE, TRUE},
	[268] = {FALSE, FALSE, TRUE},
	[269] = {FALSE, FALSE, TRUE},
	[270] = {FALSE, FALSE, TRUE},
	[271] = {FALSE, FALSE, TRUE},
	[272] = {TRUE, FALSE, TRUE},
	[273] = {TRUE, FALSE, TRUE},
	[274] = {TRUE, FALSE, TRUE},
	[275] = {TRUE, FALSE, TRUE},
	[276] = {FALSE, FALSE, TRUE},
	[277] = {TRUE, FALSE, TRUE},
	[278] = {TRUE, FALSE, TRUE},
	[279] = {FALSE, FALSE, TRUE},
	[280] = {FALSE, FALSE, TRUE},
	[281] = {TRUE, FALSE, TRUE},
	[282] = {TRUE, FALSE, TRUE},
	[283] = {FALSE, FALSE, TRUE},
	[284] = {TRUE, FALSE, TRUE},
	[285] = {TRUE, FALSE, TRUE},
	[286] = {FALSE, FALSE, TRUE},
	[287] = {FALSE, FALSE, TRUE},
	[288] = {FALSE, FALSE, TRUE},
	[289] = {FALSE, FALSE, TRUE},
	[290] = {FALSE, FALSE, TRUE},
	[291] = {FALSE, FALSE, TRUE},
	[292] = {FALSE, FALSE, TRUE},
	[293] = {FALSE, FALSE, TRUE},
	[294] = {FALSE, FALSE, TRUE},
	[295] = {FALSE, FALSE, TRUE},
	[296] = {FALSE, FALSE, TRUE},
	[297] = {FALSE, FALSE, TRUE},
	[298] = {FALSE, FALSE, TRUE},
	[299] = {FALSE, FALSE, TRUE},
	[300] = {TRUE, FALSE, TRUE},
	[301] = {FALSE, FALSE, TRUE},
	[302] = {FALSE, FALSE, TRUE},
	[303] = {FALSE, FALSE, TRUE},
	[304] = {TRUE, FALSE, TRUE},
	[305] = {FALSE, FALSE, TRUE},
	[306] = {FALSE, FALSE, TRUE},
	[307] = {FALSE, FALSE, TRUE},
	[308] = {TRUE, FALSE, TRUE},
	[309] = {TRUE, FALSE, TRUE},
	[310] = {TRUE, FALSE, TRUE},
	[311] = {TRUE, FALSE, TRUE},
	[312] = {FALSE, FALSE, TRUE},
	[313] = {TRUE, FALSE, TRUE},
	[314] = {TRUE, FALSE, TRUE},
	[315] = {TRUE, FALSE, TRUE},
	[316] = {TRUE, FALSE, TRUE},
	[317] = {TRUE, FALSE, TRUE},
	[318] = {TRUE, FALSE, TRUE},
	[319] = {FALSE, FALSE, TRUE},
	[320] = {TRUE, FALSE, TRUE},
	[321] = {FALSE, FALSE, TRUE},
	[322] = {TRUE, FALSE, TRUE},
	[323] = {FALSE, FALSE, TRUE},
	[324] = {TRUE, TRUE, TRUE},
	[325] = {FALSE, FALSE, TRUE},
	[326] = {FALSE, FALSE, TRUE},
	[327] = {TRUE, FALSE, TRUE},
	[328] = {FALSE, FALSE, TRUE},
	[329] = {TRUE, FALSE, TRUE},
	[330] = {FALSE, FALSE, TRUE},
	[331] = {TRUE, FALSE, TRUE},
	[332] = {FALSE, FALSE, TRUE},
	[333] = {FALSE, FALSE, TRUE},
	[334] = {FALSE, FALSE, TRUE},
	[335] = {TRUE, FALSE, TRUE},
	[336] = {TRUE, FALSE, TRUE},
	[337] = {FALSE, FALSE, FALSE},
	[338] = {FALSE, FALSE, TRUE},
	[339] = {FALSE, FALSE, TRUE},
	[340] = {TRUE, FALSE, TRUE},
	[341] = {TRUE, FALSE, TRUE},
	[342] = {TRUE, FALSE, TRUE},
	[343] = {TRUE, FALSE, TRUE},
	[344] = {TRUE, FALSE, FALSE},
	[345] = {TRUE, FALSE, FALSE},
	[346] = {FALSE, FALSE, FALSE},
	[347] = {FALSE, FALSE, FALSE},
	[348] = {FALSE, FALSE, TRUE},
	[349] = {TRUE, FALSE, TRUE},
	[350] = {TRUE, FALSE, TRUE},
	[351] = {TRUE, FALSE, TRUE},
	[352] = {FALSE, FALSE, TRUE},
	[353] = {TRUE, FALSE, TRUE},
	[354] = {TRUE, FALSE, TRUE},
	[355] = {TRUE, FALSE, TRUE},
	[356] = {FALSE, FALSE, TRUE},
	[357] = {FALSE, FALSE, FALSE},
	[358] = {FALSE, FALSE, TRUE},
	[359] = {TRUE, FALSE, TRUE},
	[360] = {FALSE, FALSE, TRUE},
	[361] = {TRUE, FALSE, TRUE},
	[362] = {TRUE, FALSE, TRUE},
	[363] = {FALSE, FALSE, TRUE},
	[364] = {TRUE, FALSE, TRUE},
	[365] = {FALSE, FALSE, TRUE},
	[366] = {FALSE, FALSE, TRUE},
	[367] = {FALSE, FALSE, TRUE},
	[368] = {TRUE, FALSE, TRUE},
	[369] = {FALSE, FALSE, TRUE},
	[370] = {FALSE, FALSE, TRUE},
	[371] = {FALSE, FALSE, FALSE},
	[372] = {FALSE, FALSE, TRUE},
	[373] = {FALSE, FALSE, TRUE},
	[374] = {FALSE, FALSE, TRUE},
	[375] = {FALSE, FALSE, TRUE},
	[376] = {FALSE, FALSE, TRUE},
	[377] = {FALSE, FALSE, TRUE},
	[378] = {FALSE, FALSE, TRUE},
	[379] = {FALSE, FALSE, TRUE},
	[380] = {FALSE, FALSE, TRUE},
	[399] = {FALSE, FALSE, TRUE}
}

-- Decides whether to perform a "retrieve weapon" animation after finishing a Weapon Art.
-- See the above table for reference.
function GetSwordArtsPutOppositeWeapon()
	-- ivi: In Fromsoft's original code, this was nil by default. FALSE is more forgiving for custom weapon arts.
	local result = FALSE

	-- ivi: Add sanity check for absent entries (custom Sword Arts).
	if SwordArtPutOppositeWeapon[c_SwordArtsID] ~= nil then
		if c_Style == HAND_RIGHT then
			if HAND_RIGHT == c_SwordArtsHand then
				if c_SwordArtsID == 276 and GetVariable("SwordArtsRollingDirection") == 3 then
					result = TRUE -- DLC special case
				else
					result = SwordArtPutOppositeWeapon[c_SwordArtsID][1] -- Right hand, weapon art cast from right hand
				end
			else
				result = SwordArtPutOppositeWeapon[c_SwordArtsID][2] -- Right hand, weapon art cast from left hand
			end
		elseif env(GetEquipWeaponCategory, c_SwordArtsHand) == WEAPON_CATEGORY_THROW_DAGGER or env(GetEquipWeaponCategory, c_SwordArtsHand) == WEAPON_CATEGORY_BACKHAND_SWORD then
			result = SwordArtPutOppositeWeapon[c_SwordArtsID][1] -- DLC special case
		else
			result = SwordArtPutOppositeWeapon[c_SwordArtsID][3] -- Left hand
		end
	end

	return result
end

------------------------------------------
-- Core: Helper Functions
------------------------------------------
function Contains(tab, val)
	for index, value in ipairs(tab) do
		if value == val then
			return TRUE
		end
	end

	return FALSE
end

------------------------------------------
-- Core: Logic Expansion
------------------------------------------
function IsWeaponCatalyst(sp_kind)
	local weaponCatalystSpKinds = {
		293, -- Carian Sorcery Sword
	}
	if Contains(weaponCatalystSpKinds, sp_kind) == TRUE then
		return TRUE
	end
	return FALSE
end

------------------------
-- Core: Global Variables
------------------------
HandChangeTest_ToR1 = FALSE
HandChangeTest_ToR2 = FALSE
HandChangeTest_ToL1 = FALSE
HandChangeTest_ToL2 = FALSE
HandChangeTest_L = FALSE
HandChangeTest_R = FALSE
HandChangeTest_Time = 233

JUMP_STATE_1 = 0
JUMP_STATE_2 = 0
JUMP_STATE_3 = 0
RIDE_TURN_STATE = 0
PROTO5 = 0
DAMAGE_ELEMENT_DEFAULT = 0
DAMAGE_ELEMENT_MAGIC = 10
DAMAGE_ELEMENT_FIRE = 11
DAMAGE_ELEMENT_LIGHTNING = 12
DAMAGE_ELEMENT_DARK = 13
DAMAGE_ELEMENT_POISON = 20
DAMAGE_ELEMENT_BLIGHT = 21
DAMAGE_ELEMENT_BLOOD = 22
DAMAGE_ELEMENT_FROSTBITE = 23
DAMAGE_ELEMENT_SLEEP = 24
DAMAGE_ELEMENT_MAD = 25
DAMAGE_ELEMENT_CURSE = 26
DAMAGE_ELEMENT_NONE = 254
DAMAGE_ELEMENT_MATERIAL_1 = 255
DAMAGE_PHYSICAL_SLASH = 0
DAMAGE_PHYSICAL_BLUNT = 1
DAMAGE_PHYSICAL_THRUST = 2
DAMAGE_PHYSICAL_NORMAL = 3

IS_ATTACKED_JUMPMAGIC = FALSE

g_IsMimicry = 0
g_EnableMimicry = 0
g_ComboReset = FALSE
lastUsedMagicAnim = -1

Jump_InitWeaponRef = FALSE
Jump_LeftWeaponRef = FALSE

Event_MoveQuick = {"W_MoveQuick", MOVE_DEF0}

local blendtimemax = 0
local blendtime = 0
local EVENT_BLEND_RATE = 1000

-- Torrent
RIDE_MOVE_TYPE_IDLE = 0
RIDE_MOVE_TYPE_WALK = 1
RIDE_MOVE_TYPE_RUN = 2
RIDE_MOVE_TYPE_DASH = 3
RIDE_MOVE_TYPE_GALLOP = 4
RIDE_MOVE_TYPE_OTHER = 10
RIDE_ISENABLE_DOUBLEJUMP = TRUE
RideDashAccelerateTest = 0
RideJumpLoop_IsSecond = FALSE
DISABLEJUMP_FALLDIST = 20
rideJumpHighLoop_StopTime = 0
lastFallHeight = 0
rideJumpHighLoop_IsStop = FALSE

-- DLC
JUSTGUARD_IS_FIRSTFRAME = TRUE
JUSTGUARD_RELEASE_GUARD_BUTTON = FALSE

-- Added
-- ACTION_ARM_JUMP = ACTION_ARM_CHANGE_STYLE -- Unused after remake

------------------------
-- Conditions
-- env( <condition>, <args> )
-- *<args> are optional
------------------------
IsGeneralAnimEnd = 0
IsAttackAnimEnd = 1
AnimIDOffset = 9
AdditiveBlendAnim = 10
AdditiveBlendAnimOfSlot = 11

IsAtkRequest = 100 -- args: <attack request index>
IsAtkReleaseRequest = 101
IsChainAtkRequest = 102
GetAtkDuration = 103
GetWeaponSwitchRequest = 104
GetCommandIDFromEvent = 105
GetAIActionType = 106
GetAIChainActionType = 107
GetChainEvadeRequest = 108
GetWeaponChangeRequest = 109
GetAnimIDFromMoveParam = 110
IsThereAnyAtkRequest = 111
IsThereAnyChainAtkRequest = 112
IsItemUseMenuOpening = 113
IsMagicUseMenuOpening = 114
IsItemUseMenuOpened = 115
IsMagicUseMenuOpened = 116
GetBlendAnimIDFromMoveParam = 117
GetAIChainStepType = 118
GetTransitionToSpecialStayAnimID = 119
GetAIAtkCancelType = 120
GetWeaponCancelType = 121 -- args: <hand index>
IsWeaponCancelPossible = 122
GetAIDefenseCancelType = 123
GetAIVersusBackstabCancelType = 124

IsFalling = 200
IsLanding = 201
GetReceivedDamageType = 202
IsActiveActionValid = 203
GetActionEventNumber = 204
IsNormalDmgPassThroughDuringThrow = 205
IsThrowing = 206
GetWeaponSwitchState = 207
IsEquipmentSwitchPossible = 209
IsAnimCancelPossibleInAtkRelease = 210
IsEmergencyStopAnimPlaying = 211
GetLockRangeState = 212
GetLockAngleState = 213
IsAnimCancelPossibleInDamageHit = 214
IsChangeToScrapeAtk = 215
IsChangeToDeflectAtk = 216
IsChangeToAfterParrySuccess = 217
IsChangeFromNormalToBigAtk = 218
GetMovementType = 219
IsLargeAtkComboPossible = 220
IsMapActionPossible = 221
GetReceivedDamageDirection = 222
GetMapActionID = 223
GetFallHeight = 224
GetEquipWeaponCategory = 225 -- args: <hand index>
IsHoldingBow = 226
GetMagicAnimType = 227
WasNotLargeAtk = 228
IsBackAtkPossible = 229
IsAfterParryAtkPossible = 230
GetItemAnimType = 231
IsMagicUseable = 232 -- args: <hand index>, <unknown index>
IsItemUseable = 233
IsPrecisionShoot = 234
IsFireDamaged = 235
GetDamageLevel = 236
GetGuardLevelAction = 237
IsNewLeftHandAtkFromStay = 238
IsParryFromIdle = 239
IsGuardFromIdle = 240
IsNewLeftHandAtkFromAtkCancel = 241
IsParryFromAtkCancel = 242
IsGuardFromAtkCancel = 243
IsTiedUp = 244
IsOutOfAmmo = 245 -- args: <slot index> # 1 is left slot, 0 is right slot
IsUseCatLanding = 246
GetHoverMoveState = 247
IsTruelyLanding = 248
IsRightHandMagic = 249
IsChangeToSpecialStayAnim = 250
GetSpecialStayAnimID = 251
AcquireSpecialDamageAnimationID = 252
IsRunTurnAnimPlaying = 253
IsGenerateAction = 254
GetSpecialStayCancelAnimID = 255
HasReceivedAnyDamage = 256
GetMoveAnimParamID = 257
GetGuardLevel = 258
IsRequestTurnAnimStart = 259
IsTurningWithAnim = 260
IsFlying = 261
IsAbilityInsufficient = 262 -- args: <hand index>
GetEquipWeightRatioForFalling = 263
GetFlightMotionState = 264
GetIsWeakPoint = 265
GetMoveAnimBlendRatio = 266
GetLadderActionState = 267
IsInDisguise = 268
IsCoopWait = 269
IsCoop = 270
IsSpecialTransitionPossible = 271
GetLandingAnimBlendRatio = 272
GetThrowAnimID = 273
DidOpponentDieFromThrow = 274
HasThrowEnded = 275
IsThrowSelfDeath = 276
IsThrowSuccess = 277
GetGuardMotionCategory = 278 -- args: <hand index>
IsBeingThrown = 279
IsSelfThrow = 280
IsThrowDeathState = 281
GetNewLockState = 282
IsOnLadder = 283
GetPhysicalAttribute = 284
GetSpecialAttribute = 285
GetSpecialStayDeathAnimID = 286
HasReceivedAnyDamage_AnimEnd = 287
EggGrowth_IsHeadScratch = 288
EggGrowth_IsBecomeEggHead = 289
IsStop = 290
IsSomeoneOnLadder = 291 -- args: <check distance>, <unknown index>
IsSomeoneUnderLadder = 292 -- args: <check distance>, <unknown index>
GetLadderHandState = 293
DoesLadderHaveCharacters = 294 -- args: <check distance>, <unknown index>, <unknown index>
IsLadderRightHandStayState = 295
IsDescendingToFloor = 296
IsInputDirectionMatch = 297
IsSpecialTransition2Possible = 298
IsVersusDivineDamage = 299

IsGeneralAnimCancelPossible = 300
GetEventEzStateFlag = 301 -- args: <EzState command id>
IsLadderEventEnd = 302
IsReachBottomOfLadder = 303
IsReachTopOfLadder = 304
GetStateChangeType = 305 -- args: <state change id>
IsOnLastRungOfLadder = 306
GetWeaponDurability = 311
IsWeaponBroken = 312
IsAnimEndBySkillCancel = 313
EggGrowth_IsBecomeEgghead_SecondStage = 314
IsHamariFallDeath = 315 -- args: <unknown index>
IsClient = 316
IsSlope = 317
IsSwitchState = 318
IsPressUpKey = 319
IsSpecialTurning = 320
GetIntValueForTest = 321
IsObjActInterpolatedMotion = 322
GetObjActTargetDirection = 323
GetObjActRemainingInterpolateTime = 324
IsGap = 325
GetSwordArtID = 326 -- args: <hand index>
IsMovingLaterally = 327
IsNet = 328
HasBrokenSA = 329
IsEmergencyQuickTurnActivated = 330
IsDoubleChantPossible = 331
IsAnimOver = 332
ObtainedDT = 333
GetBehaviorID = 334 -- args: <hand index>
IsTwoHandPossible = 335 -- args: <hand index>
IsPartDamageAdditiveBlendInvalid = 336
IsThrowPosRealign = 337
GetBoltLoadingState = 338 -- args: <slot index>
IsAnimEnd = 339 -- args: <unknown index>
IsTwinSwords = 340 -- args: <hand index>
GetTurnAngleForDelayedTurn = 341
GetThrowDefenseCount = 342
IsEmergencyEvasionPossible = 343 -- args: <unknown index>
HasEnoughArtsPoints = 344 -- args: <button index>, <hand index>
GetEquipWeaponSpecialCategoryNumber = 345 -- args: <hand index>
CheckForEventAnimPlaybackRequest = 346
IsFemale = 347
GetDelayTurnAngleDifference = 348
IsDamageMotionOff = 349
HasReachedStatsNeededForWeapon = 350 -- args: <hand index>  -- Checks for the attainmentWepStatus fields in EquipParamWeapon
UpperArmControlOuterAngle = 351
UpperArmControlTopAndBottomAngle = 352
CompleteLadderSlideDown = 353
GetLadderRungCount = 354
GetNumberOfRungsBelowOnLadder = 355
GetBowAndArrowSlot = 356
GetWeaponStorageSpotType = 357 -- args: <hand index>
GetStayAnimCategory = 358
GetWeaponSwitchStatus = 359
IsEquipmentMenuOpen = 360
GetRemainingArrowCount = 361
GetSpEffectType = 362 -- args: <enum> SP_EFFECT_TYPE_
IsPlayerInRangeOfMount = 363
GetEventID = 364
IsMultiplayer = 365
GetSpiritspringJumpHeight = 366
IsAutomaticTesting = 368

GetPoise = 400
GetMaxPoise = 402
GetSpEffectEventAnimID = 403
GetNpcAIAttackRequestID = 404
GetNpcAIAttackRequestIDAfterBlend = 405
GetRollAngle = 406
GetJumpAngle = 407
GetSwordArtsRollAngle = 408
GetDamageSpecialAttribute = 409 -- args: <index>

IsOnMount = 500
IsMount = 502
IsSummoningRide = 504
IsMovingOnMount = 505
IsIdleOnMount = 506
GetMountRidingAnimID = 507
GetDismountingDirection = 520
GetDismountingDirectionRun = 521
GetMountReceivedDamageDirection = 522 -- args: <unknown>
GetMountDamageLevel = 530
GetMountGuardLevel = 531
GetMountAttackDirection = 532
GetMountRecievedDamageAngle = 533
GetMountRecievedDamageType = 534
HasMountReceivedAnyDamage = 535
GetMountGuardLevelAction = 536
IsMountFalling = 537
GetMountFallHeight = 538
IsMountInFallLoop = 539
IsMountTrulyLanding = 540
IsMountFallingDeadly = 541
GetPhysicalAttributeMount = 542
GetMountSpecialAttribute = 543
GetSlope = 544
IsMountDead = 545
GetMountIsWeakPoint = 546
GetMountDamageAnimID = 547
InNoRidingArea = 548
GetMountSpEffectID = 549
GetMountSpEffectType = 550
GetMountStateInfo = 551
IsNewRidingTest = 552
GetMountBehaviorID = 553
GetMountStatusEffect = 554
IsRidingPcMount = 555

GetFlyRouteState = 600

IsAIJumpRequested = 700
IsAIJumping = 701

GetHP = 1000
GetStamina = 1001
IsGhost = 1002
GetRandomInt = 1003
GetRandomFloat = 1004
IsUnableToDie = 1005
IsResurrectionPossible = 1006
IsCOMPlayer = 1007
GetAITargetAwareState = 1008
IsAIChangeToAwareState = 1009
GetAITargetAwareStatePreviousFrame = 1010

GetTestDamageAnimID = 1100
IsInvincibleDebugMode = 1101
WasGameLaunchedInPGTestMode = 1102
IsTiltingStick = 1103
GetGestureRequestNumber = 1104
IsStayState = 1105
ActionRequest = 1106 -- args: <action arm index>
ActionCancelRequest = 1107 -- args: <action arm index>
ActionDuration = 1108 -- args: <action arm index>
HasActionRequest = 1109
MovementRequest = 1110
MovementRequestDuration = 1111
HasThrowRequest = 1112
IsGuardCancelPossible = 1113
DoesAnimExist = 1114 -- args: <anim id>, *<anim id>
GetAIMovementType = 1115
GetSpEffectID = 1116
IsConversationEnd = 1117
IsLocked = 1118
GetAtkDirection = 1119
GetPartGroup = 1120
GetKnockbackDistance = 1121

IsMoveCancelPossible = 2000
GetSpecialMovementType = 2002
GetGeneralTAEFlag = 2003 -- args: <flag>
IsSwingHitTarget = 2004
GetCeremonyState = 2005
GetSuccessiveGuardCount = 2006
GetMinLuck = 2007
GetAccumulatedLuck = 2008
GetMaxLuck = 2009
GetMaxStamina = 2010
GetGeneralMSBParameter = 2011
IsHitWall = 2012
GetSafetyDirection = 2013
IsInCeremony = 2014
IsDoingCorpseCarryKeyframe = 2015
GetFP = 2016
IsCeremonyComplete = 2017
IsCeremonyInterrupt = 2018

IsSpeaking = 3000
GetTalkBehavior = 3001
GetTalkEzStateBehaviourID = 3002

Unknown9999 = 9999

------------------------
-- Commands
-- act( <command>, <args> )
-- *<args> are optional
------------------------
ChangeGeneralAnim = 0
ChangeUpperBodyAnim = 1
ChangeStayAnim = 2
ChangeGeneralAnimCategorized = 3 -- args: <anim category>, <anim id>, <layer index>, <blend>, <isLoop>
ChangeUpperBodyAnimCategorized = 4
ChangeGeneralAnimAdditiveCategorized = 5
ChangeUpperBodyAnimAdditiveCategorized = 6
ChangeGeneralAnimCategorizedMatchPlaybackTime = 7
ChangeUpperBodyAnimCategorizedMatchPlaybackTime = 8
SetAnimIDOffset = 9
SetAdditiveBlendAnimation = 10
SetAdditiveBlendAnimationSlotted = 11
ChangeBlendAnimationCategorized = 12
ChangeUpperAndLowerBodySyncedAnimCategorized = 13

SetActiveActionState = 100
SwitchMotion = 101 -- args: <bool>
SetAllowedThrowAttackType = 102 -- args: <index> # ENUM: THROW_STATE
SetAllowedThrowDefenseType = 103 -- args: <index> # ENUM: THROW_STATE
SwitchEquippedWeapon = 104
SetReadyForAtkFinish = 105
SetEquipmentChangeable = 106
SetUnableToFall = 107
SendMessageIDToEvents = 108 -- args: <event call>
SetAttackType = 109 -- args: <index> # -1
SetStaminaRecoveryDisabled = 110
SetAIBusyDoingAction = 111
BowTurn = 112
SetBowStance = 113
SetPreciseAimMode = 114
SetSpecialMovement = 115
SetIsWeaponChanging = 116
SetIsItemInUse = 117 -- args: <bool>
SetIsMagicInUse = 118 -- args: <bool>
SetHoverState = 119
RemoveBinoculars = 120
ChangeToSpecialStay = 121
SetIsHeadTurnPossible = 122
OpenMenuWhenUsingItem = 123
OpenMenuWhenUsingMagic = 124 -- args: <action arm index>
BlowDamageTurn = 125
SetDeathStay = 126 -- args: <bool> # TRUE, FALSE
CloseMenuWhenUsingItem = 127
CloseMenuWhenUsingMagic = 128
DisallowAdditiveTurning = 129 -- args: <bool>
ChangeFlightStatus = 130
ShowFixedYAxisDirectionDisplay = 131
WhiffPossibility = 132
SetLadderActionState = 133 -- args: <index>
SetInsufficientStrengthAnimID = 134
ForceCancelThrowAnim = 135
SetThrowState = 136 -- args: <index> # ENUM: THROW_TYPE
StartSlidingDownLadder = 137
SetIsEventActionPossible = 138 -- args: <bool>
RequestThrowAnimInterrupt = 139
SetHandStateOfLadder = 140
SetDamageAnimType = 141 -- args: <index> # ENUM: DAMAGE_FLAG
DownwardSlideTurn = 142 -- args: <index>
InterruptAttack = 143
SkyDeathWarp = 144
ClearSlopeInfo = 145
ReceiveStateInput = 146
SetCanChangeEquipmentOn = 147
SetHavokVariable = 148 -- args: <string>, <value>
AimAtSelfPosition = 149
SetIsItemAnimationPlaying = 150
DoAIReplanningAtCancelTiming = 151
DenyEventAnimPlaybackRequest = 152
InvokeBackstab = 153
WeaponParameterReference = 154 -- args: <hand index>
AINotifyAttackType = 155 -- args: <index>
SetAutoCaptureTarget = 156
ClearAutoCaptureTarget = 157
RequestAIReplanning = 158
TurnTowardAttacker = 159
SetThrowPossibilityState_Attacker = 160 -- args: <index>
SetThrowPossibilityState_Defender = 161 -- args: <index>
NotifyAIMagicCast = 162
SetCanChangeEquipmentOff = 163

StateIdentifier = 200

ChangeHP = 1000 -- args: <value>
ChangeStamina = 1001 -- args: <value> # ENUM: STAMINA_REDUCE

SyncAtInit_Active = 1100
SyncAtInit_Passive = 1101

SetMovementScaleMult = 2001 -- args: <value>
AddSpEffect = 2002 -- args: <id>
SetFastStealthThrowEnabled = 2003
SetTurnSpeed = 2004 -- args: <degrees>
SetCeremonyState = 2005
SetDamageMotionBlendRatio = 2006 -- args: <value>
SetForceTurnTarget = 2007
ForceTurn = 2008
SpecialTurn = 2009
SetInSpecialGuard = 2010
SetWeaponCancelType = 2011 -- args: <index>
SetIsPreciseShootingPossible = 2012
ChooseBowAndArrowSlot = 2013 -- args: <slot index> # 0, 1
Set4DirectionMovementThreshold = 2014 -- args: <front right angle>, <front left angle>, <back left angle>, <back right angle> #
LockonSystemUnableToTurnAngle = 2015 -- args: <angle>, <angle>
ReserveArtsPointsUse = 2016 -- args: <button index>, <hand index>
SetArtsPointFEDisplayState = 2017 -- args: <value> # 0, 1
LockonFixedAngleCancel = 2018
TurnToLockonTargetImmediately = 2019 -- args: *<value>
SetSpecialInterpolation = 2020 -- args: <value>, <bool>
LadderSlideDownCancel = 2021
DisableMagicIDSwitching = 2022
DisableToolIDSwitching = 2023
UseItemDecision = 2024
SetNpcAIAttackRequestIDAfterBlend = 2025 -- args: <value>
DecideMagicUse = 2026
FallPreventionAssist = 2027
FaceDirection = 2029 -- args: <degrees>
ChangeBuddyState = 2030
PlayEventSync = 2031
AllowBuddyWarp = 2040
NotifyAIOfBehaviourState = 2050 -- args: <index>, <index> # IDX_AINOTE_STATETYPE, IDX_AINOTE_STATETYPE

Mounting = 3000
PlayRideAnim = 3003
ApplyRideBlend = 3004 -- args: <blend anim>, <rate>
Dismount = 3005
AllowMounting = 3006
ApplyDamageFlag = 3007 -- args: <index>

RequestAIJumpInterupt = 4000
NotifyAIOfJumpState = 4001
AIJumpState = 4002

DebugLogOutput = 9000
ClearSpEffect = 9001 -- args: <id>
Test_SpEffectTypeSpecifyDelete = 9002
MarkerStart = 9003
MarkerEnd = 9004

Wait = 9100
ResetInputQueue = 9101
SetIsEventAnim = 9102
SetAIAttackState = 9103 -- args: <index>
SetIsTurnAnimInProgress = 9104
SetTurnAnimCorrectionRate = 9105 -- args: <degrees>

-- CUSTOM: Begin.
SetCanChangeEquipmentOff = 163
GetNpcAIAttackRequestID = 404
IsAIJumpRequested = 700
SetNpcAIAttackRequestIDAfterBlend = 2025
FallPreventionAssist = 2027
FaceDirection = 2029
AllowBuddyWarp = 2040
NotifyAIOfJumpState = 4001
-- CUSTOM: End.

Unknown9999 = 9999 -- args: <value> # 1, 2, 3

------------------------------------------
-- Must be last for the global variables to be read
------------------------------------------
global = {}

function dummy()
end

global.__index = function(table, element)
	return dummy
end

setmetatable(_G, global)
